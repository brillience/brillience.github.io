[{"categories":null,"content":"Hello ç›®å‰ä¸“æ³¨äº ğŸ¤“ ï¼š Java ã€ Golang ã€ å¾®æœåŠ¡æ¶æ„ Github: https://github.com/brillience Email: zxb6815@gmail.com ","date":"2023-04-08","objectID":"/about/:1:0","tags":null,"title":"å…³äº","uri":"/about/"},{"categories":null,"content":"è¿‘æœŸé˜…è¯»çš„ä¹¦ç± ã€ŠGoè¯­è¨€é«˜çº§ç¼–ç¨‹ã€‹ ã€Šgo-zeroæºç åˆ†æã€‹ ã€Šæ•°æ®å¯†é›†å‹åº”ç”¨ç³»ç»Ÿè®¾è®¡ã€‹ ã€Šå‡¤å‡°æ¶æ„ã€‹ ã€ŠEffective Javaã€‹ ","date":"2023-04-08","objectID":"/about/:2:0","tags":null,"title":"å…³äº","uri":"/about/"},{"categories":null,"content":"Other ","date":"2023-04-08","objectID":"/about/:3:0","tags":null,"title":"å…³äº","uri":"/about/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è®¾è®¡æ¨¡å¼golangå®ç°","date":"2023-04-06","objectID":"/design_pattern/","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è®¾è®¡æ¨¡å¼ 6 å¤§åŸåˆ™ golang è®¾è®¡æ¨¡å¼ ** è®¾è®¡æ¨¡å¼ï¼ˆDesign patternï¼‰**æ˜¯ä¸€å¥—è¢«åå¤ä½¿ç”¨ã€å¤šæ•°äººçŸ¥æ™“çš„ã€ç»è¿‡åˆ†ç±»ç¼–ç›®çš„ã€ä»£ç è®¾è®¡ç»éªŒçš„æ€»ç»“ã€‚ä½¿ç”¨è®¾è®¡æ¨¡å¼æ˜¯ä¸ºäº†å¯é‡ç”¨ä»£ç ã€è®©ä»£ç æ›´å®¹æ˜“è¢«ä»–äººç†è§£ã€ä¿è¯ä»£ç å¯é æ€§ã€‚ æ¯«æ— ç–‘é—®ï¼Œè®¾è®¡æ¨¡å¼äºå·±äºä»–äººäºç³»ç»Ÿéƒ½æ˜¯å¤šèµ¢çš„ï¼›è®¾è®¡æ¨¡å¼ä½¿ä»£ç ç¼–åˆ¶çœŸæ­£å·¥ç¨‹åŒ–ï¼›è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹çš„åŸºçŸ³è„‰ç»œï¼Œå¦‚åŒå¤§å¦çš„ç»“æ„ä¸€æ ·ã€‚ ","date":"2023-04-06","objectID":"/design_pattern/:1:0","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"1. å¼€é—­åŸåˆ™ ä¸€ä¸ªè½¯ä»¶å®ä½“å¦‚ç±»ã€æ¨¡å—å’Œå‡½æ•°åº”è¯¥å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚æ¨¡å—åº”å°½é‡åœ¨ä¸ä¿®æ”¹åŸï¼ˆæ˜¯â€œåŸâ€ï¼ŒæŒ‡åŸæ¥çš„ä»£ç ï¼‰ä»£ç çš„æƒ…å†µä¸‹è¿›è¡Œæ‰©å±•ã€‚ ä¼˜ç‚¹ï¼š å¤ç”¨æ€§é«˜ æ˜“ç»´æŠ¤ ","date":"2023-04-06","objectID":"/design_pattern/:1:1","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"2. é‡Œæ°ä»£æ¢åŸåˆ™ ä¸€ä¸ªè½¯ä»¶å®ä½“å¦‚æœä½¿ç”¨çš„æ˜¯ä¸€ä¸ªçˆ¶ç±»çš„è¯ï¼Œé‚£ä¹ˆä¸€å®šé€‚ç”¨äºå…¶å­ç±»ï¼Œè€Œä¸”å®ƒå¯Ÿè§‰ä¸å‡ºçˆ¶ç±»å’Œå­ç±»å¯¹è±¡çš„åŒºåˆ«ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è½¯ä»¶é‡Œé¢ï¼ŒæŠŠçˆ¶ç±»æ›¿æ¢æˆå®ƒçš„å­ç±»ï¼Œç¨‹åºçš„è¡Œä¸ºæ²¡æœ‰å˜åŒ–ã€‚ ä¼˜ç‚¹ï¼š éœ€æ±‚å˜åŒ–æ—¶ï¼Œåªé¡»ç»§æ‰¿ï¼Œè€Œåˆ«çš„ä¸œè¥¿ä¸ä¼šæ”¹å˜ã€‚ç”±äºé‡Œæ°ä»£æ¢åŸåˆ™æ‰ä½¿å¾—å¼€æ”¾å°é—­æˆä¸ºå¯èƒ½ã€‚è¿™æ ·ä½¿å¾—å­ç±»åœ¨çˆ¶ç±»æ— éœ€ä¿®æ”¹çš„è¯å°±å¯ä»¥æ‰©å±•ã€‚ ","date":"2023-04-06","objectID":"/design_pattern/:1:2","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"3. å•ä¸€èŒè´£åŸåˆ™ ä¸€ä¸ªç±»åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸä¸­çš„ç›¸åº”èŒè´£ï¼Œæˆ–è€…å¯ä»¥å®šä¹‰ä¸ºï¼šå°±ä¸€ä¸ªç±»è€Œè¨€ï¼Œåº”è¯¥åªæœ‰ä¸€ä¸ªå¼•èµ·å®ƒå˜åŒ–çš„åŸå› ã€‚ å•ä¸€èŒè´£åŸåˆ™æ˜¯å®ç°é«˜å†…èšã€ä½è€¦åˆçš„æŒ‡å¯¼æ–¹é’ˆï¼Œå®ƒæ˜¯æœ€ç®€å•ä½†åˆæœ€éš¾è¿ç”¨çš„åŸåˆ™ï¼Œéœ€è¦è®¾è®¡äººå‘˜å‘ç°ç±»çš„ä¸åŒèŒè´£å¹¶å°†å…¶åˆ†ç¦»ï¼Œè€Œå‘ç°ç±»çš„å¤šé‡èŒè´£éœ€è¦è®¾è®¡äººå‘˜å…·æœ‰è¾ƒå¼ºçš„åˆ†æè®¾è®¡èƒ½åŠ›å’Œç›¸å…³å®è·µç»éªŒã€‚ ","date":"2023-04-06","objectID":"/design_pattern/:1:3","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"4. ä¾èµ–å€’ç½®åŸåˆ™ ç¨‹åºè¦ä¾èµ–äºæŠ½è±¡æ¥å£ï¼Œä¸è¦ä¾èµ–äºå…·ä½“å®ç°ã€‚ ä¼˜ç‚¹ï¼š é™ä½ç±»ä¹‹é—´çš„è€¦åˆæ€§ æé«˜ç³»ç»Ÿçš„ç¨³å®šæ€§ å¢åŠ ä»£ç çš„å¯ç»´æŠ¤æ€§ ","date":"2023-04-06","objectID":"/design_pattern/:1:4","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"5. æ¥å£éš”ç¦»åŸåˆ™ ä½¿ç”¨å¤šä¸ªä¸“é—¨çš„æ¥å£ï¼Œè€Œä¸ä½¿ç”¨å•ä¸€çš„æ€»æ¥å£ï¼Œå³å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–é‚£äº›å®ƒä¸éœ€è¦çš„æ¥å£ã€‚ ä¼˜ç‚¹ï¼š æé«˜ç³»ç»Ÿçš„çµæ´»æ€§å’Œå¯ç»´æŠ¤æ€§ ","date":"2023-04-06","objectID":"/design_pattern/:1:5","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"6. æœ€å°‘çŸ¥è¯†æ³•åˆ™ï¼ˆè¿ªç±³è±æ³•åˆ™ï¼‰ ä¸€ä¸ªè½¯ä»¶å®ä½“åº”å½“å°½å¯èƒ½å°‘åœ°ä¸å…¶ä»–å®ä½“å‘ç”Ÿç›¸äº’ä½œç”¨ã€‚ ","date":"2023-04-06","objectID":"/design_pattern/:1:6","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"åˆ›å»ºå‹æ¨¡å¼ ","date":"2023-04-06","objectID":"/design_pattern/:2:0","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ç®€å•å·¥å‚æ¨¡å¼ go è¯­è¨€æ²¡æœ‰æ„é€ å‡½æ•°ä¸€è¯´ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šå®šä¹‰ NewXXX å‡½æ•°æ¥åˆå§‹åŒ–ç›¸å…³ç±»ã€‚ NewXXX å‡½æ•°è¿”å›æ¥å£æ—¶å°±æ˜¯ç®€å•å·¥å‚æ¨¡å¼ï¼Œä¹Ÿå°±æ˜¯è¯´ Golang çš„ä¸€èˆ¬æ¨èåšæ³•å°±æ˜¯ç®€å•å·¥å‚ã€‚ åœ¨è¿™ä¸ª simplefactory åŒ…ä¸­åªæœ‰ API æ¥å£å’Œ NewAPI å‡½æ•°ä¸ºåŒ…å¤–å¯è§ï¼Œå°è£…äº†å®ç°ç»†èŠ‚ã€‚ simple.go ä»£ç : package simplefactory import \"fmt\" //API is interface type API interface { Say(name string) string } //NewAPI return Api instance by type func NewAPI(t int) API { if t == 1 { return \u0026hiAPI{} } else if t == 2 { return \u0026helloAPI{} } return nil } //hiAPI is one of API implement type hiAPI struct{} //Say hi to name func (*hiAPI) Say(name string) string { return fmt.Sprintf(\"Hi, %s\", name) } //HelloAPI is another API implement type helloAPI struct{} //Say hello to name func (*helloAPI) Say(name string) string { return fmt.Sprintf(\"Hello, %s\", name) } simple_test.go ä»£ç  package simplefactory import \"testing\" //TestType1 test get hiapi with factory func TestType1(t *testing.T) { api := NewAPI(1) s := api.Say(\"Tom\") if s != \"Hi, Tom\" { t.Fatal(\"Type1 test fail\") } } func TestType2(t *testing.T) { api := NewAPI(2) s := api.Say(\"Tom\") if s != \"Hello, Tom\" { t.Fatal(\"Type2 test fail\") } } ","date":"2023-04-06","objectID":"/design_pattern/:2:1","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"å·¥å‚æ–¹æ³•æ¨¡å¼ ç®€å•å·¥å‚æ¨¡å¼åªèƒ½ç”Ÿäº§å•ä¸€çš„äº§å“ï¼ˆè¯¥äº§å“çš„å®ç°ç»†èŠ‚å¯¹å¤–ä¸å¯è§ï¼‰ã€‚ å·¥å‚æ–¹æ³•æ¨¡å¼å¯ä»¥ç”Ÿäº§å¤šç§äº§å“ï¼Œæ‰€æœ‰äº§å“çš„å…±æ€§ç”±äº§å“åŸºç±»å®ç°ï¼Œäº§å“ä¹‹é—´çš„ä¸ªæ€§ç”±äº§å“åŸºç±»çš„å­ç±»å®ç°ã€‚å³ï¼šåˆ›å»ºè¿‡ç¨‹å»¶è¿Ÿåˆ°å­ç±»è¿›è¡Œ factorymethod.go //äº§å“åŸºç±»æ¥å£ type Operator interface { SetA(int) SetB(int) Result() int } //äº§å“åŸºç±» å®ç°äº§å“çš„å…±æ€§ //OperatorBase æ˜¯Operator æ¥å£å®ç°çš„åŸºç±»ï¼Œå°è£…å…¬ç”¨æ–¹æ³• type OperatorBase struct { a, b int } //SetA è®¾ç½® A func (o *OperatorBase) SetA(a int) { o.a = a } //SetB è®¾ç½® B func (o *OperatorBase) SetB(b int) { o.b = b } //ä¸ªæ€§äº§å“å®ç° //PlusOperator Operator çš„å®é™…åŠ æ³•å®ç° type PlusOperator struct { *OperatorBase } //Result è·å–ç»“æœ func (o PlusOperator) Result() int { return o.a + o.b } //æ­¤æ—¶ï¼ŒPlusOperator å°±æ˜¯ä¸€ä¸ª Operator çš„ â€œä¸ªæ€§äº§å“â€ //å·¥å‚å®ç° //OperatorFactory æ˜¯å·¥å‚æ¥å£ type OperatorFactory interface { Create() Operator } //PlusOperatorFactory æ˜¯ PlusOperator çš„å·¥å‚ç±» type PlusOperatorFactory struct{} func (PlusOperatorFactory) Create() Operator { return \u0026PlusOperator{ OperatorBase: \u0026OperatorBase{}, } } factorymethod_test.go package factorymethod import \"testing\" func compute(factory OperatorFactory, a, b int) int { op := factory.Create() op.SetA(a) op.SetB(b) return op.Result() } func TestOperator(t *testing.T) { var ( factory OperatorFactory ) factory = PlusOperatorFactory{} if compute(factory, 1, 2) != 3 { t.Fatal(\"error with factory method pattern\") } factory = MinusOperatorFactory{} if compute(factory, 4, 2) != 2 { t.Fatal(\"error with factory method pattern\") } } ","date":"2023-04-06","objectID":"/design_pattern/:2:2","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"æŠ½è±¡å·¥å‚æ¨¡å¼ æŠ½è±¡å·¥å‚æ¨¡å¼ï¼ˆAbstract Factory Patternï¼‰æ˜¯å›´ç»•ä¸€ä¸ªè¶…çº§å·¥å‚åˆ›å»ºå…¶ä»–å·¥å‚ã€‚è¯¥è¶…çº§å·¥å‚åˆç§°ä¸ºå…¶ä»–å·¥å‚çš„å·¥å‚ã€‚è¿™ç§ç±»å‹çš„è®¾è®¡æ¨¡å¼å±äºåˆ›å»ºå‹æ¨¡å¼ï¼Œå®ƒæä¾›äº†ä¸€ç§åˆ›å»ºå¯¹è±¡çš„æœ€ä½³æ–¹å¼ã€‚ åœ¨æŠ½è±¡å·¥å‚æ¨¡å¼ä¸­ï¼Œæ¥å£æ˜¯è´Ÿè´£åˆ›å»ºä¸€ä¸ªç›¸å…³å¯¹è±¡çš„å·¥å‚ï¼Œä¸éœ€è¦æ˜¾å¼æŒ‡å®šå®ƒä»¬çš„ç±»ã€‚æ¯ä¸ªç”Ÿæˆçš„å·¥å‚éƒ½èƒ½æŒ‰ç…§å·¥å‚æ¨¡å¼æä¾›å¯¹è±¡ã€‚ æŠ½è±¡å·¥å‚æ¨¡å¼ç”¨äºç”Ÿæˆäº§å“æ—çš„å·¥å‚ï¼Œæ‰€ç”Ÿæˆçš„å¯¹è±¡æ˜¯æœ‰å…³è”çš„ã€‚ å¦‚æœæŠ½è±¡å·¥å‚é€€åŒ–æˆç”Ÿæˆçš„å¯¹è±¡æ— å…³è”åˆ™æˆä¸ºå·¥å‚å‡½æ•°æ¨¡å¼ã€‚ æ¯”å¦‚æœ¬ä¾‹å­ä¸­ä½¿ç”¨ RDB å’Œ XML å­˜å‚¨è®¢å•ä¿¡æ¯ï¼ŒæŠ½è±¡å·¥å‚åˆ†åˆ«èƒ½ç”Ÿæˆç›¸å…³çš„ä¸»è®¢å•ä¿¡æ¯å’Œè®¢å•è¯¦æƒ…ä¿¡æ¯ã€‚ å¦‚æœä¸šåŠ¡é€»è¾‘ä¸­éœ€è¦æ›¿æ¢ä½¿ç”¨çš„æ—¶å€™åªéœ€è¦æ”¹åŠ¨å·¥å‚å‡½æ•°ç›¸å…³çš„ç±»å°±èƒ½æ›¿æ¢ä½¿ç”¨ä¸åŒçš„å­˜å‚¨æ–¹å¼äº†ã€‚ abstractfactory.go package AbstractFactory import \"fmt\" //DAOFactory DAO æŠ½è±¡æ¨¡å¼å·¥å‚æ¥å£ type DAOFactory interface { CreateOrderMainDAO() OrderMainDAO CreateOrderDetailDAO() OrderDetailDAO } //OrderMainDAO ä¸ºè®¢å•ä¸»è®°å½• type OrderMainDAO interface { SaveOrderMain() } //OrderDetailDAO ä¸ºè®¢å•è¯¦æƒ…çºªå½• type OrderDetailDAO interface { SaveOrderDetail() } //RDBMainDAP ä¸ºå…³ç³»å‹æ•°æ®åº“çš„OrderMainDAOå®ç° type RDBMainDAO struct{} //SaveOrderMain ... func (*RDBMainDAO) SaveOrderMain() { fmt.Print(\"rdb main save\\n\") } //RDBDetailDAO ä¸ºå…³ç³»å‹æ•°æ®åº“çš„OrderDetailDAOå®ç° type RDBDetailDAO struct{} // SaveOrderDetail ... func (*RDBDetailDAO) SaveOrderDetail() { fmt.Print(\"rdb detail save\\n\") } //RDBDAOFactory æ˜¯RDB æŠ½è±¡å·¥å‚å®ç° type RDBDAOFactory struct{} func (*RDBDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026RDBMainDAO{} } func (*RDBDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026RDBDetailDAO{} } //XMLMainDAO XMLå­˜å‚¨ type XMLMainDAO struct{} //SaveOrderMain ... func (*XMLMainDAO) SaveOrderMain() { fmt.Print(\"xml main save\\n\") } //XMLDetailDAO XMLå­˜å‚¨ type XMLDetailDAO struct{} // SaveOrderDetail ... func (*XMLDetailDAO) SaveOrderDetail() { fmt.Print(\"xml detail save\") } //XMLDAOFactory æ˜¯RDB æŠ½è±¡å·¥å‚å®ç° type XMLDAOFactory struct{} func (*XMLDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026XMLMainDAO{} } func (*XMLDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026XMLDetailDAO{} } abstractfactory_test.go package abstractfactory func getMainAndDetail(factory DAOFactory) { factory.CreateOrderMainDAO().SaveOrderMain() factory.CreateOrderDetailDAO().SaveOrderDetail() } func ExampleRdbFactory() { var factory DAOFactory factory = \u0026RDBDAOFactory{} getMainAndDetail(factory) // Output: // rdb main save // rdb detail save } func ExampleXmlFactory() { var factory DAOFactory factory = \u0026XMLDAOFactory{} getMainAndDetail(factory) // Output: // xml main save // xml detail save } ","date":"2023-04-06","objectID":"/design_pattern/:2:3","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"åˆ›å»ºè€…æ¨¡å¼ åˆ›å»ºè€…æ¨¡å¼ï¼šå°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºåˆ†ç¦»æˆå¤šä¸ªç®€å•å¯¹è±¡çš„æ„å»ºç»„åˆ package Builder //Builder æ˜¯ç”Ÿæˆå™¨æ¥å£ type Builder interface { Part1() Part2() Part3() } type Director struct { builder Builder } // NewDirector ... func NewDirector(builder Builder) *Director { return \u0026Director{ builder: builder, } } //Construct Product func (d *Director) Construct() { d.builder.Part1() d.builder.Part2() d.builder.Part3() } type Builder1 struct { result string } func (b *Builder1) Part1() { b.result += \"1\" } func (b *Builder1) Part2() { b.result += \"2\" } func (b *Builder1) Part3() { b.result += \"3\" } func (b *Builder1) GetResult() string { return b.result } type Builder2 struct { result int } func (b *Builder2) Part1() { b.result += 1 } func (b *Builder2) Part2() { b.result += 2 } func (b *Builder2) Part3() { b.result += 3 } func (b *Builder2) GetResult() int { return b.result } package Builder import \"testing\" func TestBuilder1(t *testing.T) { builder := \u0026Builder1{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != \"123\" { t.Fatalf(\"Builder1 fail expect 123 acture %s\", res) } } func TestBuilder2(t *testing.T) { builder := \u0026Builder2{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != 6 { t.Fatalf(\"Builder2 fail expect 6 acture %d\", res) } } ","date":"2023-04-06","objectID":"/design_pattern/:2:4","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"åŸå‹æ¨¡å¼ åŸå‹æ¨¡å¼ï¼ˆPrototype Patternï¼‰æ˜¯ç”¨äºåˆ›å»ºé‡å¤çš„å¯¹è±¡ï¼ŒåŒæ—¶åˆèƒ½ä¿è¯æ€§èƒ½ã€‚è¿™ç§ç±»å‹çš„è®¾è®¡æ¨¡å¼å±äºåˆ›å»ºå‹æ¨¡å¼ï¼Œå®ƒæä¾›äº†ä¸€ç§åˆ›å»ºå¯¹è±¡çš„æœ€ä½³æ–¹å¼ã€‚ è¿™ç§æ¨¡å¼æ˜¯å®ç°äº†ä¸€ä¸ªåŸå‹æ¥å£ï¼Œè¯¥æ¥å£ç”¨äºåˆ›å»ºå½“å‰å¯¹è±¡çš„å…‹éš†ã€‚å½“ç›´æ¥åˆ›å»ºå¯¹è±¡çš„ä»£ä»·æ¯”è¾ƒå¤§æ—¶ï¼Œåˆ™é‡‡ç”¨è¿™ç§æ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå¯¹è±¡éœ€è¦åœ¨ä¸€ä¸ªé«˜ä»£ä»·çš„æ•°æ®åº“æ“ä½œä¹‹åè¢«åˆ›å»ºã€‚æˆ‘ä»¬å¯ä»¥ç¼“å­˜è¯¥å¯¹è±¡ï¼Œåœ¨ä¸‹ä¸€ä¸ªè¯·æ±‚æ—¶è¿”å›å®ƒçš„å…‹éš†ï¼Œåœ¨éœ€è¦çš„æ—¶å€™æ›´æ–°æ•°æ®åº“ï¼Œä»¥æ­¤æ¥å‡å°‘æ•°æ®åº“è°ƒç”¨ã€‚ package ProtoType //Cloneable æ˜¯åŸå‹å¯¹è±¡éœ€è¦å®ç°çš„æ¥å£ type Cloneable interface { Clone() Cloneable } type PrototypeManager struct { prototypes map[string]Cloneable } func NewPrototypeManager() *PrototypeManager { return \u0026PrototypeManager{ prototypes: make(map[string]Cloneable), } } func (p *PrototypeManager) Get(name string) Cloneable { return p.prototypes[name] } func (p *PrototypeManager) Set(name string, prototype Cloneable) { p.prototypes[name] = prototype } package ProtoType import \"testing\" var manager *PrototypeManager type Type1 struct { name string } func (t *Type1) Clone() Cloneable { tc := *t return \u0026tc } type Type2 struct { name string } func (t *Type2) Clone() Cloneable { tc := *t return \u0026tc } func TestClone(t *testing.T) { t1 := manager.Get(\"t1\") t2 := t1.Clone() if t1 == t2 { t.Fatal(\"error! get clone not working\") } } func TestCloneFromManager(t *testing.T) { c := manager.Get(\"t1\").Clone() t1 := c.(*Type1) if t1.name != \"type1\" { t.Fatal(\"error\") } } func init() { manager = NewPrototypeManager() t1 := \u0026Type1{ name: \"type1\", } manager.Set(\"t1\", t1) } ","date":"2023-04-06","objectID":"/design_pattern/:2:5","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"å•ä¾‹æ¨¡å¼ **æ„å›¾ï¼š**ä¿è¯ä¸€ä¸ªç±»ä»…æœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªè®¿é—®å®ƒçš„å…¨å±€è®¿é—®ç‚¹ã€‚ **ä¸»è¦è§£å†³ï¼š**ä¸€ä¸ªå…¨å±€ä½¿ç”¨çš„ç±»é¢‘ç¹åœ°åˆ›å»ºä¸é”€æ¯ã€‚ **ä½•æ—¶ä½¿ç”¨ï¼š**å½“æ‚¨æƒ³æ§åˆ¶å®ä¾‹æ•°ç›®ï¼ŒèŠ‚çœç³»ç»Ÿèµ„æºçš„æ—¶å€™ã€‚ **å¦‚ä½•è§£å†³ï¼š**åˆ¤æ–­ç³»ç»Ÿæ˜¯å¦å·²ç»æœ‰è¿™ä¸ªå•ä¾‹ï¼Œå¦‚æœæœ‰åˆ™è¿”å›ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºã€‚ ä½¿ç”¨æ‡’æƒ°æ¨¡å¼çš„å•ä¾‹æ¨¡å¼ï¼Œä½¿ç”¨åŒé‡æ£€æŸ¥åŠ é”ä¿è¯çº¿ç¨‹å®‰å…¨ package Singleton import \"sync\" //Singleton æ˜¯å•ä¾‹æ¨¡å¼ç±» type Singleton struct{} var singleton *Singleton var once sync.Once //GetInstance ç”¨äºè·å–å•ä¾‹æ¨¡å¼å¯¹è±¡ func GetInstance() *Singleton { once.Do(func() { singleton = \u0026Singleton{} }) return singleton } package Singleton import ( \"sync\" \"testing\" ) const parCount = 100 func TestSingleton(t *testing.T) { ins1 := GetInstance() ins2 := GetInstance() if ins1 != ins2 { t.Fatal(\"instance is not equal\") } } func TestParallelSingleton(t *testing.T) { wg := sync.WaitGroup{} wg.Add(parCount) instances := [parCount]*Singleton{} for i := 0; i \u003c parCount; i++ { go func(index int) { instances[index] = GetInstance() wg.Done() }(i) } wg.Wait() for i := 1; i \u003c parCount; i++ { if instances[i] != instances[i-1] { t.Fatal(\"instance is not equal\") } } } ","date":"2023-04-06","objectID":"/design_pattern/:2:6","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ç»“æ„å‹æ¨¡å¼ ","date":"2023-04-06","objectID":"/design_pattern/:3:0","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ä»£ç†æ¨¡å¼ ç»“æ„å‹æ¨¡å¼ï¼šæè¿°å¦‚ä½•å°†ç±»æˆ–å¯¹è±¡æŒ‰ç…§æŸç§æ–¹å¼ç»„ç»‡æˆæ›´å¤§çš„ç»“æ„ã€‚ å®¢æˆ·ç«¯ä¸ç›´æ¥å£°æ˜çœŸå®ä¸»ä½“ï¼Œè€Œæ˜¯å£°æ˜ä»£ç†ç±»ï¼Œé€šè¿‡è°ƒç”¨ä»£ç†ç±»çš„æ–¹æ³•æ¥é—´æ¥æ‰§è¡ŒçœŸå®ä¸»ä½“ç±»çš„è¡Œä¸ºã€‚ package proxy type Subject interface { Do() string } type RealSubject struct{} func (RealSubject) Do() string { return \"real\" } type Proxy struct { real RealSubject } func (p Proxy) Do() string { var res string // åœ¨è°ƒç”¨çœŸå®å¯¹è±¡ä¹‹å‰çš„å·¥ä½œï¼Œæ£€æŸ¥ç¼“å­˜ï¼Œåˆ¤æ–­æƒé™ï¼Œå®ä¾‹åŒ–çœŸå®å¯¹è±¡ç­‰ã€‚ã€‚ res += \"pre:\" // è°ƒç”¨çœŸå®å¯¹è±¡ res += p.real.Do() // è°ƒç”¨ä¹‹åçš„æ“ä½œï¼Œå¦‚ç¼“å­˜ç»“æœï¼Œå¯¹ç»“æœè¿›è¡Œå¤„ç†ç­‰ã€‚ã€‚ res += \":after\" return res } ","date":"2023-04-06","objectID":"/design_pattern/:3:1","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"é€‚é…å™¨æ¨¡å¼ é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦å¤–ä¸€ä¸ªæ¥å£ï¼Œä½¿å¾—åŸæœ¬ç”±äºæ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œçš„é‚£äº›ç±»èƒ½ä¸€èµ·å·¥ä½œã€‚ è¯´ç™½äº†å°±æ˜¯è®©é€‚é…è€…çš„å®ç°ç±»ï¼ŒåŒæ—¶å®ç°é€‚é…å™¨çš„æ¥å£å’Œç›®æ ‡ç±»çš„æ¥å£ã€‚ package adapter //Target æ˜¯é€‚é…çš„ç›®æ ‡æ¥å£ type Target interface { Request() string } //Adaptee æ˜¯è¢«é€‚é…çš„ç›®æ ‡æ¥å£ type Adaptee interface { SpecificRequest() string } //NewAdaptee æ˜¯è¢«é€‚é…æ¥å£çš„å·¥å‚å‡½æ•° func NewAdaptee() Adaptee { return \u0026adapteeImpl{} } //AdapteeImpl æ˜¯è¢«é€‚é…çš„ç›®æ ‡ç±» type adapteeImpl struct{} //SpecificRequest æ˜¯ç›®æ ‡ç±»çš„ä¸€ä¸ªæ–¹æ³• func (*adapteeImpl) SpecificRequest() string { return \"adaptee method\" } //NewAdapter æ˜¯Adapterçš„å·¥å‚å‡½æ•° func NewAdapter(adaptee Adaptee) Target { return \u0026adapter{ Adaptee: adaptee, } } //Adapter æ˜¯è½¬æ¢Adapteeä¸ºTargetæ¥å£çš„é€‚é…å™¨ type adapter struct { Adaptee } //Request å®ç°Targetæ¥å£ func (a *adapter) Request() string { return a.SpecificRequest() } ","date":"2023-04-06","objectID":"/design_pattern/:3:2","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"æ¡¥æ¥æ¨¡å¼ æ¡¥æ¥ï¼ˆBridgeï¼‰æ¨¡å¼çš„å®šä¹‰å¦‚ä¸‹ï¼šå°†æŠ½è±¡ä¸å®ç°åˆ†ç¦»ï¼Œä½¿å®ƒä»¬å¯ä»¥ç‹¬ç«‹å˜åŒ–ã€‚å®ƒæ˜¯ç”¨ç»„åˆå…³ç³»ä»£æ›¿ç»§æ‰¿å…³ç³»æ¥å®ç°ï¼Œä»è€Œé™ä½äº†æŠ½è±¡å’Œå®ç°è¿™ä¸¤ä¸ªå¯å˜ç»´åº¦çš„è€¦åˆåº¦ã€‚ æ¡¥æ¥ï¼ˆBridgeï¼‰æ¨¡å¼çš„ä¼˜ç‚¹æ˜¯ï¼š æŠ½è±¡ä¸å®ç°åˆ†ç¦»ï¼Œæ‰©å±•èƒ½åŠ›å¼º ç¬¦åˆå¼€é—­åŸåˆ™ ç¬¦åˆåˆæˆå¤ç”¨åŸåˆ™ å…¶å®ç°ç»†èŠ‚å¯¹å®¢æˆ·é€æ˜ ç¼ºç‚¹æ˜¯ï¼šç”±äºèšåˆå…³ç³»å»ºç«‹åœ¨æŠ½è±¡å±‚ï¼Œè¦æ±‚å¼€å‘è€…é’ˆå¯¹æŠ½è±¡åŒ–è¿›è¡Œè®¾è®¡ä¸ç¼–ç¨‹ï¼Œèƒ½æ­£ç¡®åœ°è¯†åˆ«å‡ºç³»ç»Ÿä¸­ä¸¤ä¸ªç‹¬ç«‹å˜åŒ–çš„ç»´åº¦ï¼Œè¿™å¢åŠ äº†ç³»ç»Ÿçš„ç†è§£ä¸è®¾è®¡éš¾åº¦ã€‚ package bridge import \"fmt\" // æŠ½è±¡æ¶ˆæ¯ type AbstractMessage interface { SendMessage(text, to string) } //æ¶ˆæ¯çš„å®æ–½è€… type MessageImplementer interface { Send(text, to string) } type MessageSMS struct{} //ä¸åŒçš„åŠŸèƒ½ï¼›è¿™äº›åŠŸèƒ½éƒ½è¦è¿”å›æ¶ˆæ¯çš„å®æ–½è€…è¿™ä¸ªæ¥å£ func ViaSMS() MessageImplementer { return \u0026MessageSMS{} } func (*MessageSMS) Send(text, to string) { fmt.Printf(\"send %s to %s via SMS\", text, to) } type MessageEmail struct{} //ä¸åŒçš„åŠŸèƒ½ func ViaEmail() MessageImplementer { return \u0026MessageEmail{} } func (*MessageEmail) Send(text, to string) { fmt.Printf(\"send %s to %s via Email\", text, to) } type CommonMessage struct { method MessageImplementer } func NewCommonMessage(method MessageImplementer) *CommonMessage { return \u0026CommonMessage{ method: method, } } func (m *CommonMessage) SendMessage(text, to string) { m.method.Send(text, to) } type UrgencyMessage struct { method MessageImplementer } func NewUrgencyMessage(method MessageImplementer) *UrgencyMessage { return \u0026UrgencyMessage{ method: method, } } func (m *UrgencyMessage) SendMessage(text, to string) { m.method.Send(fmt.Sprintf(\"[Urgency] %s\", text), to) } ","date":"2023-04-06","objectID":"/design_pattern/:3:3","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è£…é¥°å™¨æ¨¡å¼ è£…é¥°å™¨ï¼ˆDecoratorï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šæŒ‡åœ¨ä¸æ”¹å˜ç°æœ‰å¯¹è±¡ç»“æ„çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€åœ°ç»™è¯¥å¯¹è±¡å¢åŠ ä¸€äº›èŒè´£ï¼ˆå³å¢åŠ å…¶é¢å¤–åŠŸèƒ½ï¼‰çš„æ¨¡å¼ï¼Œå®ƒå±äºå¯¹è±¡ç»“æ„å‹æ¨¡å¼ã€‚ è£…é¥°å™¨æ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹æœ‰ï¼š è£…é¥°å™¨æ˜¯ç»§æ‰¿çš„æœ‰åŠ›è¡¥å……ï¼Œæ¯”ç»§æ‰¿çµæ´»ï¼Œåœ¨ä¸æ”¹å˜åŸæœ‰å¯¹è±¡çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€çš„ç»™ä¸€ä¸ªå¯¹è±¡æ‰©å±•åŠŸèƒ½ï¼Œå³æ’å³ç”¨ é€šè¿‡ä½¿ç”¨ä¸ç”¨è£…é¥°ç±»åŠè¿™äº›è£…é¥°ç±»çš„æ’åˆ—ç»„åˆï¼Œå¯ä»¥å®ç°ä¸åŒæ•ˆæœ è£…é¥°å™¨æ¨¡å¼å®Œå…¨éµå®ˆå¼€é—­åŸåˆ™ å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼šè£…é¥°å™¨æ¨¡å¼ä¼šå¢åŠ è®¸å¤šå­ç±»ï¼Œè¿‡åº¦ä½¿ç”¨ä¼šå¢åŠ ç¨‹åºå¾—å¤æ‚æ€§ã€‚ package decorator // ç»„ä»¶æ¥å£ type Component interface { Calc() int } // å…·ä½“ç»„ä»¶ type ConcreteComponent struct{} func (*ConcreteComponent) Calc() int { return 0 } //ä¹˜æ³•è£…é¥°å™¨ type MulDecorator struct { Component num int } func WarpMulDecorator(c Component, num int) Component { return \u0026MulDecorator{ Component: c, num: num, } } func (d *MulDecorator) Calc() int { return d.Component.Calc() * d.num } //åŠ æ³•è£…é¥°å™¨ type AddDecorator struct { Component num int } func WarpAddDecorator(c Component, num int) Component { return \u0026AddDecorator{ Component: c, num: num, } } func (d *AddDecorator) Calc() int { return d.Component.Calc() + d.num } ","date":"2023-04-06","objectID":"/design_pattern/:3:4","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"å¤–è§‚æ¨¡å¼ å¤–è§‚ï¼ˆFacadeï¼‰æ¨¡å¼åˆå«ä½œé—¨é¢æ¨¡å¼ï¼Œæ˜¯ä¸€ç§é€šè¿‡ä¸ºå¤šä¸ªå¤æ‚çš„å­ç³»ç»Ÿæä¾›ä¸€ä¸ªä¸€è‡´çš„æ¥å£ï¼Œè€Œä½¿è¿™äº›å­ç³»ç»Ÿæ›´åŠ å®¹æ˜“è¢«è®¿é—®çš„æ¨¡å¼ã€‚è¯¥æ¨¡å¼å¯¹å¤–æœ‰ä¸€ä¸ªç»Ÿä¸€æ¥å£ï¼Œå¤–éƒ¨åº”ç”¨ç¨‹åºä¸ç”¨å…³å¿ƒå†…éƒ¨å­ç³»ç»Ÿçš„å…·ä½“ç»†èŠ‚ï¼Œè¿™æ ·ä¼šå¤§å¤§é™ä½åº”ç”¨ç¨‹åºçš„å¤æ‚åº¦ï¼Œæé«˜äº†ç¨‹åºçš„å¯ç»´æŠ¤æ€§ã€‚ å¤–è§‚ï¼ˆFacadeï¼‰æ¨¡å¼æ˜¯â€œè¿ªç±³ç‰¹æ³•åˆ™â€çš„å…¸å‹åº”ç”¨ï¼Œå®ƒæœ‰ä»¥ä¸‹ä¸»è¦ä¼˜ç‚¹ã€‚ é™ä½äº†å­ç³»ç»Ÿä¸å®¢æˆ·ç«¯ä¹‹é—´çš„è€¦åˆåº¦ï¼Œä½¿å¾—å­ç³»ç»Ÿçš„å˜åŒ–ä¸ä¼šå½±å“è°ƒç”¨å®ƒçš„å®¢æˆ·ç±»ã€‚ å¯¹å®¢æˆ·å±è”½äº†å­ç³»ç»Ÿç»„ä»¶ï¼Œå‡å°‘äº†å®¢æˆ·å¤„ç†çš„å¯¹è±¡æ•°ç›®ï¼Œå¹¶ä½¿å¾—å­ç³»ç»Ÿä½¿ç”¨èµ·æ¥æ›´åŠ å®¹æ˜“ã€‚ é™ä½äº†å¤§å‹è½¯ä»¶ç³»ç»Ÿä¸­çš„ç¼–è¯‘ä¾èµ–æ€§ï¼Œç®€åŒ–äº†ç³»ç»Ÿåœ¨ä¸åŒå¹³å°ä¹‹é—´çš„ç§»æ¤è¿‡ç¨‹ï¼Œå› ä¸ºç¼–è¯‘ä¸€ä¸ªå­ç³»ç»Ÿä¸ä¼šå½±å“å…¶ä»–çš„å­ç³»ç»Ÿï¼Œä¹Ÿä¸ä¼šå½±å“å¤–è§‚å¯¹è±¡ã€‚ å¤–è§‚ï¼ˆFacadeï¼‰æ¨¡å¼çš„ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ ä¸èƒ½å¾ˆå¥½åœ°é™åˆ¶å®¢æˆ·ä½¿ç”¨å­ç³»ç»Ÿç±»ï¼Œå¾ˆå®¹æ˜“å¸¦æ¥æœªçŸ¥é£é™©ã€‚ å¢åŠ æ–°çš„å­ç³»ç»Ÿå¯èƒ½éœ€è¦ä¿®æ”¹å¤–è§‚ç±»æˆ–å®¢æˆ·ç«¯çš„æºä»£ç ï¼Œè¿èƒŒäº†â€œå¼€é—­åŸåˆ™â€ã€‚ package main import ( \"fmt\" ) type DataHandler struct { decoder *Decoder //è§£ç å­ç³»ç»Ÿ handler *MainHandler //å¤„ç†å­ç³»ç»Ÿ encoder *Encoder //ç¼–ç å­ç³»ç»Ÿ } func (pD *DataHandler) Working() { pD.decoder.Working() pD.handler.Working() pD.encoder.Working() } type Decoder struct { } func (pD *Decoder) Working() { fmt.Println(\"è§£ç å­ç³»ç»Ÿå…ˆXXXæ ¼å¼æ•°æ®,å¹¶è½¬æ¢ä¸ºxxxxç»“æ„æ•°æ®\") } type MainHandler struct { } func (pM *MainHandler) Working() { fmt.Println(\"æ•°æ®å¤„ç†å­ç³»ç»Ÿï¼Œå¤„ç†æ•°æ®\") } type Encoder struct { } func (pE *Encoder) Working() { fmt.Println(\"ç¼–ç å­ç³»ç»Ÿå°†xxxæ•°æ®æ ¼å¼è½¬æ¢ä¸ºJsonæ ¼å¼\") } func main() { worker := \u0026DataHandler{decoder: \u0026Decoder{}, handler: \u0026MainHandler{}, encoder: \u0026Encoder{}} worker.Working() return } ","date":"2023-04-06","objectID":"/design_pattern/:3:5","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"äº«å…ƒæ¨¡å¼ äº«å…ƒï¼ˆFlyweightï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šè¿ç”¨å…±äº«æŠ€æœ¯æ¥æœ‰æ•ˆåœ°æ”¯æŒå¤§é‡ç»†ç²’åº¦å¯¹è±¡çš„å¤ç”¨ã€‚å®ƒé€šè¿‡å…±äº«å·²ç»å­˜åœ¨çš„å¯¹è±¡æ¥å¤§å¹…åº¦å‡å°‘éœ€è¦åˆ›å»ºçš„å¯¹è±¡æ•°é‡ã€é¿å…å¤§é‡ç›¸ä¼¼ç±»çš„å¼€é”€ï¼Œä»è€Œæé«˜ç³»ç»Ÿèµ„æºçš„åˆ©ç”¨ç‡ã€‚ äº«å…ƒæ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹æ˜¯ï¼šç›¸åŒå¯¹è±¡åªè¦ä¿å­˜ä¸€ä»½ï¼Œè¿™é™ä½äº†ç³»ç»Ÿä¸­å¯¹è±¡çš„æ•°é‡ï¼Œä»è€Œé™ä½äº†ç³»ç»Ÿä¸­ç»†ç²’åº¦å¯¹è±¡ç»™å†…å­˜å¸¦æ¥çš„å‹åŠ›ã€‚ å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼š ä¸ºäº†ä½¿å¯¹è±¡å¯ä»¥å…±äº«ï¼Œéœ€è¦å°†ä¸€äº›ä¸èƒ½å…±äº«çš„çŠ¶æ€å¤–éƒ¨åŒ–ï¼Œè¿™å°†å¢åŠ ç¨‹åºçš„å¤æ‚æ€§ã€‚ è¯»å–äº«å…ƒæ¨¡å¼çš„å¤–éƒ¨çŠ¶æ€ä¼šä½¿å¾—è¿è¡Œæ—¶é—´ç¨å¾®å˜é•¿ã€‚ äº«å…ƒæ¨¡å¼å°è¯•é‡ç”¨ç°æœ‰çš„åŒç±»å¯¹è±¡ï¼Œå¦‚æœæœªæ‰¾åˆ°åŒ¹é…çš„å¯¹è±¡ï¼Œåˆ™åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚ //Shape æ¨¡å‹æ¥å£ type Shape interface { Draw() } //Circle åœ†å½¢ç±» type Circle struct { X int Y int Radius int Color string } //NewCircle å®ä¾‹åŒ–åœ†å½¢ç±» func NewCircle(color string) *Circle { return \u0026Circle{ Color: color, } } //SetX è®¾ç½®åœ†å½¢ç±»çš„xè½´ func (c *Circle) SetX(x int) { c.X = x } //SetY è®¾ç½®åœ†å½¢ç±»çš„yè½´ func (c *Circle) SetY(y int) { c.Y = y } //SetRadius è®¾ç½®åœ†å½¢ç±»çš„åŠå¾„ func (c *Circle) SetRadius(radius int) { c.Radius = radius } //Draw åœ†å½¢ç±»çš„Drawæ–¹æ³•ï¼Œå®ç°Shapeæ¥å£ func (c *Circle) Draw() { fmt.Printf(\"Circle Draw() [Color: %s, x: %d, y: %d, radius: %d] \\n\", c.Color, c.X, c.Y, c.Radius) } //ShapeFactory æ¨¡å‹å·¥å‚ç±»ï¼ŒåŒ…å«ä¸€ä¸ªcircleçš„map type ShapeFactory struct { circleMap map[string]Shape } //NewShapeFactory å®ä¾‹åŒ–æ¨¡å‹å·¥å‚ç±» func NewShapeFactory() *ShapeFactory { return \u0026ShapeFactory{ circleMap: make(map[string]Shape), } } //GetCircle è·å–ä¸€ä¸ªåœ†å½¢å®ä¾‹ //color: éœ€è¦è·å–å®ä¾‹çš„é¢œè‰² func (sf *ShapeFactory) GetCircle(color string) Shape { circle := sf.circleMap[color] if circle == nil { circle = NewCircle(color) sf.circleMap[color] = circle fmt.Println(\"Creating circleof color: \", color) } return circle } ","date":"2023-04-06","objectID":"/design_pattern/:3:6","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ç»„åˆæ¨¡å¼ ç»„åˆï¼ˆComposite Patternï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šæœ‰æ—¶åˆå«ä½œæ•´ä½“-éƒ¨åˆ†ï¼ˆPart-Wholeï¼‰æ¨¡å¼ï¼Œå®ƒæ˜¯ä¸€ç§å°†å¯¹è±¡ç»„åˆæˆæ ‘çŠ¶çš„å±‚æ¬¡ç»“æ„çš„æ¨¡å¼ï¼Œç”¨æ¥è¡¨ç¤ºâ€œæ•´ä½“-éƒ¨åˆ†â€çš„å…³ç³»ï¼Œä½¿ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡å…·æœ‰ä¸€è‡´çš„è®¿é—®æ€§ï¼Œå±äºç»“æ„å‹è®¾è®¡æ¨¡å¼ã€‚ ç»„åˆæ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹æœ‰ï¼š ç»„åˆæ¨¡å¼ä½¿å¾—å®¢æˆ·ç«¯ä»£ç å¯ä»¥ä¸€è‡´åœ°å¤„ç†å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡ï¼Œæ— é¡»å…³å¿ƒè‡ªå·±å¤„ç†çš„æ˜¯å•ä¸ªå¯¹è±¡ï¼Œè¿˜æ˜¯ç»„åˆå¯¹è±¡ï¼Œè¿™ç®€åŒ–äº†å®¢æˆ·ç«¯ä»£ç ï¼› æ›´å®¹æ˜“åœ¨ç»„åˆä½“å†…åŠ å…¥æ–°çš„å¯¹è±¡ï¼Œå®¢æˆ·ç«¯ä¸ä¼šå› ä¸ºåŠ å…¥äº†æ–°çš„å¯¹è±¡è€Œæ›´æ”¹æºä»£ç ï¼Œæ»¡è¶³â€œå¼€é—­åŸåˆ™â€ï¼› å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼š è®¾è®¡è¾ƒå¤æ‚ï¼Œå®¢æˆ·ç«¯éœ€è¦èŠ±æ›´å¤šæ—¶é—´ç†æ¸…ç±»ä¹‹é—´çš„å±‚æ¬¡å…³ç³»ï¼› ä¸å®¹æ˜“é™åˆ¶å®¹å™¨ä¸­çš„æ„ä»¶ï¼› ä¸å®¹æ˜“ç”¨ç»§æ‰¿çš„æ–¹æ³•æ¥å¢åŠ æ„ä»¶çš„æ–°åŠŸèƒ½ï¼› package composite import ( \"container/list\" \"reflect\" \"strconv\" ) //Employee èŒå‘˜ç±» type Employee struct { Name string Dept string Salary int Subordinates *list.List } //NewEmployee å®ä¾‹åŒ–èŒå‘˜ç±» func NewEmployee(name, dept string, salary int) *Employee { sub := list.New() return \u0026Employee{ Name: name, Dept: dept, Salary: salary, Subordinates: sub, } } //Add æ·»åŠ èŒå‘˜çš„ä¸‹å± func (e *Employee) Add(emp Employee) { e.Subordinates.PushBack(emp) } //Remove åˆ é™¤èŒå‘˜çš„ä¸‹å± func (e *Employee) Remove(emp Employee) { for i := e.Subordinates.Front(); i != nil; i = i.Next() { if reflect.DeepEqual(i.Value, emp) { e.Subordinates.Remove(i) } } } //GetSubordinates è·å–èŒå‘˜ä¸‹å±åˆ—è¡¨ func (e *Employee) GetSubordinates() *list.List { return e.Subordinates } //ToString è·å–èŒå‘˜çš„stringä¿¡æ¯ func (e *Employee) ToString() string { return \"[ Name: \" + e.Name + \", dept: \" + e.Dept + \", Salary: \" + strconv.Itoa(e.Salary) + \" ]\" } ","date":"2023-04-06","objectID":"/design_pattern/:3:7","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è¡Œä¸ºå‹æ¨¡å¼ ","date":"2023-04-06","objectID":"/design_pattern/:4:0","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è´£ä»»é“¾æ¨¡å¼ è´£ä»»é“¾ï¼ˆChain of Responsibilityï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šä¸ºäº†é¿å…è¯·æ±‚å‘é€è€…ä¸å¤šä¸ªè¯·æ±‚å¤„ç†è€…è€¦åˆåœ¨ä¸€èµ·ï¼Œäºæ˜¯å°†æ‰€æœ‰è¯·æ±‚çš„å¤„ç†è€…é€šè¿‡å‰ä¸€å¯¹è±¡è®°ä½å…¶ä¸‹ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è€Œè¿æˆä¸€æ¡é“¾ï¼›å½“æœ‰è¯·æ±‚å‘ç”Ÿæ—¶ï¼Œå¯å°†è¯·æ±‚æ²¿ç€è¿™æ¡é“¾ä¼ é€’ï¼Œç›´åˆ°æœ‰å¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚ æ³¨æ„ï¼šè´£ä»»é“¾æ¨¡å¼ä¹Ÿå«èŒè´£é“¾æ¨¡å¼ã€‚ è´£ä»»é“¾æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ é™ä½äº†å¯¹è±¡ä¹‹é—´çš„è€¦åˆåº¦ã€‚è¯¥æ¨¡å¼ä½¿å¾—ä¸€ä¸ªå¯¹è±¡æ— é¡»çŸ¥é“åˆ°åº•æ˜¯å“ªä¸€ä¸ªå¯¹è±¡å¤„ç†å…¶è¯·æ±‚ä»¥åŠé“¾çš„ç»“æ„ï¼Œå‘é€è€…å’Œæ¥æ”¶è€…ä¹Ÿæ— é¡»æ‹¥æœ‰å¯¹æ–¹çš„æ˜ç¡®ä¿¡æ¯ã€‚ å¢å¼ºäº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€‚å¯ä»¥æ ¹æ®éœ€è¦å¢åŠ æ–°çš„è¯·æ±‚å¤„ç†ç±»ï¼Œæ»¡è¶³å¼€é—­åŸåˆ™ã€‚ å¢å¼ºäº†ç»™å¯¹è±¡æŒ‡æ´¾èŒè´£çš„çµæ´»æ€§ã€‚å½“å·¥ä½œæµç¨‹å‘ç”Ÿå˜åŒ–ï¼Œå¯ä»¥åŠ¨æ€åœ°æ”¹å˜é“¾å†…çš„æˆå‘˜æˆ–è€…è°ƒåŠ¨å®ƒä»¬çš„æ¬¡åºï¼Œä¹Ÿå¯åŠ¨æ€åœ°æ–°å¢æˆ–è€…åˆ é™¤è´£ä»»ã€‚ è´£ä»»é“¾ç®€åŒ–äº†å¯¹è±¡ä¹‹é—´çš„è¿æ¥ã€‚æ¯ä¸ªå¯¹è±¡åªéœ€ä¿æŒä¸€ä¸ªæŒ‡å‘å…¶åç»§è€…çš„å¼•ç”¨ï¼Œä¸éœ€ä¿æŒå…¶ä»–æ‰€æœ‰å¤„ç†è€…çš„å¼•ç”¨ï¼Œè¿™é¿å…äº†ä½¿ç”¨ä¼—å¤šçš„ if æˆ–è€… ifÂ·Â·Â·else è¯­å¥ã€‚ è´£ä»»åˆ†æ‹…ã€‚æ¯ä¸ªç±»åªéœ€è¦å¤„ç†è‡ªå·±è¯¥å¤„ç†çš„å·¥ä½œï¼Œä¸è¯¥å¤„ç†çš„ä¼ é€’ç»™ä¸‹ä¸€ä¸ªå¯¹è±¡å®Œæˆï¼Œæ˜ç¡®å„ç±»çš„è´£ä»»èŒƒå›´ï¼Œç¬¦åˆç±»çš„å•ä¸€èŒè´£åŸåˆ™ã€‚ å…¶ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ ä¸èƒ½ä¿è¯æ¯ä¸ªè¯·æ±‚ä¸€å®šè¢«å¤„ç†ã€‚ç”±äºä¸€ä¸ªè¯·æ±‚æ²¡æœ‰æ˜ç¡®çš„æ¥æ”¶è€…ï¼Œæ‰€ä»¥ä¸èƒ½ä¿è¯å®ƒä¸€å®šä¼šè¢«å¤„ç†ï¼Œè¯¥è¯·æ±‚å¯èƒ½ä¸€ç›´ä¼ åˆ°é“¾çš„æœ«ç«¯éƒ½å¾—ä¸åˆ°å¤„ç†ã€‚ å¯¹æ¯”è¾ƒé•¿çš„èŒè´£é“¾ï¼Œè¯·æ±‚çš„å¤„ç†å¯èƒ½æ¶‰åŠå¤šä¸ªå¤„ç†å¯¹è±¡ï¼Œç³»ç»Ÿæ€§èƒ½å°†å—åˆ°ä¸€å®šå½±å“ã€‚ èŒè´£é“¾å»ºç«‹çš„åˆç†æ€§è¦é å®¢æˆ·ç«¯æ¥ä¿è¯ï¼Œå¢åŠ äº†å®¢æˆ·ç«¯çš„å¤æ‚æ€§ï¼Œå¯èƒ½ä¼šç”±äºèŒè´£é“¾çš„é”™è¯¯è®¾ç½®è€Œå¯¼è‡´ç³»ç»Ÿå‡ºé”™ï¼Œå¦‚å¯èƒ½ä¼šé€ æˆå¾ªç¯è°ƒç”¨ã€‚ // Package chain_of_responsibility is an example of the Chain Of Responsibility Pattern. package chain_of_responsibility // Handler provides a handler interface. type Handler interface { SendRequest(message int) string } // ConcreteHandlerA implements handler \"A\". type ConcreteHandlerA struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerA) SendRequest(message int) (result string) { if message == 1 { result = \"Im handler 1\" } else if h.next != nil { result = h.next.SendRequest(message) } return } // ConcreteHandlerB implements handler \"B\". type ConcreteHandlerB struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerB) SendRequest(message int) (result string) { if message == 2 { result = \"Im handler 2\" } else if h.next != nil { result = h.next.SendRequest(message) } return } // ConcreteHandlerC implements handler \"C\". type ConcreteHandlerC struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerC) SendRequest(message int) (result string) { if message == 3 { result = \"Im handler 3\" } else if h.next != nil { result = h.next.SendRequest(message) } return } ","date":"2023-04-06","objectID":"/design_pattern/:4:1","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"å‘½ä»¤æ¨¡å¼ å‘½ä»¤ï¼ˆCommandï¼‰æ¨¡å¼çš„å®šä¹‰å¦‚ä¸‹ï¼šå°†ä¸€ä¸ªè¯·æ±‚å°è£…ä¸ºä¸€ä¸ªå¯¹è±¡ï¼Œä½¿å‘å‡ºè¯·æ±‚çš„è´£ä»»å’Œæ‰§è¡Œè¯·æ±‚çš„è´£ä»»åˆ†å‰²å¼€ã€‚è¿™æ ·ä¸¤è€…ä¹‹é—´é€šè¿‡å‘½ä»¤å¯¹è±¡è¿›è¡Œæ²Ÿé€šï¼Œè¿™æ ·æ–¹ä¾¿å°†å‘½ä»¤å¯¹è±¡è¿›è¡Œå‚¨å­˜ã€ä¼ é€’ã€è°ƒç”¨ã€å¢åŠ ä¸ç®¡ç†ã€‚ å‘½ä»¤æ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ é€šè¿‡å¼•å…¥ä¸­é—´ä»¶ï¼ˆæŠ½è±¡æ¥å£ï¼‰é™ä½ç³»ç»Ÿçš„è€¦åˆåº¦ã€‚ æ‰©å±•æ€§è‰¯å¥½ï¼Œå¢åŠ æˆ–åˆ é™¤å‘½ä»¤éå¸¸æ–¹ä¾¿ã€‚é‡‡ç”¨å‘½ä»¤æ¨¡å¼å¢åŠ ä¸åˆ é™¤å‘½ä»¤ä¸ä¼šå½±å“å…¶ä»–ç±»ï¼Œä¸”æ»¡è¶³â€œå¼€é—­åŸåˆ™â€ã€‚ å¯ä»¥å®ç°å®å‘½ä»¤ã€‚å‘½ä»¤æ¨¡å¼å¯ä»¥ä¸ç»„åˆæ¨¡å¼ç»“åˆï¼Œå°†å¤šä¸ªå‘½ä»¤è£…é…æˆä¸€ä¸ªç»„åˆå‘½ä»¤ï¼Œå³å®å‘½ä»¤ã€‚ æ–¹ä¾¿å®ç° Undo å’Œ Redo æ“ä½œã€‚å‘½ä»¤æ¨¡å¼å¯ä»¥ä¸åé¢ä»‹ç»çš„å¤‡å¿˜å½•æ¨¡å¼ç»“åˆï¼Œå®ç°å‘½ä»¤çš„æ’¤é”€ä¸æ¢å¤ã€‚ å¯ä»¥åœ¨ç°æœ‰å‘½ä»¤çš„åŸºç¡€ä¸Šï¼Œå¢åŠ é¢å¤–åŠŸèƒ½ã€‚æ¯”å¦‚æ—¥å¿—è®°å½•ï¼Œç»“åˆè£…é¥°å™¨æ¨¡å¼ä¼šæ›´åŠ çµæ´»ã€‚ å…¶ç¼ºç‚¹æ˜¯ï¼š å¯èƒ½äº§ç”Ÿå¤§é‡å…·ä½“çš„å‘½ä»¤ç±»ã€‚å› ä¸ºæ¯ä¸€ä¸ªå…·ä½“æ“ä½œéƒ½éœ€è¦è®¾è®¡ä¸€ä¸ªå…·ä½“å‘½ä»¤ç±»ï¼Œè¿™ä¼šå¢åŠ ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚ å‘½ä»¤æ¨¡å¼çš„ç»“æœå…¶å®å°±æ˜¯æ¥æ”¶æ–¹çš„æ‰§è¡Œç»“æœï¼Œä½†æ˜¯ä¸ºäº†ä»¥å‘½ä»¤çš„å½¢å¼è¿›è¡Œæ¶æ„ã€è§£è€¦è¯·æ±‚ä¸å®ç°ï¼Œå¼•å…¥äº†é¢å¤–ç±»å‹ç»“æ„ï¼ˆå¼•å…¥äº†è¯·æ±‚æ–¹ä¸æŠ½è±¡å‘½ä»¤æ¥å£ï¼‰ï¼Œå¢åŠ äº†ç†è§£ä¸Šçš„å›°éš¾ã€‚ä¸è¿‡è¿™ä¹Ÿæ˜¯è®¾è®¡æ¨¡å¼çš„é€šç—…ï¼ŒæŠ½è±¡å¿…ç„¶ä¼šé¢å¤–å¢åŠ ç±»çš„æ•°é‡ï¼Œä»£ç æŠ½ç¦»è‚¯å®šæ¯”ä»£ç èšåˆæ›´åŠ éš¾ç†è§£ã€‚ package command import \"fmt\" // å‘½ä»¤æ¥å£ type Command interface { Execute() } // å¼€å¯å‘½ä»¤ type StartCommand struct { mb *MotherBoard } func NewStartCommand(mb *MotherBoard) *StartCommand { return \u0026StartCommand{ mb: mb, } } func (c *StartCommand) Execute() { c.mb.Start() } // é‡å¯å‘½ä»¤ type RebootCommand struct { mb *MotherBoard } func NewRebootCommand(mb *MotherBoard) *RebootCommand { return \u0026RebootCommand{ mb: mb, } } func (c *RebootCommand) Execute() { c.mb.Reboot() } // ä¸»æ¿ï¼Œå®ƒå®ç°äº†æ‰€æœ‰çš„å‘½ä»¤ type MotherBoard struct{} func (*MotherBoard) Start() { fmt.Print(\"system starting\\n\") } func (*MotherBoard) Reboot() { fmt.Print(\"system rebooting\\n\") } // ç›’å­é‡Œè£…äº†æ‰€æœ‰å‘½ä»¤ï¼Œé€šè¿‡æŒ‰é’®ï¼Œæ‰§è¡Œä¸åŒçš„å‘½ä»¤ type Box struct { button1 Command button2 Command } func NewBox(button1, button2 Command) *Box { return \u0026Box{ button1: button1, button2: button2, } } func (b *Box) PressButton1() { b.button1.Execute() } func (b *Box) PressButton2() { b.button2.Execute() } ","date":"2023-04-06","objectID":"/design_pattern/:4:2","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è§£é‡Šå™¨æ¨¡å¼ åœ¨è½¯ä»¶å¼€å‘ä¸­ï¼Œä¼šé‡åˆ°æœ‰äº›é—®é¢˜å¤šæ¬¡é‡å¤å‡ºç°ï¼Œè€Œä¸”æœ‰ä¸€å®šçš„ç›¸ä¼¼æ€§å’Œè§„å¾‹æ€§ã€‚å¦‚æœå°†å®ƒä»¬å½’çº³æˆä¸€ç§ç®€å•çš„è¯­è¨€ï¼Œé‚£ä¹ˆè¿™äº›é—®é¢˜å®ä¾‹å°†æ˜¯è¯¥è¯­è¨€çš„ä¸€äº›å¥å­ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨â€œç¼–è¯‘åŸç†â€ä¸­çš„è§£é‡Šå™¨æ¨¡å¼æ¥å®ç°äº†ã€‚ è§£é‡Šå™¨ï¼ˆInterpreterï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šç»™åˆ†æå¯¹è±¡å®šä¹‰ä¸€ä¸ªè¯­è¨€ï¼Œå¹¶å®šä¹‰è¯¥è¯­è¨€çš„æ–‡æ³•è¡¨ç¤ºï¼Œå†è®¾è®¡ä¸€ä¸ªè§£æå™¨æ¥è§£é‡Šè¯­è¨€ä¸­çš„å¥å­ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç”¨ç¼–è¯‘è¯­è¨€çš„æ–¹å¼æ¥åˆ†æåº”ç”¨ä¸­çš„å®ä¾‹ã€‚è¿™ç§æ¨¡å¼å®ç°äº†æ–‡æ³•è¡¨è¾¾å¼å¤„ç†çš„æ¥å£ï¼Œè¯¥æ¥å£è§£é‡Šä¸€ä¸ªç‰¹å®šçš„ä¸Šä¸‹æ–‡ã€‚ ä¼˜ç‚¹ï¼š å¯æ‹“å±•æ€§é«˜ï¼Œçµæ´» æ˜“äºå®ç°ç®€å•çš„æ–‡æ³• ç¼ºç‚¹ï¼š å¯ä½¿ç”¨åœºæ™¯å°‘ å¯¹äºå¤æ‚çš„æ–‡æ³•è¾ƒéš¾ç»´æŠ¤ è§£é‡Šå™¨æ¨¡å¼ä¼šå¼•èµ·ç±»è†¨èƒ€ è§£é‡Šå™¨æ¨¡å¼é‡‡ç”¨é€’å½’è°ƒç”¨çš„æ–¹æ³• //Expression è¯­å¥æ¥å£ type Expression interface { Interpret(context string) bool } //TerminalExpression ç»ˆç«¯è¯­å¥ç±» type TerminalExpression struct { Data string } //NewTerminalExpression å®ä¾‹åŒ–ç»ˆç«¯è¯­å¥ç±» func NewTerminalExpression(data string) *TerminalExpression { return \u0026TerminalExpression{ Data: data, } } //Interpret ç»ˆç«¯è¯­å¥ç±»çš„è§£é‡Šå™¨ func (te *TerminalExpression) Interpret(context string) bool { if strings.Contains(context, te.Data) { return true } return false } //OrExpression æˆ–è¯­å¥ç±» type OrExpression struct { Expr1 Expression Expr2 Expression } //NewOrExpression å®ä¾‹åŒ–æˆ–è¯­å¥ func NewOrExpression(expr1, expr2 Expression) *OrExpression { return \u0026OrExpression{ Expr1: expr1, Expr2: expr2, } } //Interpret è§£é‡Šå™¨ func (oe *OrExpression) Interpret(context string) bool { return oe.Expr1.Interpret(context) || oe.Expr2.Interpret(context) } //AndExpression ä¸è¯­å¥ç±» type AndExpression struct { Expr1 Expression Expr2 Expression } //NewAndExpression å®ä¾‹åŒ–ä¸è¯­å¥ func NewAndExpression(expr1, expr2 Expression) *AndExpression { return \u0026AndExpression{ Expr1: expr1, Expr2: expr2, } } //Interpret è§£é‡Šå™¨ func (ae *AndExpression) Interpret(context string) bool { return ae.Expr1.Interpret(context) \u0026\u0026 ae.Expr2.Interpret(context) } func OrExpressionTest(t *testing.T) { //è§„åˆ™ï¼Œlee å’Œ wang æ˜¯ç”·æ€§ lee := NewTerminalExpression(\"Lee\") wang := NewTerminalExpression(\"Wang\") isMale := NewOrExpression(lee, wang) fmt.Println(\"lee is male? \", isMale.Interpret(\"Lee\")) } func AndExpressionTest(t *testing.T) { //è§„åˆ™ï¼Œyangæ˜¯å·²å©šå¥³æ€§ yang := NewTerminalExpression(\"Yang\") married := NewTerminalExpression(\"Married\") isMarried := NewAndExpression(yang, married) fmt.Println(\"Yang is a married women? \", isMarried.Interpret(\"Married Yang\")) } ","date":"2023-04-06","objectID":"/design_pattern/:4:3","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è¿­ä»£å™¨æ¨¡å¼ è¿­ä»£å™¨ï¼ˆIteratorï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šæä¾›ä¸€ä¸ªå¯¹è±¡æ¥é¡ºåºè®¿é—®èšåˆå¯¹è±¡ä¸­çš„ä¸€ç³»åˆ—æ•°æ®ï¼Œè€Œä¸æš´éœ²èšåˆå¯¹è±¡çš„å†…éƒ¨è¡¨ç¤ºã€‚è¿­ä»£å™¨æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ è®¿é—®ä¸€ä¸ªèšåˆå¯¹è±¡çš„å†…å®¹è€Œæ— é¡»æš´éœ²å®ƒçš„å†…éƒ¨è¡¨ç¤ºã€‚ éå†ä»»åŠ¡äº¤ç”±è¿­ä»£å™¨å®Œæˆï¼Œè¿™ç®€åŒ–äº†èšåˆç±»ã€‚ å®ƒæ”¯æŒä»¥ä¸åŒæ–¹å¼éå†ä¸€ä¸ªèšåˆï¼Œç”šè‡³å¯ä»¥è‡ªå®šä¹‰è¿­ä»£å™¨çš„å­ç±»ä»¥æ”¯æŒæ–°çš„éå†ã€‚ å¢åŠ æ–°çš„èšåˆç±»å’Œè¿­ä»£å™¨ç±»éƒ½å¾ˆæ–¹ä¾¿ï¼Œæ— é¡»ä¿®æ”¹åŸæœ‰ä»£ç ã€‚ å°è£…æ€§è‰¯å¥½ï¼Œä¸ºéå†ä¸åŒçš„èšåˆç»“æ„æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ã€‚ å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼šå¢åŠ äº†ç±»çš„ä¸ªæ•°ï¼Œè¿™åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¢åŠ äº†ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚ // Package iterator is an example of the Iterator Pattern. package iterator // Iterator provides a iterator interface. type Iterator interface { Index() int Value() interface{} Has() bool Next() Prev() Reset() End() } // Aggregate provides a collection interface. type Aggregate interface { Iterator() Iterator } // BookIterator implements the Iterator interface. type BookIterator struct { shelf *BookShelf index int internal int } // Index returns current index func (i *BookIterator) Index() int { return i.index } // Value returns current value func (i *BookIterator) Value() interface{} { return i.shelf.Books[i.index] } // Has implementation. func (i *BookIterator) Has() bool { if i.internal \u003c 0 || i.internal \u003e= len(i.shelf.Books) { return false } return true } // Next goes to the next item. func (i *BookIterator) Next() { i.internal++ if i.Has() { i.index++ } } // Prev goes to the previous item. func (i *BookIterator) Prev() { i.internal-- if i.Has() { i.index-- } } // Reset resets iterator. func (i *BookIterator) Reset() { i.index = 0 i.internal = 0 } // End goes to the last item. func (i *BookIterator) End() { i.index = len(i.shelf.Books) - 1 i.internal = i.index } // BookShelf implements the Aggregate interface. type BookShelf struct { Books []*Book } // Iterator creates and returns the iterator over the collection. func (b *BookShelf) Iterator() Iterator { return \u0026BookIterator{shelf: b} } // Add adds an item to the collection. func (b *BookShelf) Add(book *Book) { b.Books = append(b.Books, book) } // Book implements a item of the collection. type Book struct { Name string } package iterator import ( \"testing\" ) func TestIterator(t *testing.T) { shelf := new(BookShelf) books := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"} for _, book := range books { shelf.Add(\u0026Book{Name: book}) } for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() { index, value := iterator.Index(), iterator.Value().(*Book) if value.Name != books[index] { t.Errorf(\"Expect Book.Name to %s, but %s\", books[index], value.Name) } } } ","date":"2023-04-06","objectID":"/design_pattern/:4:4","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ä¸­ä»‹è€…æ¨¡å¼ ä¸­ä»‹è€…ï¼ˆMediatorï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šå®šä¹‰ä¸€ä¸ªä¸­ä»‹å¯¹è±¡æ¥å°è£…ä¸€ç³»åˆ—å¯¹è±¡ä¹‹é—´çš„äº¤äº’ï¼Œä½¿åŸæœ‰å¯¹è±¡ä¹‹é—´çš„è€¦åˆæ¾æ•£ï¼Œä¸”å¯ä»¥ç‹¬ç«‹åœ°æ”¹å˜å®ƒä»¬ä¹‹é—´çš„äº¤äº’ã€‚ä¸­ä»‹è€…æ¨¡å¼åˆå«è°ƒåœæ¨¡å¼ï¼Œå®ƒæ˜¯è¿ªç±³ç‰¹æ³•åˆ™çš„å…¸å‹åº”ç”¨ã€‚ ä¸­ä»‹è€…æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ ç±»ä¹‹é—´å„å¸å…¶èŒï¼Œç¬¦åˆè¿ªç±³ç‰¹æ³•åˆ™ã€‚ é™ä½äº†å¯¹è±¡ä¹‹é—´çš„è€¦åˆæ€§ï¼Œä½¿å¾—å¯¹è±¡æ˜“äºç‹¬ç«‹åœ°è¢«å¤ç”¨ã€‚ å°†å¯¹è±¡é—´çš„ä¸€å¯¹å¤šå…³è”è½¬å˜ä¸ºä¸€å¯¹ä¸€çš„å…³è”ï¼Œæé«˜ç³»ç»Ÿçš„çµæ´»æ€§ï¼Œä½¿å¾—ç³»ç»Ÿæ˜“äºç»´æŠ¤å’Œæ‰©å±•ã€‚ å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼šä¸­ä»‹è€…æ¨¡å¼å°†åŸæœ¬å¤šä¸ªå¯¹è±¡ç›´æ¥çš„ç›¸äº’ä¾èµ–å˜æˆäº†ä¸­ä»‹è€…å’Œå¤šä¸ªåŒäº‹ç±»çš„ä¾èµ–å…³ç³»ã€‚å½“åŒäº‹ç±»è¶Šå¤šæ—¶ï¼Œä¸­ä»‹è€…å°±ä¼šè¶Šè‡ƒè‚¿ï¼Œå˜å¾—å¤æ‚ä¸”éš¾ä»¥ç»´æŠ¤ã€‚ package mediator import ( \"fmt\" \"strings\" ) type CDDriver struct { Data string } func (c *CDDriver) ReadData() { c.Data = \"music,image\" fmt.Printf(\"CDDriver: reading data %s\\n\", c.Data) GetMediatorInstance().changed(c) } type CPU struct { Video string Sound string } func (c *CPU) Process(data string) { sp := strings.Split(data, \",\") c.Sound = sp[0] c.Video = sp[1] fmt.Printf(\"CPU: split data with Sound %s, Video %s\\n\", c.Sound, c.Video) GetMediatorInstance().changed(c) } type VideoCard struct { Data string } func (v *VideoCard) Display(data string) { v.Data = data fmt.Printf(\"VideoCard: display %s\\n\", v.Data) GetMediatorInstance().changed(v) } type SoundCard struct { Data string } func (s *SoundCard) Play(data string) { s.Data = data fmt.Printf(\"SoundCard: play %s\\n\", s.Data) GetMediatorInstance().changed(s) } type Mediator struct { CD *CDDriver CPU *CPU Video *VideoCard Sound *SoundCard } var mediator *Mediator func GetMediatorInstance() *Mediator { if mediator == nil { mediator = \u0026Mediator{} } return mediator } func (m *Mediator) changed(i interface{}) { switch inst := i.(type) { case *CDDriver: m.CPU.Process(inst.Data) case *CPU: m.Sound.Play(inst.Sound) m.Video.Display(inst.Video) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:5","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"å¤‡å¿˜å½•æ¨¡å¼ å¤‡å¿˜å½•ï¼ˆMementoï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šåœ¨ä¸ç ´åå°è£…æ€§çš„å‰æä¸‹ï¼Œæ•è·ä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ï¼Œå¹¶åœ¨è¯¥å¯¹è±¡ä¹‹å¤–ä¿å­˜è¿™ä¸ªçŠ¶æ€ï¼Œä»¥ä¾¿ä»¥åå½“éœ€è¦æ—¶èƒ½å°†è¯¥å¯¹è±¡æ¢å¤åˆ°åŸå…ˆä¿å­˜çš„çŠ¶æ€ã€‚è¯¥æ¨¡å¼åˆå«å¿«ç…§æ¨¡å¼ã€‚ å¤‡å¿˜å½•æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ æä¾›äº†ä¸€ç§å¯ä»¥æ¢å¤çŠ¶æ€çš„æœºåˆ¶ã€‚å½“ç”¨æˆ·éœ€è¦æ—¶èƒ½å¤Ÿæ¯”è¾ƒæ–¹ä¾¿åœ°å°†æ•°æ®æ¢å¤åˆ°æŸä¸ªå†å²çš„çŠ¶æ€ã€‚ å®ç°äº†å†…éƒ¨çŠ¶æ€çš„å°è£…ã€‚é™¤äº†åˆ›å»ºå®ƒçš„å‘èµ·äººä¹‹å¤–ï¼Œå…¶ä»–å¯¹è±¡éƒ½ä¸èƒ½å¤Ÿè®¿é—®è¿™äº›çŠ¶æ€ä¿¡æ¯ã€‚ ç®€åŒ–äº†å‘èµ·äººç±»ã€‚å‘èµ·äººä¸éœ€è¦ç®¡ç†å’Œä¿å­˜å…¶å†…éƒ¨çŠ¶æ€çš„å„ä¸ªå¤‡ä»½ï¼Œæ‰€æœ‰çŠ¶æ€ä¿¡æ¯éƒ½ä¿å­˜åœ¨å¤‡å¿˜å½•ä¸­ï¼Œå¹¶ç”±ç®¡ç†è€…è¿›è¡Œç®¡ç†ï¼Œè¿™ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ã€‚ å…¶ä¸»è¦ç¼ºç‚¹æ˜¯ï¼šèµ„æºæ¶ˆè€—å¤§ã€‚å¦‚æœè¦ä¿å­˜çš„å†…éƒ¨çŠ¶æ€ä¿¡æ¯è¿‡å¤šæˆ–è€…ç‰¹åˆ«é¢‘ç¹ï¼Œå°†ä¼šå ç”¨æ¯”è¾ƒå¤§çš„å†…å­˜èµ„æºã€‚ //Memento å¤‡å¿˜å½•ç±» type Memento struct { state string } //NewMemento å®ä¾‹åŒ–å¤‡å¿˜å½•ç±» func NewMemento(st string) *Memento { return \u0026Memento{ state: st, } } //GetState è·å–å¤‡å¿˜å½•ç±»çš„çŠ¶æ€ func (m *Memento) GetState() string { return m.state } //Originator åˆå§‹ç±» type Originator struct { state string } //NewOriginator å®ä¾‹åŒ–åˆå§‹ç±» func NewOriginator(st string) *Originator { return \u0026Originator{ state: st, } } //SetState åˆå§‹åŒ–ç±»è®¾ç½®çŠ¶æ€ func (o *Originator) SetState(st string) { o.state = st } //GetState ä»åˆå§‹ç±»ä¸­è·å–çŠ¶æ€ func (o *Originator) GetState() string { return o.state } //SaveStateToMemento å°†åˆå§‹ç±»çŠ¶æ€ä¿å­˜åˆ°å¤‡å¿˜å½•ç±» func (o *Originator) SaveStateToMemento() *Memento { return NewMemento(o.state) } //GetStateFromMemento å°†å¤‡å¿˜å½•ç±»çš„çŠ¶æ€è¯»å–åˆ°åˆå§‹ç±» func (o *Originator) GetStateFromMemento(memento *Memento) { o.state = memento.GetState() } //CareTaker ä¿å­˜ç±»ï¼Œç”¨äºå­˜å‚¨å¤‡å¿˜å½•å®ä¾‹ type CareTaker struct { MementoList map[int]*Memento } //NewCareTaker å®ä¾‹åŒ–ä¿å­˜ç±» func NewCareTaker() *CareTaker { return \u0026CareTaker{ MementoList: make(map[int]*Memento), } } //Add ä¿å­˜ç±»æ·»åŠ å¤‡å¿˜å½•å®ä¾‹ func (ct *CareTaker) Add(index int, memento *Memento) { ct.MementoList[index] = memento } //Get ä¿å­˜ç±»è·å–å¤‡å¿˜å½•å®ä¾‹ func (ct *CareTaker) Get(index int) *Memento { return ct.MementoList[index] } ","date":"2023-04-06","objectID":"/design_pattern/:4:6","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è§‚å¯Ÿè€…æ¨¡å¼ è§‚å¯Ÿè€…ï¼ˆObserverï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šæŒ‡å¤šä¸ªå¯¹è±¡é—´å­˜åœ¨ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥å¹¶è¢«è‡ªåŠ¨æ›´æ–°ã€‚è¿™ç§æ¨¡å¼æœ‰æ—¶åˆç§°ä½œå‘å¸ƒ-è®¢é˜…æ¨¡å¼ã€æ¨¡å‹-è§†å›¾æ¨¡å¼ï¼Œå®ƒæ˜¯å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ã€‚ è§‚å¯Ÿè€…æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ é™ä½äº†ç›®æ ‡ä¸è§‚å¯Ÿè€…ä¹‹é—´çš„è€¦åˆå…³ç³»ï¼Œä¸¤è€…ä¹‹é—´æ˜¯æŠ½è±¡è€¦åˆå…³ç³»ã€‚ç¬¦åˆä¾èµ–å€’ç½®åŸåˆ™ã€‚ ç›®æ ‡ä¸è§‚å¯Ÿè€…ä¹‹é—´å»ºç«‹äº†ä¸€å¥—è§¦å‘æœºåˆ¶ã€‚ å®ƒçš„ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ ç›®æ ‡ä¸è§‚å¯Ÿè€…ä¹‹é—´çš„ä¾èµ–å…³ç³»å¹¶æ²¡æœ‰å®Œå…¨è§£é™¤ï¼Œè€Œä¸”æœ‰å¯èƒ½å‡ºç°å¾ªç¯å¼•ç”¨ã€‚ å½“è§‚å¯Ÿè€…å¯¹è±¡å¾ˆå¤šæ—¶ï¼Œé€šçŸ¥çš„å‘å¸ƒä¼šèŠ±è´¹å¾ˆå¤šæ—¶é—´ï¼Œå½±å“ç¨‹åºçš„æ•ˆç‡ã€‚ package main import ( \"container/list\" ) type Subject interface { Attach(Observer) //æ³¨å†Œè§‚å¯Ÿè€… Detach(Observer) //é‡Šæ”¾è§‚å¯Ÿè€… Notify() //é€šçŸ¥æ‰€æœ‰æ³¨å†Œçš„è§‚å¯Ÿè€… } type Observer interface { Update(Subject) //è§‚å¯Ÿè€…è¿›è¡Œæ›´æ–°çŠ¶æ€ } //implements Subject type ConcreteSubject struct { observers *list.List value int } func NewConcreteSubject() *ConcreteSubject { s := new(ConcreteSubject) s.observers = list.New() return s } func (s *ConcreteSubject) Attach(observe Observer) { //æ³¨å†Œè§‚å¯Ÿè€… s.observers.PushBack(observe) } func (s *ConcreteSubject) Detach(observer Observer) { //é‡Šæ”¾è§‚å¯Ÿè€… for ob := s.observers.Front(); ob != nil; ob = ob.Next() { if ob.Value.(*Observer) == \u0026observer { s.observers.Remove(ob) break } } } func (s *ConcreteSubject) Notify() { //é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€… for ob := s.observers.Front(); ob != nil; ob = ob.Next() { ob.Value.(Observer).Update(s) } } func (s *ConcreteSubject) setValue(value int) { s.value = value s.Notify() } func (s *ConcreteSubject) getValue() int { return s.value } /** * å…·ä½“è§‚å¯Ÿè€… implements Observer * */ type ConcreteObserver1 struct { } func (c *ConcreteObserver1) Update(subject Subject) { println(\"ConcreteObserver1 value is \", subject.(*ConcreteSubject).getValue()) } /** * å…·ä½“è§‚å¯Ÿè€… implements Observer * */ type ConcreteObserver2 struct { } func (c *ConcreteObserver2) Update(subject Subject) { println(\"ConcreteObserver2 value is \", subject.(*ConcreteSubject).getValue()) } func main() { subject := NewConcreteSubject() observer1 := new(ConcreteObserver1) observer2 := new(ConcreteObserver2) subject.Attach(observer1) subject.Attach(observer2) subject.setValue(5) } ","date":"2023-04-06","objectID":"/design_pattern/:4:7","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"çŠ¶æ€æ¨¡å¼ çŠ¶æ€ï¼ˆStateï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šå¯¹æœ‰çŠ¶æ€çš„å¯¹è±¡ï¼ŒæŠŠå¤æ‚çš„â€œåˆ¤æ–­é€»è¾‘â€æå–åˆ°ä¸åŒçš„çŠ¶æ€å¯¹è±¡ä¸­ï¼Œå…è®¸çŠ¶æ€å¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶æ”¹å˜å…¶è¡Œä¸ºã€‚ çŠ¶æ€æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ ç»“æ„æ¸…æ™°ï¼ŒçŠ¶æ€æ¨¡å¼å°†ä¸ç‰¹å®šçŠ¶æ€ç›¸å…³çš„è¡Œä¸ºå±€éƒ¨åŒ–åˆ°ä¸€ä¸ªçŠ¶æ€ä¸­ï¼Œå¹¶ä¸”å°†ä¸åŒçŠ¶æ€çš„è¡Œä¸ºåˆ†å‰²å¼€æ¥ï¼Œæ»¡è¶³â€œå•ä¸€èŒè´£åŸåˆ™â€ã€‚ å°†çŠ¶æ€è½¬æ¢æ˜¾ç¤ºåŒ–ï¼Œå‡å°‘å¯¹è±¡é—´çš„ç›¸äº’ä¾èµ–ã€‚å°†ä¸åŒçš„çŠ¶æ€å¼•å…¥ç‹¬ç«‹çš„å¯¹è±¡ä¸­ä¼šä½¿å¾—çŠ¶æ€è½¬æ¢å˜å¾—æ›´åŠ æ˜ç¡®ï¼Œä¸”å‡å°‘å¯¹è±¡é—´çš„ç›¸äº’ä¾èµ–ã€‚ çŠ¶æ€ç±»èŒè´£æ˜ç¡®ï¼Œæœ‰åˆ©äºç¨‹åºçš„æ‰©å±•ã€‚é€šè¿‡å®šä¹‰æ–°çš„å­ç±»å¾ˆå®¹æ˜“åœ°å¢åŠ æ–°çš„çŠ¶æ€å’Œè½¬æ¢ã€‚ çŠ¶æ€æ¨¡å¼çš„ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ çŠ¶æ€æ¨¡å¼çš„ä½¿ç”¨å¿…ç„¶ä¼šå¢åŠ ç³»ç»Ÿçš„ç±»ä¸å¯¹è±¡çš„ä¸ªæ•°ã€‚ çŠ¶æ€æ¨¡å¼çš„ç»“æ„ä¸å®ç°éƒ½è¾ƒä¸ºå¤æ‚ï¼Œå¦‚æœä½¿ç”¨ä¸å½“ä¼šå¯¼è‡´ç¨‹åºç»“æ„å’Œä»£ç çš„æ··ä¹±ã€‚ çŠ¶æ€æ¨¡å¼å¯¹å¼€é—­åŸåˆ™çš„æ”¯æŒå¹¶ä¸å¤ªå¥½ï¼Œå¯¹äºå¯ä»¥åˆ‡æ¢çŠ¶æ€çš„çŠ¶æ€æ¨¡å¼ï¼Œå¢åŠ æ–°çš„çŠ¶æ€ç±»éœ€è¦ä¿®æ”¹é‚£äº›è´Ÿè´£çŠ¶æ€è½¬æ¢çš„æºç ï¼Œå¦åˆ™æ— æ³•åˆ‡æ¢åˆ°æ–°å¢çŠ¶æ€ï¼Œè€Œä¸”ä¿®æ”¹æŸä¸ªçŠ¶æ€ç±»çš„è¡Œä¸ºä¹Ÿéœ€è¦ä¿®æ”¹å¯¹åº”ç±»çš„æºç ã€‚ // Package state is an example of the State Pattern. package state // MobileAlertStater provides a common interface for various states. type MobileAlertStater interface { Alert() string } // MobileAlert implements an alert depending on its state. type MobileAlert struct { state MobileAlertStater } // Alert returns a alert string func (a *MobileAlert) Alert() string { return a.state.Alert() } // SetState changes state func (a *MobileAlert) SetState(state MobileAlertStater) { a.state = state } // NewMobileAlert is the MobileAlert constructor. func NewMobileAlert() *MobileAlert { return \u0026MobileAlert{state: \u0026MobileAlertVibration{}} } // MobileAlertVibration implements vibration alert type MobileAlertVibration struct { } // Alert returns a alert string func (a *MobileAlertVibration) Alert() string { return \"Vrrr... Brrr... Vrrr...\" } // MobileAlertSong implements beep alert type MobileAlertSong struct { } // Alert returns a alert string func (a *MobileAlertSong) Alert() string { return \"Ğ‘ĞµĞ»Ñ‹Ğµ Ñ€Ğ¾Ğ·Ñ‹, Ğ‘ĞµĞ»Ñ‹Ğµ Ñ€Ğ¾Ğ·Ñ‹. Ğ‘ĞµĞ·Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ñ‹ ÑˆĞ¸Ğ¿Ñ‹...\" } package state import ( \"testing\" ) func TestState(t *testing.T) { expect := \"Vrrr... Brrr... Vrrr...\" + \"Vrrr... Brrr... Vrrr...\" + \"Ğ‘ĞµĞ»Ñ‹Ğµ Ñ€Ğ¾Ğ·Ñ‹, Ğ‘ĞµĞ»Ñ‹Ğµ Ñ€Ğ¾Ğ·Ñ‹. Ğ‘ĞµĞ·Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ñ‹ ÑˆĞ¸Ğ¿Ñ‹...\" mobile := NewMobileAlert() result := mobile.Alert() result += mobile.Alert() mobile.SetState(\u0026MobileAlertSong{}) result += mobile.Alert() if result != expect { t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:8","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"ç­–ç•¥æ¨¡å¼ ç­–ç•¥ï¼ˆStrategyï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šè¯¥æ¨¡å¼å®šä¹‰äº†ä¸€ç³»åˆ—ç®—æ³•ï¼Œå¹¶å°†æ¯ä¸ªç®—æ³•å°è£…èµ·æ¥ï¼Œä½¿å®ƒä»¬å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¸”ç®—æ³•çš„å˜åŒ–ä¸ä¼šå½±å“ä½¿ç”¨ç®—æ³•çš„å®¢æˆ·ã€‚ç­–ç•¥æ¨¡å¼å±äºå¯¹è±¡è¡Œä¸ºæ¨¡å¼ï¼Œå®ƒé€šè¿‡å¯¹ç®—æ³•è¿›è¡Œå°è£…ï¼ŒæŠŠä½¿ç”¨ç®—æ³•çš„è´£ä»»å’Œç®—æ³•çš„å®ç°åˆ†å‰²å¼€æ¥ï¼Œå¹¶å§”æ´¾ç»™ä¸åŒçš„å¯¹è±¡å¯¹è¿™äº›ç®—æ³•è¿›è¡Œç®¡ç†ã€‚ ç­–ç•¥æ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ å¤šé‡æ¡ä»¶è¯­å¥ä¸æ˜“ç»´æŠ¤ï¼Œè€Œä½¿ç”¨ç­–ç•¥æ¨¡å¼å¯ä»¥é¿å…ä½¿ç”¨å¤šé‡æ¡ä»¶è¯­å¥ï¼Œå¦‚ ifâ€¦else è¯­å¥ã€switchâ€¦case è¯­å¥ã€‚ ç­–ç•¥æ¨¡å¼æä¾›äº†ä¸€ç³»åˆ—çš„å¯ä¾›é‡ç”¨çš„ç®—æ³•æ—ï¼Œæ°å½“ä½¿ç”¨ç»§æ‰¿å¯ä»¥æŠŠç®—æ³•æ—çš„å…¬å…±ä»£ç è½¬ç§»åˆ°çˆ¶ç±»é‡Œé¢ï¼Œä»è€Œé¿å…é‡å¤çš„ä»£ç ã€‚ ç­–ç•¥æ¨¡å¼å¯ä»¥æä¾›ç›¸åŒè¡Œä¸ºçš„ä¸åŒå®ç°ï¼Œå®¢æˆ·å¯ä»¥æ ¹æ®ä¸åŒæ—¶é—´æˆ–ç©ºé—´è¦æ±‚é€‰æ‹©ä¸åŒçš„ã€‚ ç­–ç•¥æ¨¡å¼æä¾›äº†å¯¹å¼€é—­åŸåˆ™çš„å®Œç¾æ”¯æŒï¼Œå¯ä»¥åœ¨ä¸ä¿®æ”¹åŸä»£ç çš„æƒ…å†µä¸‹ï¼Œçµæ´»å¢åŠ æ–°ç®—æ³•ã€‚ ç­–ç•¥æ¨¡å¼æŠŠç®—æ³•çš„ä½¿ç”¨æ”¾åˆ°ç¯å¢ƒç±»ä¸­ï¼Œè€Œç®—æ³•çš„å®ç°ç§»åˆ°å…·ä½“ç­–ç•¥ç±»ä¸­ï¼Œå®ç°äº†äºŒè€…çš„åˆ†ç¦»ã€‚ å…¶ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ å®¢æˆ·ç«¯å¿…é¡»ç†è§£æ‰€æœ‰ç­–ç•¥ç®—æ³•çš„åŒºåˆ«ï¼Œä»¥ä¾¿é€‚æ—¶é€‰æ‹©æ°å½“çš„ç®—æ³•ç±»ã€‚ ç­–ç•¥æ¨¡å¼é€ æˆå¾ˆå¤šçš„ç­–ç•¥ç±»ï¼Œå¢åŠ ç»´æŠ¤éš¾åº¦ã€‚ // Package strategy is an example of the Strategy Pattern. package strategy // StrategySort provides an interface for sort algorithms. type StrategySort interface { Sort([]int) } // BubbleSort implements bubble sort algorithm. type BubbleSort struct { } // Sort sorts data. func (s *BubbleSort) Sort(a []int) { size := len(a) if size \u003c 2 { return } for i := 0; i \u003c size; i++ { for j := size - 1; j \u003e= i+1; j-- { if a[j] \u003c a[j-1] { a[j], a[j-1] = a[j-1], a[j] } } } } // InsertionSort implements insertion sort algorithm. type InsertionSort struct { } // Sort sorts data. func (s *InsertionSort) Sort(a []int) { size := len(a) if size \u003c 2 { return } for i := 1; i \u003c size; i++ { var j int var buff = a[i] for j = i - 1; j \u003e= 0; j-- { if a[j] \u003c buff { break } a[j+1] = a[j] } a[j+1] = buff } } // Context provides a context for execution of a strategy. type Context struct { strategy StrategySort } // Algorithm replaces strategies. func (c *Context) Algorithm(a StrategySort) { c.strategy = a } // Sort sorts data according to the chosen strategy. func (c *Context) Sort(s []int) { c.strategy.Sort(s) } package strategy import ( \"strconv\" \"testing\" ) func TestStrategy(t *testing.T) { data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4} data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4} ctx := new(Context) ctx.Algorithm(\u0026BubbleSort{}) ctx.Sort(data1) ctx.Algorithm(\u0026InsertionSort{}) ctx.Sort(data2) expect := \"1,2,3,4,5,6,7,8,9,\" var result1 string for _, val := range data1 { result1 += strconv.Itoa(val) + \",\" } if result1 != expect { t.Errorf(\"Expect result1 to equal %s, but %s.\\n\", expect, result1) } var result2 string for _, val := range data2 { result2 += strconv.Itoa(val) + \",\" } if result2 != expect { t.Errorf(\"Expect result2 to equal %s, but %s.\\n\", expect, result2) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:9","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"æ¨¡æ¿æ–¹æ³•æ¨¡å¼ æ¨¡æ¿æ–¹æ³•ï¼ˆTemplate Methodï¼‰æ¨¡å¼çš„å®šä¹‰å¦‚ä¸‹ï¼šå®šä¹‰ä¸€ä¸ªæ“ä½œä¸­çš„ç®—æ³•éª¨æ¶ï¼Œè€Œå°†ç®—æ³•çš„ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ï¼Œä½¿å¾—å­ç±»å¯ä»¥ä¸æ”¹å˜è¯¥ç®—æ³•ç»“æ„çš„æƒ…å†µä¸‹é‡å®šä¹‰è¯¥ç®—æ³•çš„æŸäº›ç‰¹å®šæ­¥éª¤ã€‚å®ƒæ˜¯ä¸€ç§ç±»è¡Œä¸ºå‹æ¨¡å¼ã€‚ è¯¥æ¨¡å¼çš„ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ å®ƒå°è£…äº†ä¸å˜éƒ¨åˆ†ï¼Œæ‰©å±•å¯å˜éƒ¨åˆ†ã€‚å®ƒæŠŠè®¤ä¸ºæ˜¯ä¸å˜éƒ¨åˆ†çš„ç®—æ³•å°è£…åˆ°çˆ¶ç±»ä¸­å®ç°ï¼Œè€ŒæŠŠå¯å˜éƒ¨åˆ†ç®—æ³•ç”±å­ç±»ç»§æ‰¿å®ç°ï¼Œä¾¿äºå­ç±»ç»§ç»­æ‰©å±•ã€‚ å®ƒåœ¨çˆ¶ç±»ä¸­æå–äº†å…¬å…±çš„éƒ¨åˆ†ä»£ç ï¼Œä¾¿äºä»£ç å¤ç”¨ã€‚ éƒ¨åˆ†æ–¹æ³•æ˜¯ç”±å­ç±»å®ç°çš„ï¼Œå› æ­¤å­ç±»å¯ä»¥é€šè¿‡æ‰©å±•æ–¹å¼å¢åŠ ç›¸åº”çš„åŠŸèƒ½ï¼Œç¬¦åˆå¼€é—­åŸåˆ™ã€‚ è¯¥æ¨¡å¼çš„ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ å¯¹æ¯ä¸ªä¸åŒçš„å®ç°éƒ½éœ€è¦å®šä¹‰ä¸€ä¸ªå­ç±»ï¼Œè¿™ä¼šå¯¼è‡´ç±»çš„ä¸ªæ•°å¢åŠ ï¼Œç³»ç»Ÿæ›´åŠ åºå¤§ï¼Œè®¾è®¡ä¹Ÿæ›´åŠ æŠ½è±¡ï¼Œé—´æ¥åœ°å¢åŠ äº†ç³»ç»Ÿå®ç°çš„å¤æ‚åº¦ã€‚ çˆ¶ç±»ä¸­çš„æŠ½è±¡æ–¹æ³•ç”±å­ç±»å®ç°ï¼Œå­ç±»æ‰§è¡Œçš„ç»“æœä¼šå½±å“çˆ¶ç±»çš„ç»“æœï¼Œè¿™å¯¼è‡´ä¸€ç§åå‘çš„æ§åˆ¶ç»“æ„ï¼Œå®ƒæé«˜äº†ä»£ç é˜…è¯»çš„éš¾åº¦ã€‚ ç”±äºç»§æ‰¿å…³ç³»è‡ªèº«çš„ç¼ºç‚¹ï¼Œå¦‚æœçˆ¶ç±»æ·»åŠ æ–°çš„æŠ½è±¡æ–¹æ³•ï¼Œåˆ™æ‰€æœ‰å­ç±»éƒ½è¦æ”¹ä¸€éã€‚ //Game æ¨¡æ¿åŸºç±» type Game struct { Initialize func() StartPlay func() EndPlay func() } //Play æ¨¡æ¿åŸºç±»çš„Playæ–¹æ³• func (g Game) Play() { g.Initialize() g.StartPlay() g.EndPlay() } //FootBall å­ç±»ï¼Œç»§æ‰¿ameç±» type FootBall struct { Game } //NewFootBall å®ä¾‹åŒ–footballå­ç±» func NewFootBall() *FootBall { ft := new(FootBall) ft.Game.Initialize = ft.Initialize ft.Game.StartPlay = ft.StartPlay ft.Game.EndPlay = ft.EndPlay return ft } //Initialize å­ç±»çš„Initializeæ–¹æ³• func (ft *FootBall) Initialize() { fmt.Println(\"Football game initialize\") } //StartPlay å­ç±»çš„StartPlayæ–¹æ³• func (ft *FootBall) StartPlay() { fmt.Println(\"Football game started.\") } //EndPlay å­ç±»çš„EndPlayæ–¹æ³• func (ft *FootBall) EndPlay() { fmt.Println(\"Football game Finished!\") } func TemplateTest(t *testing.T) { football := NewFootBall() football.Play() fmt.Println(\"-------------------\") basketball := NewBasketball() basketball.Play() } ","date":"2023-04-06","objectID":"/design_pattern/:4:10","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang","è®¾è®¡æ¨¡å¼"],"content":"è®¿é—®è€…æ¨¡å¼ è®¿é—®è€…ï¼ˆVisitorï¼‰æ¨¡å¼çš„å®šä¹‰ï¼šå°†ä½œç”¨äºæŸç§æ•°æ®ç»“æ„ä¸­çš„å„å…ƒç´ çš„æ“ä½œåˆ†ç¦»å‡ºæ¥å°è£…æˆç‹¬ç«‹çš„ç±»ï¼Œä½¿å…¶åœ¨ä¸æ”¹å˜æ•°æ®ç»“æ„çš„å‰æä¸‹å¯ä»¥æ·»åŠ ä½œç”¨äºè¿™äº›å…ƒç´ çš„æ–°çš„æ“ä½œï¼Œä¸ºæ•°æ®ç»“æ„ä¸­çš„æ¯ä¸ªå…ƒç´ æä¾›å¤šç§è®¿é—®æ–¹å¼ã€‚å®ƒå°†å¯¹æ•°æ®çš„æ“ä½œä¸æ•°æ®ç»“æ„è¿›è¡Œåˆ†ç¦»ï¼Œæ˜¯è¡Œä¸ºç±»æ¨¡å¼ä¸­æœ€å¤æ‚çš„ä¸€ç§æ¨¡å¼ã€‚ è®¿é—®è€…ï¼ˆVisitorï¼‰æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡è¡Œä¸ºå‹æ¨¡å¼ï¼Œå…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ã€‚ æ‰©å±•æ€§å¥½ã€‚èƒ½å¤Ÿåœ¨ä¸ä¿®æ”¹å¯¹è±¡ç»“æ„ä¸­çš„å…ƒç´ çš„æƒ…å†µä¸‹ï¼Œä¸ºå¯¹è±¡ç»“æ„ä¸­çš„å…ƒç´ æ·»åŠ æ–°çš„åŠŸèƒ½ã€‚ å¤ç”¨æ€§å¥½ã€‚å¯ä»¥é€šè¿‡è®¿é—®è€…æ¥å®šä¹‰æ•´ä¸ªå¯¹è±¡ç»“æ„é€šç”¨çš„åŠŸèƒ½ï¼Œä»è€Œæé«˜ç³»ç»Ÿçš„å¤ç”¨ç¨‹åº¦ã€‚ çµæ´»æ€§å¥½ã€‚è®¿é—®è€…æ¨¡å¼å°†æ•°æ®ç»“æ„ä¸ä½œç”¨äºç»“æ„ä¸Šçš„æ“ä½œè§£è€¦ï¼Œä½¿å¾—æ“ä½œé›†åˆå¯ç›¸å¯¹è‡ªç”±åœ°æ¼”åŒ–è€Œä¸å½±å“ç³»ç»Ÿçš„æ•°æ®ç»“æ„ã€‚ ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ã€‚è®¿é—®è€…æ¨¡å¼æŠŠç›¸å…³çš„è¡Œä¸ºå°è£…åœ¨ä¸€èµ·ï¼Œæ„æˆä¸€ä¸ªè®¿é—®è€…ï¼Œä½¿æ¯ä¸€ä¸ªè®¿é—®è€…çš„åŠŸèƒ½éƒ½æ¯”è¾ƒå•ä¸€ã€‚ è®¿é—®è€…ï¼ˆVisitorï¼‰æ¨¡å¼çš„ä¸»è¦ç¼ºç‚¹å¦‚ä¸‹ã€‚ å¢åŠ æ–°çš„å…ƒç´ ç±»å¾ˆå›°éš¾ã€‚åœ¨è®¿é—®è€…æ¨¡å¼ä¸­ï¼Œæ¯å¢åŠ ä¸€ä¸ªæ–°çš„å…ƒç´ ç±»ï¼Œéƒ½è¦åœ¨æ¯ä¸€ä¸ªå…·ä½“è®¿é—®è€…ç±»ä¸­å¢åŠ ç›¸åº”çš„å…·ä½“æ“ä½œï¼Œè¿™è¿èƒŒäº†â€œå¼€é—­åŸåˆ™â€ã€‚ ç ´åå°è£…ã€‚è®¿é—®è€…æ¨¡å¼ä¸­å…·ä½“å…ƒç´ å¯¹è®¿é—®è€…å…¬å¸ƒç»†èŠ‚ï¼Œè¿™ç ´åäº†å¯¹è±¡çš„å°è£…æ€§ã€‚ è¿åäº†ä¾èµ–å€’ç½®åŸåˆ™ã€‚è®¿é—®è€…æ¨¡å¼ä¾èµ–äº†å…·ä½“ç±»ï¼Œè€Œæ²¡æœ‰ä¾èµ–æŠ½è±¡ç±»ã€‚ package Visitor import \"fmt\" type IVisitor interface { Visit() } type WeiBoVisitor struct { } func (w WeiBoVisitor) Visit() { fmt.Println(\"visit weibo\") } type IQIYIVisitor struct { } func (I IQIYIVisitor) Visit() { fmt.Println(\"visit iqiyi\") } type IElement interface { Accept(visitor IVisitor) } type Element struct { } func (e Element) Accept(v IVisitor) { v.Visit() } package Visitor import \"testing\" func TestElement_Accept(t *testing.T) { e := new(Element) e.Accept(new(WeiBoVisitor)) e.Accept(new(IQIYIVisitor)) } ","date":"2023-04-06","objectID":"/design_pattern/:4:11","tags":["Golang","è®¾è®¡æ¨¡å¼"],"title":"è®¾è®¡æ¨¡å¼","uri":"/design_pattern/"},{"categories":["Golang"],"content":"å¿«é€ŸæŒæ¡golangçš„è¯­æ³•çŸ¥è¯†","date":"2023-04-06","objectID":"/golang-quick/","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"ä»£ç è§„èŒƒ ","date":"2023-04-06","objectID":"/golang-quick/:1:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1. ä¸ºä»€ä¹ˆéœ€è¦ä»£ç è§„èŒƒ ä»£ç è§„èŒƒä¸æ˜¯å¼ºåˆ¶çš„ï¼Œä¹Ÿå°±æ˜¯ä½ ä¸éµå¾ªä»£ç è§„èŒƒå†™å‡ºæ¥çš„ä»£ç è¿è¡Œä¹Ÿæ˜¯å®Œå…¨æ²¡æœ‰é—®é¢˜çš„ ä»£ç è§„èŒƒç›®çš„æ˜¯æ–¹ä¾¿å›¢é˜Ÿå½¢æˆä¸€ä¸ªç»Ÿä¸€çš„ä»£ç é£æ ¼ï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§ï¼Œè§„èŒƒæ€§å’Œç»Ÿä¸€æ€§ã€‚æœ¬è§„èŒƒå°†ä»å‘½åè§„èŒƒï¼Œæ³¨é‡Šè§„èŒƒï¼Œä»£ç é£æ ¼å’Œ Go è¯­è¨€æä¾›çš„å¸¸ç”¨çš„å·¥å…·è¿™å‡ ä¸ªæ–¹é¢åšä¸€ä¸ªè¯´æ˜ã€‚ è§„èŒƒå¹¶ä¸æ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ç†è®ºä¸Šæ¯ä¸ªå…¬å¸éƒ½å¯ä»¥åˆ¶å®šè‡ªå·±çš„è§„èŒƒï¼Œä¸è¿‡ä¸€èˆ¬æ¥è¯´æ•´ä½“ä¸Šè§„èŒƒå·®å¼‚ä¸ä¼šå¾ˆå¤§ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:1:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2. ä»£ç è§„èŒƒ 2.1 å‘½åè§„èŒƒ å‘½åæ˜¯ä»£ç è§„èŒƒä¸­å¾ˆé‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œç»Ÿä¸€çš„å‘½åè§„åˆ™æœ‰åˆ©äºæé«˜çš„ä»£ç çš„å¯è¯»æ€§ï¼Œå¥½çš„å‘½åä»…ä»…é€šè¿‡å‘½åå°±å¯ä»¥è·å–åˆ°è¶³å¤Ÿå¤šçš„ä¿¡æ¯ã€‚ a. å½“å‘½åï¼ˆåŒ…æ‹¬å¸¸é‡ã€å˜é‡ã€ç±»å‹ã€å‡½æ•°åã€ç»“æ„å­—æ®µç­‰ç­‰ï¼‰ä»¥ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å¤´ï¼Œå¦‚ï¼šGroup1ï¼Œé‚£ä¹ˆä½¿ç”¨è¿™ç§å½¢å¼çš„æ ‡è¯†ç¬¦çš„å¯¹è±¡å°±å¯ä»¥è¢«å¤–éƒ¨åŒ…çš„ä»£ç æ‰€ä½¿ç”¨ï¼ˆå®¢æˆ·ç«¯ç¨‹åºéœ€è¦å…ˆå¯¼å…¥è¿™ä¸ªåŒ…ï¼‰ï¼Œè¿™è¢«ç§°ä¸ºå¯¼å‡ºï¼ˆåƒé¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„ publicï¼‰ï¼› b. å‘½åå¦‚æœä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œåˆ™å¯¹åŒ…å¤–æ˜¯ä¸å¯è§çš„ï¼Œä½†æ˜¯ä»–ä»¬åœ¨æ•´ä¸ªåŒ…çš„å†…éƒ¨æ˜¯å¯è§å¹¶ä¸”å¯ç”¨çš„ï¼ˆåƒé¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„ private ï¼‰ 2.1.1 åŒ…åï¼špackage ä¿æŒ package çš„åå­—å’Œç›®å½•ä¿æŒä¸€è‡´ï¼Œå°½é‡é‡‡å–æœ‰æ„ä¹‰çš„åŒ…åï¼Œç®€çŸ­ï¼Œæœ‰æ„ä¹‰ï¼Œå°½é‡å’Œæ ‡å‡†åº“ä¸è¦å†²çªã€‚åŒ…ååº”è¯¥ä¸ºå°å†™å•è¯ï¼Œä¸è¦ä½¿ç”¨ä¸‹åˆ’çº¿æˆ–è€…æ··åˆå¤§å°å†™ã€‚ package model package main 2.1.2 æ–‡ä»¶å å°½é‡é‡‡å–æœ‰æ„ä¹‰çš„æ–‡ä»¶åï¼Œç®€çŸ­ï¼Œæœ‰æ„ä¹‰ï¼Œåº”è¯¥ä¸ºå°å†™å•è¯ï¼Œä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å„ä¸ªå•è¯ã€‚ user_model.go 2.1.3 ç»“æ„ä½“å‘½å é‡‡ç”¨é©¼å³°å‘½åæ³•ï¼Œé¦–å­—æ¯æ ¹æ®è®¿é—®æ§åˆ¶å¤§å†™æˆ–è€…å°å†™ struct ç”³æ˜å’Œåˆå§‹åŒ–æ ¼å¼é‡‡ç”¨å¤šè¡Œï¼Œä¾‹å¦‚ä¸‹é¢ï¼š // å¤šè¡Œç”³æ˜ type User struct{ Username string Email string } // å¤šè¡Œåˆå§‹åŒ– u := User{ Username: \"bobby\", Email: \"bobby@imooc.com\", } 2.1.4 æ¥å£å‘½å å‘½åè§„åˆ™åŸºæœ¬å’Œä¸Šé¢çš„ç»“æ„ä½“ç±»å‹ å•ä¸ªå‡½æ•°çš„ç»“æ„åä»¥ â€œerâ€ ä½œä¸ºåç¼€ï¼Œä¾‹å¦‚ Reader , Writer ã€‚ type Reader interface { Read(p []byte) (n int, err error) } 2.1.5 å˜é‡å‘½å å’Œç»“æ„ä½“ç±»ä¼¼ï¼Œå˜é‡åç§°ä¸€èˆ¬éµå¾ªé©¼å³°æ³•ï¼Œé¦–å­—æ¯æ ¹æ®è®¿é—®æ§åˆ¶åŸåˆ™å¤§å†™æˆ–è€…å°å†™ï¼Œä½†é‡åˆ°ç‰¹æœ‰åè¯æ—¶ï¼Œéœ€è¦éµå¾ªä»¥ä¸‹è§„åˆ™ï¼š å¦‚æœå˜é‡ä¸ºç§æœ‰ï¼Œä¸”ç‰¹æœ‰åè¯ä¸ºé¦–ä¸ªå•è¯ï¼Œåˆ™ä½¿ç”¨å°å†™ï¼Œå¦‚ apiClient å…¶å®ƒæƒ…å†µéƒ½åº”å½“ä½¿ç”¨è¯¥åè¯åŸæœ‰çš„å†™æ³•ï¼Œå¦‚ APIClientã€repoIDã€UserID é”™è¯¯ç¤ºä¾‹ï¼šUrlArrayï¼Œåº”è¯¥å†™æˆ urlArray æˆ–è€… URLArray è‹¥å˜é‡ç±»å‹ä¸º bool ç±»å‹ï¼Œåˆ™åç§°åº”ä»¥ Has, Is, Can æˆ– Allow å¼€å¤´ var isExist bool var hasConflict bool var canManage bool var allowGitHook bool 2.1.6 å¸¸é‡å‘½å å¸¸é‡å‡éœ€ä½¿ç”¨å…¨éƒ¨å¤§å†™å­—æ¯ç»„æˆï¼Œå¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†è¯ å¦‚æœæ˜¯æšä¸¾ç±»å‹çš„å¸¸é‡ï¼Œéœ€è¦å…ˆåˆ›å»ºç›¸åº”ç±»å‹ï¼š ","date":"2023-04-06","objectID":"/golang-quick/:1:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2.2 æ³¨é‡Š Go æä¾› C é£æ ¼çš„/* */å—æ³¨é‡Šå’Œ C ++é£æ ¼çš„//è¡Œæ³¨é‡Šã€‚è¡Œæ³¨é‡Šæ˜¯å¸¸æ€ï¼›å—æ³¨é‡Šä¸»è¦æ˜¾ç¤ºä¸ºåŒ…æ³¨é‡Šï¼Œä½†åœ¨è¡¨è¾¾å¼ä¸­å¾ˆæœ‰ç”¨æˆ–ç¦ç”¨å¤§é‡ä»£ç ã€‚ å•è¡Œæ³¨é‡Šæ˜¯æœ€å¸¸è§çš„æ³¨é‡Šå½¢å¼ï¼Œä½ å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ä»¥ // å¼€å¤´çš„å•è¡Œæ³¨é‡Š å¤šè¡Œæ³¨é‡Šä¹Ÿå«å—æ³¨é‡Šï¼Œå‡å·²ä»¥ /_ å¼€å¤´ï¼Œå¹¶ä»¥ _/ ç»“å°¾ï¼Œä¸”ä¸å¯ä»¥åµŒå¥—ä½¿ç”¨ï¼Œå¤šè¡Œæ³¨é‡Šä¸€èˆ¬ç”¨äºåŒ…çš„æ–‡æ¡£æè¿°æˆ–æ³¨é‡Šæˆå—çš„ä»£ç ç‰‡æ®µ go è¯­è¨€è‡ªå¸¦çš„ go doc å·¥å…·å¯ä»¥æ ¹æ®æ³¨é‡Šç”Ÿæˆæ–‡æ¡£ï¼Œç”Ÿæˆå¯ä»¥è‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„ç½‘ç«™ï¼ˆgolang.org å°±æ˜¯ä½¿ç”¨ godoc å·¥å…·ç›´æ¥ç”Ÿæˆçš„ï¼‰ï¼Œæ³¨é‡Šçš„è´¨é‡å†³å®šäº†ç”Ÿæˆçš„æ–‡æ¡£çš„è´¨é‡ã€‚æ¯ä¸ªåŒ…éƒ½åº”è¯¥æœ‰ä¸€ä¸ªåŒ…æ³¨é‡Šï¼Œåœ¨ package å­å¥ä¹‹å‰æœ‰ä¸€ä¸ªå—æ³¨é‡Šã€‚å¯¹äºå¤šæ–‡ä»¶åŒ…ï¼ŒåŒ…æ³¨é‡Šåªéœ€è¦å­˜åœ¨äºä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥ã€‚åŒ…è¯„è®ºåº”è¯¥ä»‹ç»åŒ…ï¼Œå¹¶æä¾›ä¸æ•´ä¸ªåŒ…ç›¸å…³çš„ä¿¡æ¯ã€‚å®ƒå°†é¦–å…ˆå‡ºç°åœ¨ godoc é¡µé¢ä¸Šï¼Œå¹¶åº”è®¾ç½®ä¸‹é¢çš„è¯¦ç»†æ–‡æ¡£ã€‚ 2.2.1 åŒ…æ³¨é‡Š æ¯ä¸ªåŒ…éƒ½åº”è¯¥æœ‰ä¸€ä¸ªåŒ…æ³¨é‡Šï¼Œä¸€ä¸ªä½äº package å­å¥ä¹‹å‰çš„å—æ³¨é‡Šæˆ–è¡Œæ³¨é‡Šã€‚åŒ…å¦‚æœæœ‰å¤šä¸ª go æ–‡ä»¶ï¼Œåªéœ€è¦å‡ºç°åœ¨ä¸€ä¸ª go æ–‡ä»¶ä¸­ï¼ˆä¸€èˆ¬æ˜¯å’ŒåŒ…åŒåçš„æ–‡ä»¶ï¼‰å³å¯ã€‚ åŒ…æ³¨é‡Šåº”è¯¥åŒ…å«ä¸‹é¢åŸºæœ¬ä¿¡æ¯(è¯·ä¸¥æ ¼æŒ‰ç…§è¿™ä¸ªé¡ºåºï¼Œç®€ä»‹ï¼Œåˆ›å»ºäººï¼Œåˆ›å»ºæ—¶é—´ï¼‰ï¼š åŒ…çš„åŸºæœ¬ç®€ä»‹ï¼ˆåŒ…åï¼Œç®€ä»‹ï¼‰ åˆ›å»ºè€…ï¼Œæ ¼å¼ï¼š åˆ›å»ºäººï¼š rtx å åˆ›å»ºæ—¶é—´ï¼Œæ ¼å¼ï¼šåˆ›å»ºæ—¶é—´ï¼š yyyyMMdd 2.2.2 ç»“æ„ï¼ˆæ¥å£ï¼‰æ³¨é‡Š æ¯ä¸ªè‡ªå®šä¹‰çš„ç»“æ„ä½“æˆ–è€…æ¥å£éƒ½åº”è¯¥æœ‰æ³¨é‡Šè¯´æ˜ï¼Œè¯¥æ³¨é‡Šå¯¹ç»“æ„è¿›è¡Œç®€è¦ä»‹ç»ï¼Œæ”¾åœ¨ç»“æ„ä½“å®šä¹‰çš„å‰ä¸€è¡Œï¼Œæ ¼å¼ä¸ºï¼š ç»“æ„ä½“åï¼Œ ç»“æ„ä½“è¯´æ˜ã€‚åŒæ—¶ç»“æ„ä½“å†…çš„æ¯ä¸ªæˆå‘˜å˜é‡éƒ½è¦æœ‰è¯´æ˜ï¼Œè¯¥è¯´æ˜æ”¾åœ¨æˆå‘˜å˜é‡çš„åé¢ï¼ˆæ³¨æ„å¯¹é½ï¼‰ï¼Œå®ä¾‹å¦‚ä¸‹ï¼š 2.2.3 å‡½æ•°ï¼ˆæ–¹æ³•ï¼‰æ³¨é‡Š æ¯ä¸ªå‡½æ•°ï¼Œæˆ–è€…æ–¹æ³•ï¼ˆç»“æ„ä½“æˆ–è€…æ¥å£ä¸‹çš„å‡½æ•°ç§°ä¸ºæ–¹æ³•ï¼‰éƒ½åº”è¯¥æœ‰æ³¨é‡Šè¯´æ˜ï¼Œå‡½æ•°çš„æ³¨é‡Šåº”è¯¥åŒ…æ‹¬ä¸‰ä¸ªæ–¹é¢ï¼ˆä¸¥æ ¼æŒ‰ç…§æ­¤é¡ºåºæ’°å†™ï¼‰ï¼š ç®€è¦è¯´æ˜ï¼Œæ ¼å¼è¯´æ˜ï¼šä»¥å‡½æ•°åå¼€å¤´ï¼Œâ€œï¼Œâ€åˆ†éš”è¯´æ˜éƒ¨åˆ† å‚æ•°åˆ—è¡¨ï¼šæ¯è¡Œä¸€ä¸ªå‚æ•°ï¼Œå‚æ•°åå¼€å¤´ï¼Œâ€œï¼Œâ€åˆ†éš”è¯´æ˜éƒ¨åˆ† è¿”å›å€¼ï¼š æ¯è¡Œä¸€ä¸ªè¿”å›å€¼ 2.2.4 ä»£ç é€»è¾‘æ³¨é‡Š å¯¹äºä¸€äº›å…³é”®ä½ç½®çš„ä»£ç é€»è¾‘ï¼Œæˆ–è€…å±€éƒ¨è¾ƒä¸ºå¤æ‚çš„é€»è¾‘ï¼Œéœ€è¦æœ‰ç›¸åº”çš„é€»è¾‘è¯´æ˜ï¼Œæ–¹ä¾¿å…¶ä»–å¼€å‘è€…é˜…è¯»è¯¥æ®µä»£ç ï¼Œå®ä¾‹å¦‚ä¸‹ï¼š 2.2.5 æ³¨é‡Šé£æ ¼ ç»Ÿä¸€ä½¿ç”¨ä¸­æ–‡æ³¨é‡Šï¼Œå¯¹äºä¸­è‹±æ–‡å­—ç¬¦ä¹‹é—´ä¸¥æ ¼ä½¿ç”¨ç©ºæ ¼åˆ†éš”ï¼Œ è¿™ä¸ªä¸ä»…ä»…æ˜¯ä¸­æ–‡å’Œè‹±æ–‡ä¹‹é—´ï¼Œè‹±æ–‡å’Œä¸­æ–‡æ ‡ç‚¹ä¹‹é—´ä¹Ÿéƒ½è¦ä½¿ç”¨ç©ºæ ¼åˆ†éš”ï¼Œä¾‹å¦‚ï¼š ä¸Šé¢ Redis ã€ id ã€ DB å’Œå…¶ä»–ä¸­æ–‡å­—ç¬¦ä¹‹é—´éƒ½æ˜¯ç”¨äº†ç©ºæ ¼åˆ†éš”ã€‚ å»ºè®®å…¨éƒ¨ä½¿ç”¨å•è¡Œæ³¨é‡Š å’Œä»£ç çš„è§„èŒƒä¸€æ ·ï¼Œå•è¡Œæ³¨é‡Šä¸è¦è¿‡é•¿ï¼Œç¦æ­¢è¶…è¿‡ 120 å­—ç¬¦ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:1:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2.3 import è§„èŒƒ import åœ¨å¤šè¡Œçš„æƒ…å†µä¸‹ï¼Œgoimports ä¼šè‡ªåŠ¨å¸®ä½ æ ¼å¼åŒ–ï¼Œä½†æ˜¯æˆ‘ä»¬è¿™é‡Œè¿˜æ˜¯è§„èŒƒä¸€ä¸‹ import çš„ä¸€äº›è§„èŒƒï¼Œå¦‚æœä½ åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œé¢å¼•å…¥äº†ä¸€ä¸ª packageï¼Œè¿˜æ˜¯å»ºè®®é‡‡ç”¨å¦‚ä¸‹æ ¼å¼ï¼š å¦‚æœä½ çš„åŒ…å¼•å…¥äº†ä¸‰ç§ç±»å‹çš„åŒ…ï¼Œæ ‡å‡†åº“åŒ…ï¼Œç¨‹åºå†…éƒ¨åŒ…ï¼Œç¬¬ä¸‰æ–¹åŒ…ï¼Œå»ºè®®é‡‡ç”¨å¦‚ä¸‹æ–¹å¼è¿›è¡Œç»„ç»‡ä½ çš„åŒ…ï¼š æœ‰é¡ºåºçš„å¼•å…¥åŒ…ï¼Œä¸åŒçš„ç±»å‹é‡‡ç”¨ç©ºæ ¼åˆ†ç¦»ï¼Œç¬¬ä¸€ç§å®æ ‡å‡†åº“ï¼Œç¬¬äºŒæ˜¯é¡¹ç›®åŒ…ï¼Œç¬¬ä¸‰æ˜¯ç¬¬ä¸‰æ–¹åŒ…ã€‚ åœ¨é¡¹ç›®ä¸­ä¸è¦ä½¿ç”¨ç›¸å¯¹è·¯å¾„å¼•å…¥åŒ…ï¼š ä½†æ˜¯å¦‚æœæ˜¯å¼•å…¥æœ¬é¡¹ç›®ä¸­çš„å…¶ä»–åŒ…ï¼Œæœ€å¥½ä½¿ç”¨ç›¸å¯¹è·¯å¾„ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:1:4","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2.4 é”™è¯¯å¤„ç† é”™è¯¯å¤„ç†çš„åŸåˆ™å°±æ˜¯ä¸èƒ½ä¸¢å¼ƒä»»ä½•æœ‰è¿”å› err çš„è°ƒç”¨ï¼Œä¸è¦ä½¿ç”¨ _ ä¸¢å¼ƒï¼Œå¿…é¡»å…¨éƒ¨å¤„ç†ã€‚æ¥æ”¶åˆ°é”™è¯¯ï¼Œè¦ä¹ˆè¿”å› errï¼Œæˆ–è€…ä½¿ç”¨ log è®°å½•ä¸‹æ¥ å°½æ—© returnï¼šä¸€æ—¦æœ‰é”™è¯¯å‘ç”Ÿï¼Œé©¬ä¸Šè¿”å› å°½é‡ä¸è¦ä½¿ç”¨ panicï¼Œé™¤éä½ çŸ¥é“ä½ åœ¨åšä»€ä¹ˆ é”™è¯¯æè¿°å¦‚æœæ˜¯è‹±æ–‡å¿…é¡»ä¸ºå°å†™ï¼Œä¸éœ€è¦æ ‡ç‚¹ç»“å°¾ é‡‡ç”¨ç‹¬ç«‹çš„é”™è¯¯æµè¿›è¡Œå¤„ç† ","date":"2023-04-06","objectID":"/golang-quick/:1:5","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"è¯­è¨€ç‰¹æ€§ ","date":"2023-04-06","objectID":"/golang-quick/:2:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 Go è¯­è¨€ä¸»è¦ç‰¹æ€§ è‡ªåŠ¨åƒåœ¾å›æ”¶ æ›´ä¸°å¯Œçš„å†…ç½®ç±»å‹ å‡½æ•°å¤šè¿”å›å€¼ é”™è¯¯å¤„ç† åŒ¿åå‡½æ•°å’Œé—­åŒ… ç±»å‹å’Œæ¥å£ å¹¶å‘ç¼–ç¨‹ åå°„ è¯­è¨€äº¤äº’æ€§ 1.1 è‡ªåŠ¨åƒåœ¾å›æ”¶ å†…å­˜æ³„éœ²çš„æœ€ä½³è§£å†³æ–¹æ¡ˆæ˜¯åœ¨è¯­è¨€çº§åˆ«å¼•å…¥è‡ªåŠ¨åƒåœ¾å›æ”¶ç®—æ³•ï¼ˆGarbage Collectionï¼Œç®€ç§° GCï¼‰ã€‚ æ‰€è°“åƒåœ¾å›æ”¶ï¼Œå³æ‰€æœ‰çš„å†…å­˜åˆ†é…åŠ¨ä½œéƒ½ä¼šè¢«åœ¨è¿è¡Œæ—¶è®°å½•ï¼ŒåŒæ—¶ä»»ä½•å¯¹ è¯¥å†…å­˜çš„ä½¿ç”¨ä¹Ÿéƒ½ä¼šè¢«è®°å½•ï¼Œç„¶ååƒåœ¾å›æ”¶å™¨ä¼šå¯¹æ‰€æœ‰å·²ç»åˆ†é…çš„å†…å­˜è¿›è¡Œè·Ÿè¸ªç›‘æµ‹ï¼Œä¸€æ—¦å‘ç° æœ‰äº›å†…å­˜å·²ç»ä¸å†è¢«ä»»ä½•äººä½¿ç”¨ï¼Œå°±é˜¶æ®µæ€§åœ°å›æ”¶è¿™äº›æ²¡äººç”¨çš„å†…å­˜ã€‚ ä½¿ç”¨ Go è¯­è¨€ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬åˆ¤æ–­ï¼Œå¹¶åœ¨åˆé€‚çš„æ—¶å€™ï¼ˆæ¯”å¦‚ CPU ç›¸å¯¹ç©ºé—²çš„æ—¶å€™ï¼‰è¿›è¡Œè‡ªåŠ¨åƒåœ¾æ”¶é›†å·¥ä½œã€‚ 1.2 æ›´ä¸°å¯Œçš„å†…ç½®ç±»å‹ map ï¼ˆå¯ä»¥è®¤ä¸ºæ˜¯å­—å…¸ï¼‰ sliceï¼ˆä¸€ç§å¯åŠ¨æ€å¢é•¿çš„æ•°ç»„ï¼‰ 1.3 å‡½æ•°å¤šè¿”å›å€¼ Go è¯­è¨€é©å‘½æ€§åœ°åœ¨é™æ€å¼€å‘è¯­è¨€é˜µè¥ä¸­ç‡å…ˆæä¾›äº†å¤šè¿”å›å€¼åŠŸèƒ½ã€‚ 1.4 é”™è¯¯å¤„ç† Go è¯­è¨€å¼•å…¥äº† 3 ä¸ªå…³é”®å­—ç”¨äºæ ‡å‡†çš„é”™è¯¯å¤„ç†æµç¨‹ï¼Œè¿™ 3 ä¸ªå…³é”®å­—åˆ†åˆ«ä¸ºdeferã€panic å’Œ recoverã€‚Go è¯­è¨€çš„é”™è¯¯å¤„ç†æœºåˆ¶å¯ä»¥å¤§é‡å‡å°‘ä»£ç é‡ï¼Œè®©å¼€å‘è€…ä¹Ÿæ— éœ€ä»…ä»…ä¸ºäº†ç¨‹åºå®‰å…¨æ€§è€Œæ·»åŠ å¤§é‡ ä¸€å±‚å¥—ä¸€å±‚çš„ try-catch è¯­å¥ã€‚ 1.5 åŒ¿åå‡½æ•°å’Œé—­åŒ… åœ¨ Go è¯­è¨€ä¸­ï¼Œæ‰€æœ‰çš„å‡½æ•°ä¹Ÿæ˜¯å€¼ç±»å‹ï¼Œå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ã€‚Go è¯­è¨€æ”¯æŒå¸¸è§„çš„åŒ¿åå‡½æ•°å’Œé—­åŒ…ã€‚ 1.6 ç±»å‹å’Œæ¥å£ ç±»å‹çš„å®šä¹‰ä½¿ç”¨structå…³é”®å­—ã€‚å¼•å…¥äº†ä¸€ä¸ªæ— æ¯”å¼ºå¤§çš„**â€œéä¾µå…¥å¼â€ æ¥å£**çš„æ¦‚å¿µã€‚ //å®šä¹‰ä¸€ä¸ªé¸Ÿç±»å‹ type Bird struct { ... } //é¸Ÿç±»å‹çš„æ–¹æ³• func (b *Bird) Fly() { // ä»¥é¸Ÿçš„æ–¹å¼é£è¡Œ } //å®šä¹‰ä¸€ä¸ªIFlyæ¥å£ type IFly interface { Fly() } //ä½¿ç”¨æ¥å£ func main() { var fly IFly = new(Bird) fly.Fly() } å¯ä»¥çœ‹å‡ºï¼Œè™½ç„¶ Bird ç±»å‹å®ç°çš„æ—¶å€™ï¼Œæ²¡æœ‰å£°æ˜ä¸æ¥å£ IFly çš„å…³ç³»ï¼Œä½†æ¥å£å’Œç±»å‹å¯ä»¥ç›´æ¥è½¬æ¢ï¼Œç”šè‡³æ¥å£çš„å®šä¹‰éƒ½ä¸ç”¨åœ¨ç±»å‹å®šä¹‰ä¹‹å‰ï¼Œè¿™ç§æ¯”è¾ƒæ¾æ•£çš„å¯¹åº”å…³ç³»å¯ä»¥å¤§å¹…é™ä½å› ä¸ºæ¥å£è°ƒæ•´è€Œå¯¼è‡´çš„å¤§é‡ä»£ç è°ƒæ•´å·¥ä½œã€‚ 1.7 å¹¶å‘ç¼–ç¨‹ å¼•å…¥äº† goroutine æ¦‚å¿µï¼Œä½¿ç”¨æ¶ˆæ¯ä¼ é€’æ¥å…±äº«å†…å­˜ã€‚Go è¯­è¨€è®©å¹¶å‘ç¼–ç¨‹å˜å¾—æ›´åŠ è½»ç›ˆå’Œå®‰å…¨ã€‚ é€šè¿‡åœ¨å‡½æ•°è°ƒç”¨å‰ä½¿ç”¨å…³é”®å­— goï¼Œæˆ‘ä»¬å³å¯è®©è¯¥å‡½æ•°ä»¥ goroutine æ–¹å¼æ‰§è¡Œã€‚goroutineæ˜¯ä¸€ç§æ¯”çº¿ç¨‹æ›´åŠ è½»ç›ˆã€æ›´çœèµ„æºçš„åç¨‹ã€‚ã€‚Go è¯­è¨€é€šè¿‡ç³»ç»Ÿçš„çº¿ç¨‹æ¥å¤šè·¯æ´¾é£è¿™äº›å‡½æ•°çš„æ‰§è¡Œï¼Œä½¿å¾—æ¯ä¸ªç”¨ go å…³é”®å­—æ‰§è¡Œçš„å‡½æ•°å¯ä»¥è¿è¡Œæˆä¸ºä¸€ä¸ªå•ä½åç¨‹ã€‚å½“ä¸€ä¸ªåç¨‹é˜»å¡çš„æ—¶å€™ï¼Œè°ƒåº¦å™¨å°±ä¼šè‡ªåŠ¨æŠŠå…¶ä»–åç¨‹å®‰æ’åˆ°å¦å¤–çš„çº¿ç¨‹ä¸­å»æ‰§è¡Œï¼Œä»è€Œå®ç°äº†ç¨‹åºæ— ç­‰å¾…å¹¶è¡ŒåŒ–è¿è¡Œã€‚è€Œä¸”è°ƒåº¦çš„å¼€é”€éå¸¸å°ï¼Œä¸€é¢— CPU è°ƒåº¦çš„è§„æ¨¡ä¸ä¸‹äºæ¯ç§’ç™¾ä¸‡æ¬¡ï¼Œè¿™ä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºå¤§é‡çš„ goroutineï¼Œä»è€Œå¯ä»¥å¾ˆè½»æ¾åœ°ç¼–å†™é«˜å¹¶å‘ç¨‹åºï¼Œè¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„ç›®çš„ã€‚ ä½¿ç”¨ CSP(é€šä¿¡é¡ºåºè¿›ç¨‹ï¼ŒCommunicating Sequential Process)æ¨¡å‹æ¥ä½œä¸º goroutine é—´çš„æ¨èé€šä¿¡æ–¹å¼ã€‚(åœ¨ CSP æ¨¡å‹ä¸­ï¼Œä¸€ä¸ªå¹¶å‘ç³»ç»Ÿç”±è‹¥å¹²å¹¶è¡Œè¿è¡Œçš„é¡ºåºè¿›ç¨‹ç»„æˆï¼Œæ¯ä¸ªè¿›ç¨‹ä¸ èƒ½å¯¹å…¶ä»–è¿›ç¨‹çš„å˜é‡èµ‹å€¼ã€‚è¿›ç¨‹ä¹‹é—´åªèƒ½é€šè¿‡ä¸€å¯¹é€šä¿¡åŸè¯­å®ç°åä½œã€‚)Go è¯­è¨€ç”¨channelï¼ˆé€šé“ï¼‰ è¿™ä¸ªæ¦‚å¿µæ¥è½»å·§åœ°å®ç°äº† CSP æ¨¡å‹ï¼Œå¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œè·¨ goroutine çš„é€šä¿¡ã€‚ ç”±äºä¸€ä¸ªè¿›ç¨‹å†…åˆ›å»ºçš„æ‰€æœ‰ goroutine è¿è¡Œåœ¨åŒä¸€ä¸ªå†…å­˜åœ°å€ç©ºé—´ä¸­ï¼Œå› æ­¤å¦‚æœä¸åŒçš„ goroutine ä¸å¾—ä¸å»è®¿é—®å…±äº«çš„å†…å­˜å˜é‡ï¼Œè®¿é—®å‰åº”è¯¥å…ˆè·å–ç›¸åº”çš„è¯»å†™é”ã€‚Go è¯­è¨€æ ‡å‡†åº“ä¸­çš„ sync åŒ…æä¾›äº†å®Œå¤‡çš„è¯»å†™é”åŠŸèƒ½ //ç”±ä¸¤ä¸ªgoroutineè¿›è¡Œå¹¶è¡Œçš„ç´¯åŠ è®¡ç®—ï¼Œå¾…è¿™ä¸¤ä¸ªè®¡ç®—è¿‡ç¨‹éƒ½å®Œæˆåæ‰“å°è®¡ç®—ç»“æœ package main import \"fmt\" func sum(values [] int, resultChan chan int) { sum := 0 for _, value := range values { sum += value } resultChan \u003c- sum // å°†è®¡ç®—ç»“æœå‘é€åˆ°channelä¸­ } func main() { values := [] int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} resultChan := make(chan int, 2) go sum(values[:len(values)/2], resultChan) go sum(values[len(values)/2:], resultChan) sum1, sum2 := \u003c-resultChan, \u003c-resultChan // æ¥æ”¶ç»“æœ fmt.Println(\"Result:\", sum1, sum2, sum1 + sum2) } 1.8 åå°„ åå°„(reflection)ï¼Œé€šè¿‡åå°„ï¼Œä½ å¯ä»¥è·å–å¯¹è±¡ç±»å‹çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¹¶å¯åŠ¨æ€æ“ä½œå¯¹è±¡ã€‚ åå°„æœ€å¸¸è§çš„ä½¿ç”¨åœºæ™¯æ˜¯åšå¯¹è±¡çš„åºåˆ—åŒ–(serializationï¼Œæœ‰æ—¶å€™ä¹Ÿå« Marshal \u0026 Unmarshal)ã€‚ //ä»¥åˆ©ç”¨åå°„åŠŸèƒ½åˆ—å‡ºæŸä¸ªç±»å‹ä¸­æ‰€æœ‰æˆå‘˜å˜é‡çš„å€¼ package main import ( \"fmt\" \"reflect\" ) type Bird struct { Name string LifeExpectance int } func (b *Bird) Fly() { fmt.Println(\"I am flying...\") } func main() { sparrow := \u0026Bird{\"Sparrow\", 3} s := reflect.ValueOf(sparrow).Elem() typeOfT := s.Type() for i := 0; i \u003c s.NumField(); i++ { f := s.Field(i) fmt.Printf(\"%d: %s %s = %v\\n\", i,typeOfT.Field(i).Name,f.Type(), f.Interface()) } } 1.9 è¯­è¨€äº¤äº’æ€§ Cgo æ—¢æ˜¯è¯­è¨€ç‰¹æ€§,åŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªå·¥å…·çš„åç§°,ç”¨äºé‡ç”¨ç°æœ‰ C æ¨¡å—ã€‚åœ¨ Go ä»£ç ä¸­ï¼Œå¯ä»¥æŒ‰ Cgo çš„ç‰¹å®šè¯­æ³•æ··åˆç¼–å†™ C è¯­è¨€ä»£ç ï¼Œç„¶å Cgo å·¥å…·å¯ä»¥å°†è¿™äº›æ··åˆçš„ C ä»£ç æå–å¹¶ç”Ÿæˆå¯¹äº C åŠŸèƒ½çš„è°ƒç”¨åŒ…è£…ä»£ç ã€‚å¼€å‘è€…åŸºæœ¬ä¸Šå¯ä»¥å®Œå…¨å¿½ç•¥è¿™ä¸ª Go è¯­è¨€å’Œ C è¯­è¨€çš„è¾¹ç•Œæ˜¯å¦‚ä½•è·¨è¶Šçš„ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:2:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 hello world package main import \"fmt\"// æˆ‘ä»¬éœ€è¦ä½¿ç”¨fmtåŒ…ä¸­çš„Println()å‡½æ•° func main() { fmt.Println(\"Hello, world. ä½ å¥½ï¼Œä¸–ç•Œï¼\") } package : æ¯ä¸ª Go æºä»£ç æ–‡ä»¶çš„å¼€å¤´éƒ½æ˜¯ä¸€ä¸ª package å£°æ˜ï¼Œè¡¨ç¤ºè¯¥ Go ä»£ç æ‰€å±çš„åŒ…ã€‚åŒ…æ˜¯ Go è¯­è¨€é‡Œ æœ€åŸºæœ¬çš„åˆ†å‘å•ä½ï¼Œä¹Ÿæ˜¯å·¥ç¨‹ç®¡ç†ä¸­ä¾èµ–å…³ç³»çš„ä½“ç°ã€‚è¦ç”Ÿæˆ Go å¯æ‰§è¡Œç¨‹åºï¼Œå¿…é¡»å»ºç«‹ä¸€ä¸ªåå­—ä¸º main çš„åŒ…ï¼Œå¹¶ä¸”åœ¨è¯¥åŒ…ä¸­åŒ…å«ä¸€ä¸ªå« main()çš„å‡½æ•°ï¼ˆè¯¥å‡½æ•°æ˜¯ Go å¯æ‰§è¡Œç¨‹åºçš„æ‰§è¡Œèµ·ç‚¹ï¼‰ã€‚ main() : **Go è¯­è¨€çš„ main()å‡½æ•°ä¸èƒ½å¸¦å‚æ•°ï¼Œä¹Ÿä¸èƒ½å®šä¹‰è¿”å›å€¼ã€‚**å‘½ä»¤è¡Œä¼ å…¥çš„å‚æ•°åœ¨ os.Args å˜é‡ ä¸­ä¿å­˜ã€‚å¦‚æœéœ€è¦æ”¯æŒå‘½ä»¤è¡Œå¼€å…³ï¼Œå¯ä½¿ç”¨ flag åŒ…ã€‚ å‡½æ•°: åœ¨å‡½æ•°è¿”å›æ—¶æ²¡æœ‰è¢«æ˜ç¡®èµ‹å€¼çš„è¿”å›å€¼éƒ½ä¼šè¢«è®¾ç½®ä¸ºé»˜è®¤ å€¼ï¼Œæ¯”å¦‚ result ä¼šè¢«è®¾ä¸º 0.0ï¼Œerr ä¼šè¢«è®¾ä¸º nilã€‚ func Compute(value1 int, value2 float64) (result float64, err error) { // å‡½æ•°ä½“ } 2.1 ç¼–è¯‘å¹¶è¿è¡Œ ä½¿ç”¨è¿™ä¸ªå‘½ä»¤ï¼Œä¼šå°†ç¼–è¯‘ã€é“¾æ¥å’Œè¿è¡Œ 3 ä¸ªæ­¥éª¤åˆå¹¶ä¸ºä¸€æ­¥ï¼Œè¿è¡Œå®Œååœ¨å½“å‰ç›®å½•ä¸‹ä¹Ÿçœ‹ä¸ åˆ°ä»»ä½•ä¸­é—´æ–‡ä»¶å’Œæœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚ go run hello.go åªç”Ÿæˆç¼–è¯‘ç»“æœè€Œä¸è‡ªåŠ¨è¿è¡Œã€‚ç¼–è¯‘ç»“æœä¸º hello çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚ go build hello.go ","date":"2023-04-06","objectID":"/golang-quick/:2:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 å·¥ç¨‹ç®¡ç† Go å‘½ä»¤è¡Œå·¥å…·çš„é©å‘½æ€§ä¹‹å¤„åœ¨äºå½»åº•æ¶ˆé™¤äº†å·¥ç¨‹æ–‡ä»¶çš„æ¦‚å¿µï¼Œå®Œå…¨ç”¨ç›®å½•ç»“æ„å’ŒåŒ…åæ¥æ¨ å¯¼å·¥ç¨‹ç»“æ„å’Œæ„å»ºé¡ºåºã€‚ ç¤ºä¾‹ï¼š è¿™æ ·ä¸€ä¸ªç¨‹åºï¼š $ calc help USAGE: calc command [arguments] ... The commands are: sqrt Square root of a non-negative value. add Addition of two values. $ calc sqrt 4 # å¼€æ ¹å· 2 $ calc add 1 2 # åŠ æ³• 3 å·¥ç¨‹ç»“æ„ï¼š ä¸€ä¸ªæ­£å¸¸çš„å·¥ç¨‹ç›®å½•ç»„ç»‡åº”è¯¥å¦‚ä¸‹æ‰€ç¤ºï¼š \u003ccalcproj\u003e â”œâ”€\u003csrc\u003e â”œâ”€\u003ccalc\u003e â”œâ”€calc.go â”œâ”€\u003csimplemath\u003e â”œâ”€add.go â”œâ”€add_test.go â”œâ”€sqrt.go â”œâ”€sqrt_test.go â”œâ”€\u003cbin\u003e â”œâ”€\u003cpkg\u003eï¼ƒåŒ…å°†è¢«å®‰è£…åˆ°æ­¤å¤„ å¯æ‰§è¡Œç¨‹åºï¼Œåä¸º calcï¼Œå†…éƒ¨åªåŒ…å«ä¸€ä¸ª calc.go æ–‡ä»¶ï¼› ç®—æ³•åº“ï¼Œåä¸º simplemathï¼Œæ¯ä¸ª command å¯¹åº”äºä¸€ä¸ªåŒåçš„ go æ–‡ä»¶ï¼Œæ¯”å¦‚ add.goã€‚ åœ¨ä¸Šé¢çš„ç»“æ„é‡Œï¼Œå¸¦å°–æ‹¬å·çš„åå­—è¡¨ç¤ºå…¶ä¸ºç›®å½•ã€‚xxx_test.go è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå¯¹äº xxx.go çš„å•å…ƒ æµ‹è¯•ï¼Œè¿™ä¹Ÿæ˜¯ Go å·¥ç¨‹é‡Œçš„å‘½åè§„åˆ™ã€‚ //calc.go package main import \"os\" // ç”¨äºè·å¾—å‘½ä»¤è¡Œå‚æ•°os.Args import \"fmt\" import \"simplemath\" import \"strconv\" var Usage = func() { fmt.Println(\"USAGE: calc command [arguments] ...\") fmt.Println(\"\\nThe commands are:\\n\\tadd\\tAddition of two values.\\n\\tsqrt\\tSquar root of a non - negative value.\") } func main() { args := os.Args if args == nil || len(args) \u003c 2 { Usage() return } switch args[0] { case \"add\": if len(args) != 3 { fmt.Println(\"USAGE: calc add \u003cinteger1\u003e\u003cinteger2\u003e\") return } v1, err1 := strconv.Atoi(args[1]) v2, err2 := strconv.Atoi(args[2]) if err1 != nil || err2 != nil { fmt.Println(\"USAGE: calc add \u003cinteger1\u003e\u003cinteger2\u003e\") return } ret := simplemath.Add(v1, v2) fmt.Println(\"Result: \", ret) case \"sqrt\": if len(args) != 2 { fmt.Println(\"USAGE: calc sqrt \u003cinteger\u003e\") return } v, err := strconv.Atoi(args[1]) if err != nil { fmt.Println(\"USAGE: calc sqrt \u003cinteger\u003e\") return } ret := simplemath.Sqrt(v) fmt.Println(\"Result: \", ret) default: Usage() } } // add.go package simplemath func Add(a int, b int) int { return a + b } // add_test.go package simplemath import \"testing\" func TestAdd1(t *testing.T) { r := Add(1, 2) if r != 3 { t.Errorf(\"Add(1, 2) failed. Got %d, expected 3.\", r) } } // sqrt.go package simplemath import \"math\" func Sqrt(i int) int { v := math.Sqrt(float64(i)) return int(v) } // sqrt_test.go package simplemath import \"testing\" func TestSqrt1(t *testing.T) { v := Sqrt(16) if v != 4 { t.Errorf(\"Sqrt(16) failed. Got %v, expected 4.\", v) } } å°†å½“å‰çš„å·¥ç¨‹çš„æ ¹ç›®å½•æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ GOPATH ä¸­ã€‚ ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚åŠ å…¥æ”¾åˆ°å½“å‰å·¥ç¨‹æ ¹ç›®å½•çš„ bin æ–‡ä»¶å¤¹ä¸­ï¼š cd /calcproj mkdir bin go build calc æˆ‘ä»¬ä¸éœ€è¦å†™ makefileï¼Œå› ä¸ºè¿™ä¸ªå·¥å…·ä¼šæ›¿æˆ‘ä»¬åˆ†æï¼ŒçŸ¥é“ç›®æ ‡ä»£ç çš„ç¼–è¯‘ç»“æœåº”è¯¥æ˜¯ä¸€ä¸ªåŒ…è¿˜æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¹¶åˆ†æ import è¯­å¥ä»¥äº†è§£åŒ…çš„ä¾èµ–å…³ç³»ï¼Œä»è€Œåœ¨ç¼–è¯‘ calc.go ä¹‹å‰å…ˆæŠŠä¾èµ–çš„ simplemath ç¼–è¯‘æ‰“åŒ…å¥½ã€‚ ç”±äºå·²ç»å†™äº†æµ‹è¯•ä»£ç ï¼Œå¹¶ä¸”å·²æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ GOPATH ä¸­ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥æµ‹è¯•ï¼š go test simplemath è‹¥éœ€è¦è°ƒè¯•ï¼Œå¯ç›´æ¥ä½¿ç”¨ gdb è°ƒè¯•ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶(gdb version \u003e7.1)ï¼Œegï¼š gdb calc ","date":"2023-04-06","objectID":"/golang-quick/:2:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"åŸºæœ¬è¯­æ³• ","date":"2023-04-06","objectID":"/golang-quick/:3:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 å˜é‡ 1.1 å£°æ˜ var v1 int var v2 string var v3 [10]int //æ•°ç»„ var v4 []int //æ•°ç»„åˆ‡ç‰‡ var v5 struct{ f int } var v6 *int //æŒ‡é’ˆ var v7 map[string] int //map keyä¸ºstring valueä¸ºint var v8 func(a int) int // åŒ¿åå‡½æ•° //å°†è‹¥å¹²ä¸ªå˜é‡å£°æ˜åœ¨ä¸€èµ·ï¼Œé¿å…äº†é‡å¤å†™var var ( v1 int v2 string ) 1.2 åˆå§‹åŒ– var v1 int = 10 // æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼1 var v2 = 10 // æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼2ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨å¯¼å‡ºv2çš„ç±»å‹ v3 := 10 // æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼3ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨å¯¼å‡ºv3çš„ç±»å‹ PSï¼šå‡ºç°åœ¨:=å·¦ä¾§çš„å˜é‡ä¸åº”è¯¥æ˜¯å·²ç»è¢«å£°æ˜è¿‡çš„ï¼Œå¦åˆ™ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚ 1.3 èµ‹å€¼ æ”¯æŒå¤šé‡èµ‹å€¼åŠŸèƒ½ï¼š i,j=j,i 1.4 åŒ¿åå˜é‡ åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¸ºäº†è·å–ä¸€ä¸ªå€¼ï¼Œå´å› ä¸ºè¯¥å‡½æ•°è¿”å›å¤šä¸ªå€¼è€Œä¸å¾—ä¸å®šä¹‰ä¸€å †æ²¡ç”¨çš„å˜é‡ã€‚è¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨åŒ¿åå˜é‡æ¥æ¥æ”¶ä¸éœ€è¦çš„å€¼ã€‚egï¼š func GetName() (firstName, lastName, nickName string) { return \"May\", \"Chan\", \"Chibi Maruko\" } _,_,nickName := GetName() ","date":"2023-04-06","objectID":"/golang-quick/:3:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 å¸¸é‡ Go è¯­è¨€ä¸­ï¼Œå¸¸é‡æ˜¯æŒ‡ç¼–è¯‘æœŸé—´å°±å·²çŸ¥ä¸”ä¸å¯æ”¹å˜çš„å€¼ã€‚å¸¸é‡å¯ä»¥æ˜¯æ•°å€¼ç±»å‹ï¼ˆåŒ…æ‹¬æ•´å‹ã€ æµ®ç‚¹å‹å’Œå¤æ•°ç±»å‹ï¼‰ã€å¸ƒå°”ç±»å‹ã€å­—ç¬¦ä¸²ç±»å‹ç­‰ã€‚ 2.1 å­—é¢å¸¸é‡ æ‰€è°“å­—é¢å¸¸é‡ï¼ˆliteralï¼‰ï¼Œæ˜¯æŒ‡ç¨‹åºä¸­ç¡¬ç¼–ç çš„å¸¸é‡ã€‚egï¼š -12 3.14159265358979323846 // æµ®ç‚¹ç±»å‹çš„å¸¸é‡ 3.2+12i // å¤æ•°ç±»å‹çš„å¸¸é‡ true // å¸ƒå°”ç±»å‹çš„å¸¸é‡ \"foo\" // å­—ç¬¦ä¸²å¸¸é‡ Go è¯­è¨€çš„å­—é¢å¸¸é‡æ›´æ¥è¿‘æˆ‘ä»¬è‡ªç„¶è¯­è¨€ä¸­çš„å¸¸é‡æ¦‚å¿µï¼Œå®ƒæ˜¯æ— ç±»å‹çš„ã€‚åªè¦è¿™ä¸ªå¸¸é‡åœ¨ç›¸åº”ç±»å‹çš„å€¼åŸŸèŒƒå›´å†…ï¼Œå°±å¯ä»¥ä½œä¸ºè¯¥ç±»å‹çš„å¸¸é‡ï¼Œæ¯”å¦‚ä¸Šé¢çš„å¸¸é‡-12ï¼Œå®ƒå¯ä»¥èµ‹å€¼ç»™ intã€uintã€int32ã€ int64ã€float32ã€float64ã€complex64ã€complex128 ç­‰ç±»å‹çš„å˜é‡ã€‚ 2.2 å¸¸é‡çš„å®šä¹‰ é€šè¿‡ const å…³é”®å­—ï¼Œç»™å­—é¢å¸¸é‡æŒ‡å®šä¸€ä¸ªå‹å¥½çš„åå­—ã€‚ const Pi float64 = 3.14159265358979323846 const zero = 0.0 // æ— ç±»å‹æµ®ç‚¹å¸¸é‡ const ( size int64 = 1024 eof = -1 // æ— ç±»å‹æ•´å‹å¸¸é‡ ) const u, v float32 = 0, 3 // u = 0.0, v = 3.0ï¼Œå¸¸é‡çš„å¤šé‡èµ‹å€¼ const a, b, c = 3, 4, \"foo\" // a = 3, b = 4, c = \"foo\", æ— ç±»å‹æ•´å‹å’Œå­—ç¬¦ä¸²å¸¸é‡ Go çš„å¸¸é‡å®šä¹‰å¯ä»¥é™å®šå¸¸é‡ç±»å‹ï¼Œä½†ä¸æ˜¯å¿…éœ€çš„ã€‚å¦‚æœå®šä¹‰å¸¸é‡æ—¶æ²¡æœ‰æŒ‡å®šç±»å‹ï¼Œé‚£ä¹ˆå®ƒ ä¸å­—é¢å¸¸é‡ä¸€æ ·ï¼Œæ˜¯æ— ç±»å‹å¸¸é‡ã€‚ å¸¸é‡çš„èµ‹å€¼æ˜¯ä¸€ä¸ªç¼–è¯‘æœŸè¡Œä¸ºï¼Œæ‰€ä»¥å³å€¼ä¸èƒ½å‡ºç°ä»»ä½•éœ€è¦è¿è¡ŒæœŸæ‰èƒ½å¾—å‡ºç»“æœçš„è¡¨è¾¾å¼ã€‚ 2.3 é¢„å®šä¹‰å¸¸é‡ Go è¯­è¨€é¢„å®šä¹‰äº†è¿™äº›å¸¸é‡ï¼štrueã€false å’Œ iotaã€‚ iota : iota æ¯”è¾ƒç‰¹æ®Šï¼Œå¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªå¯è¢«ç¼–è¯‘å™¨ä¿®æ”¹çš„å¸¸é‡ï¼Œåœ¨æ¯ä¸€ä¸ª const å…³é”®å­—å‡ºç°æ—¶è¢« é‡ç½®ä¸º 0ï¼Œç„¶ååœ¨ä¸‹ä¸€ä¸ª const å‡ºç°ä¹‹å‰ï¼Œæ¯å‡ºç°ä¸€æ¬¡ iotaï¼Œå…¶æ‰€ä»£è¡¨çš„æ•°å­—ä¼šè‡ªåŠ¨å¢ 1ã€‚å¦‚æœä¸¤ä¸ª const çš„èµ‹å€¼è¯­å¥çš„è¡¨è¾¾å¼æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå¯ä»¥çœç•¥åä¸€ä¸ªèµ‹å€¼è¡¨è¾¾å¼ã€‚ const ( // iotaè¢«é‡è®¾ä¸º0 c0 = iota // c0 == 0 c1 = iota // c1 == 1 c2 = iota // c2 == 2 ) const ( a = 1 \u003c\u003c iota // a == 1 (iotaåœ¨æ¯ä¸ªconstå¼€å¤´è¢«é‡è®¾ä¸º0) b = 1 \u003c\u003c iota // b == 2 c = 1 \u003c\u003c iota // c == 4 ) const ( u = iota * 42 // u == 0 v float64 = iota * 42 // v == 42.0 w = iota * 42 // w == 84 ) const x = iota // x == 0 (å› ä¸ºiotaåˆè¢«é‡è®¾ä¸º0äº†) const y = iota // y == 0 (åŒä¸Š) const ( // iotaè¢«é‡è®¾ä¸º0 c0 = iota // c0 == 0 c1 // c1 == 1 c2 // c2 == 2 ) const ( a = 1 \u003c\u003c iota // a == 1 (iotaåœ¨æ¯ä¸ªconstå¼€å¤´è¢«é‡è®¾ä¸º0) b // b == 2 c // c == 4 ) 2.4 æšä¸¾ åœ¨ const åè·Ÿä¸€å¯¹åœ†æ‹¬å·çš„æ–¹å¼å®šä¹‰ä¸€ç»„å¸¸é‡ï¼Œè¿™ç§å®šä¹‰æ³•åœ¨ Go è¯­è¨€ä¸­é€šå¸¸ç”¨äºå®šä¹‰æšä¸¾å€¼ã€‚ const ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday numberOfDays // è¿™ä¸ªå¸¸é‡æ²¡æœ‰å¯¼å‡º åŒ…å†…ç§æœ‰ ) ","date":"2023-04-06","objectID":"/golang-quick/:3:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 ç±»å‹ å†…ç½®åŸºç¡€ç±»å‹ å¸ƒå°”ç±»å‹ï¼šbool æ•´å‹ï¼š int8ã€byteã€int16ã€intã€uintã€uintptr ç­‰ æµ®ç‚¹ç±»å‹ï¼šfloat32ã€float64 å¤æ•°ç±»å‹ï¼šcomplex64ã€complex128 å­—ç¬¦ä¸²ï¼šstring å­—ç¬¦ç±»å‹ï¼šrune é”™è¯¯ç±»å‹ï¼šerror å¤åˆç±»å‹ æŒ‡é’ˆï¼ˆpointerï¼‰ æ•°ç»„ï¼ˆarrayï¼‰ åˆ‡ç‰‡ï¼ˆsliceï¼‰ å­—å…¸ï¼ˆmapï¼‰ é€šé“ï¼ˆchanï¼‰ ç»“æ„ä½“ï¼ˆstructï¼‰ æ¥å£ï¼ˆinterfaceï¼‰ 3.1 å¸ƒå°”ç±»å‹ å¸ƒå°”ç±»å‹ä¸èƒ½æ¥å—å…¶ä»–ç±»å‹çš„èµ‹å€¼ï¼Œä¸æ”¯æŒè‡ªåŠ¨æˆ–å¼ºåˆ¶çš„ç±»å‹è½¬æ¢ã€‚ 3.2 æ•´å‹ ç±»å‹ å­—èŠ‚ int8 1 int16 2 int64 8 int å¹³å°ç›¸å…³ uint8 1 uint16 2 uint32 4 uint64 8 uint å¹³å°ç›¸å…³ uintptr åŒæŒ‡é’ˆï¼ˆ32 ä½å¹³å°ä¸º 4 å­—èŠ‚ï¼Œ63 ä½å¹³å°ä¸‹ä½ 8 å­—èŠ‚ï¼‰ int32 4 æ•´å½¢ä¹‹é—´ä¸å¯ä»¥ç›´æ¥å€¼è½¬æ¢ï¼Œéœ€è¦åšå¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚ var value2 int32 value1:=64 value2=int32(value1) 3.3 æµ®ç‚¹å‹ ç±»å‹ å­—èŠ‚ float32 4 float64 8 3.4 å¤æ•°ç±»å‹ å¤æ•°å®é™…ä¸Šç”±ä¸¤ä¸ªå®æ•°ï¼ˆåœ¨è®¡ç®—æœºä¸­ç”¨æµ®ç‚¹æ•°è¡¨ç¤ºï¼‰æ„æˆï¼Œä¸€ä¸ªè¡¨ç¤ºå®éƒ¨ï¼ˆrealï¼‰ï¼Œä¸€ä¸ªè¡¨ç¤º è™šéƒ¨ï¼ˆimagï¼‰ã€‚ var value1 complex64 // ç”±2ä¸ªfloat32æ„æˆçš„å¤æ•°ç±»å‹ value1 = 3.2 + 12i value2 := 3.2 + 12i // value2æ˜¯complex128ç±»å‹ value3 := complex(3.2, 12) // value3ç»“æœåŒ value2 3.5 å­—ç¬¦ä¸² å­—ç¬¦ä¸²ä¸å¯ä»¥è¢«ä¿®æ”¹ï¼Œæ˜¯å¸¸é‡ã€‚å­—ç¬¦ä¸²æ“ä½œåŒ…æ‹¬ï¼š+ã€len(s)ã€s[i]ç­‰ï¼Œæ›´å¤šæ“ä½œï¼Œè§ strings åŒ…ã€‚ str := \"Hello,ä¸–ç•Œ\" for i, ch := range str { fmt.Println(i, ch)//chçš„ç±»å‹ä¸ºrune } str := \"Hello,ä¸–ç•Œ\" n := len(str) for i := 0; i \u003c n; i++ { ch := str[i] // ä¾æ®ä¸‹æ ‡å–å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼Œç±»å‹ä¸ºbyte fmt.Println(i, ch) } 3.6 å­—ç¬¦ç±»å‹ ç±»å‹ å¤‡æ³¨ byte UTF-8 å­—ç¬¦ä¸²çš„å•ä¸ªå­—èŠ‚çš„å€¼ rune ä»£è¡¨å•ä¸ª Unicode å­—ç¬¦ 3.7 æ•°ç»„ æ•°ç»„å°±æ˜¯æŒ‡ä¸€ç³»åˆ—åŒä¸€ç±»å‹æ•°æ® çš„é›†åˆã€‚æ•°ç»„ä¸­åŒ…å«çš„æ¯ä¸ªæ•°æ®è¢«ç§°ä¸ºæ•°ç»„å…ƒç´ ï¼ˆelementï¼‰ï¼Œä¸€ä¸ªæ•°ç»„åŒ…å«çš„å…ƒç´ ä¸ªæ•°è¢«ç§°ä¸ºæ•° ç»„çš„é•¿åº¦ã€‚ //å£°æ˜æ–¹å¼ [32]byte // é•¿åº¦ä¸º32çš„æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ ä¸ºä¸€ä¸ªå­—èŠ‚ [2*N] struct { x, y int32 } // å¤æ‚ç±»å‹æ•°ç»„ [1000]*float64 // æŒ‡é’ˆæ•°ç»„ [3][5]int // äºŒç»´æ•°ç»„ [2][2][2]float64 // ç­‰åŒäº[2]([2]([2]float64)) éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œåœ¨ Go è¯­è¨€ä¸­æ•°ç»„æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼ˆvalue typeï¼‰ã€‚æ‰€æœ‰çš„å€¼ç±»å‹å˜é‡åœ¨èµ‹å€¼å’Œä½œä¸ºå‚æ•°ä¼ é€’æ—¶éƒ½å°†äº§ç”Ÿä¸€æ¬¡å¤åˆ¶åŠ¨ä½œã€‚æ•°ç»„çš„é•¿åº¦åœ¨å®šä¹‰ä¹‹åæ— æ³•å†æ¬¡ä¿®æ”¹ã€‚ 3.8 æ•°ç»„åˆ‡ç‰‡ ä¸æ•°ç»„ç›¸æ¯”ï¼Œæ•°ç»„åˆ‡ç‰‡å¤šäº†ä¸€ä¸ªå­˜å‚¨èƒ½åŠ›ï¼ˆcapacityï¼‰çš„æ¦‚å¿µï¼Œå³å…ƒç´ ä¸ªæ•°å’Œåˆ†é…çš„ç©ºé—´å¯ä»¥æ˜¯ä¸¤ä¸ªä¸åŒçš„å€¼ã€‚åˆç†åœ°è®¾ç½®å­˜å‚¨èƒ½åŠ›çš„ å€¼ï¼Œå¯ä»¥å¤§å¹…é™ä½æ•°ç»„åˆ‡ç‰‡å†…éƒ¨é‡æ–°åˆ†é…å†…å­˜å’Œæ¬é€å†…å­˜å—çš„é¢‘ç‡ï¼Œä»è€Œå¤§å¤§æé«˜ç¨‹åºæ€§èƒ½ã€‚ æ•°ç»„åˆ‡ç‰‡çš„æ•°æ®ç»“æ„å¯ä»¥æŠ½è±¡ä¸ºä»¥ä¸‹ 3 ä¸ªå˜é‡ï¼š ä¸€ä¸ªæŒ‡å‘åŸç”Ÿæ•°ç»„çš„æŒ‡é’ˆ æ•°ç»„åˆ‡ç‰‡ä¸­çš„å…ƒç´ ä¸ªæ•° æ•°ç»„åˆ‡ç‰‡å·²åˆ†é…çš„å­˜å‚¨ç©ºé—´ æ•°ç»„åˆ‡ç‰‡æ·»åŠ äº†ä¸€ç³» åˆ—ç®¡ç†åŠŸèƒ½ï¼Œå¯ä»¥éšæ—¶åŠ¨æ€æ‰©å……å­˜æ”¾ç©ºé—´ï¼Œå¹¶ä¸”å¯ä»¥è¢«éšæ„ä¼ é€’è€Œä¸ä¼šå¯¼è‡´æ‰€ç®¡ç†çš„å…ƒç´ è¢«é‡å¤ å¤åˆ¶ã€‚ åˆ›å»ºæ–¹æ³•æœ‰ä¸¤ç§ï¼š åŸºäºæ•°ç»„ ç›´æ¥åˆ›å»º // å…ˆå®šä¹‰ä¸€ä¸ªæ•°ç»„ var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} // åŸºäºæ•°ç»„åˆ›å»ºä¸€ä¸ªæ•°ç»„åˆ‡ç‰‡ var mySlice []int = myArray[:5] fmt.Println(\"Elements of myArray: \") for _, v := range myArray { fmt.Print(v, \" \") } fmt.Println(\"\\nElements of mySlice: \") for _, v := range mySlice { fmt.Print(v, \" \") } //ç›´æ¥åˆ›å»º //åˆ›å»ºä¸€ä¸ªåˆå§‹å…ƒç´ ä¸ªæ•°ä¸º5çš„æ•°ç»„åˆ‡ç‰‡ï¼Œå…ƒç´ åˆå§‹å€¼ä¸º0ï¼š mySlice1 := make([]int, 5) //åˆ›å»ºä¸€ä¸ªåˆå§‹å…ƒç´ ä¸ªæ•°ä¸º5çš„æ•°ç»„åˆ‡ç‰‡ï¼Œå…ƒç´ åˆå§‹å€¼ä¸º0ï¼Œå¹¶é¢„ç•™10ä¸ªå…ƒç´ çš„å­˜å‚¨ç©ºé—´ï¼š mySlice2 := make([]int, 5, 10) //ç›´æ¥åˆ›å»ºå¹¶åˆå§‹åŒ–åŒ…å«5ä¸ªå…ƒç´ çš„æ•°ç»„åˆ‡ç‰‡ï¼š mySlice3 := []int{1, 2, 3, 4, 5} cap()å‡½æ•°,è¿”å›çš„æ˜¯æ•°ç»„åˆ‡ç‰‡åˆ†é…çš„ç©ºé—´å¤§å° len()å‡½æ•°,è¿”å›çš„æ˜¯æ•°ç»„åˆ‡ç‰‡ä¸­å½“å‰æ‰€å­˜å‚¨çš„å…ƒç´ ä¸ªæ•°ã€‚ append()å‡½æ•°,ç»§ç»­æ–°å¢å…ƒç´ ã€‚ æ³¨æ„ï¼šåœ¨ç¬¬äºŒä¸ªå‚æ•° mySlice2 åé¢åŠ äº†ä¸‰ä¸ªç‚¹ï¼Œå³ä¸€ä¸ªçœç•¥å·ï¼Œå¦‚æœæ²¡æœ‰è¿™ä¸ªçœ ç•¥å·çš„è¯ï¼Œä¼šæœ‰ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºæŒ‰ append()çš„è¯­ä¹‰ï¼Œä»ç¬¬äºŒä¸ªå‚æ•°èµ·çš„æ‰€æœ‰å‚æ•°éƒ½æ˜¯å¾…é™„åŠ çš„ å…ƒç´ ã€‚å› ä¸º mySlice ä¸­çš„å…ƒç´ ç±»å‹ä¸º intï¼Œæ‰€ä»¥ç›´æ¥ä¼ é€’ mySlice2 æ˜¯è¡Œä¸é€šçš„ã€‚åŠ ä¸Šçœç•¥å·ç›¸å½“äºæŠŠ mySlice2 åŒ…å«çš„æ‰€æœ‰å…ƒç´ æ‰“æ•£åä¼ å…¥ã€‚ mySlice2 := []int{8, 9, 10} myslice := make([]int, 5, 10) myslice = append(myslice, 8, 9, 10) // ç»™mySliceåé¢æ·»åŠ å¦ä¸€ä¸ªæ•°ç»„åˆ‡ç‰‡ mySlice = append(mySlice, mySlice2...) //ä¸Šå¥ç­‰ä»·äº mySlice = append(mySlice, 8, 9, 10) copy()å‡½æ•°,å°†å†…å®¹ä»ä¸€ä¸ªæ•°ç»„åˆ‡ç‰‡å¤åˆ¶åˆ°å¦ä¸€ä¸ªæ•°ç»„åˆ‡ç‰‡ã€‚å¦‚æœåŠ å…¥çš„ä¸¤ä¸ªæ•°ç»„åˆ‡ç‰‡ä¸ä¸€æ ·å¤§ï¼Œå°±ä¼šæŒ‰å…¶ä¸­è¾ƒå°çš„é‚£ä¸ªæ•°ç»„åˆ‡ç‰‡çš„å…ƒç´ ä¸ªæ•°è¿›è¡Œ å¤åˆ¶ã€‚ slice1 := []int{1, 2, 3, 4, 5} slice2 := []int{5, 4, 3} copy(slice2, slice1) // åªä¼šå¤åˆ¶slice1çš„å‰3ä¸ªå…ƒç´ åˆ°slice2ä¸­ copy(slice1, slice2) // åªä¼šå¤åˆ¶slice2çš„3ä¸ªå…ƒç´ åˆ°slice1çš„å‰3ä¸ªä½ç½® 3.9 map map æ˜¯ä¸€å †é”®å€¼å¯¹çš„æœªæ’åºé›†åˆã€‚ package main import \"fmt\" // PersonInfoæ˜¯ä¸€ä¸ªåŒ…å«ä¸ªäººè¯¦ç»†ä¿¡æ¯çš„ç±»å‹ type PersonInfo struct { ID string Name string Address string } func main() { var personDB map[string]PersonInfo personDB = make(map[string]PersonInfo) // å¾€è¿™ä¸ªmapé‡Œæ’å…¥å‡ æ¡æ•°æ® personDB[\"12345\"] = PersonInfo{\"12345\", \"Tom\", \"Room 203,...\"} personDB[\"1\"] = PersonInfo{\"1\", \"Jack\", \"Room 101,...\"} // ä»è¿™ä¸ªmapæŸ¥æ‰¾é”®ä¸º\"1234\"çš„ä¿¡æ¯ person, ok := personDB[\"1234\"] // okæ˜¯ä¸€ä¸ªè¿”å›çš„boolå‹ï¼Œè¿”å›trueè¡¨ç¤ºæ‰¾åˆ°äº†å¯¹åº”çš„æ•°æ® if ok { fmt.Println(\"Found person\", person.Name, \"with ID 1234.\") } else { fmt.Println(\"Did not find person with ID 1234.\") } } å˜é‡å£°æ˜ var myMap map[string] PersonInfo åˆ›å»º myMap = make(map[string] PersonInfo) myMap = make(map[string] PersonInfo, 100)//å­˜å‚¨èƒ½åŠ›ä¸º100 //åˆ›å»ºå¹¶åˆå§‹åŒ– myMap = map[string] PersonInfo{ \"1234\": PersonInfo{\"1\", \"Jack\", \"Room 101,...\"}, } å…ƒç´ èµ‹å€¼ myMap[\"1234\"] = PersonInfo{\"1\", \"Jack\", \"Room 101,...\"} å…ƒç´ åˆ é™¤ delete(myMap, \"1234\") å…ƒç´ æŸ¥æ‰¾ value, ok := myMap[\"1234\"] if ok { // æ‰¾åˆ°äº† // å¤„ç†æ‰¾åˆ°çš„value } ","date":"2023-04-06","objectID":"/golang-quick/:3:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4 æµç¨‹æ§åˆ¶ æµç¨‹æ§åˆ¶è¯­å¥çš„ä½œç”¨ï¼š é€‰æ‹© å¾ªç¯ è·³è½¬ go è¯­è¨€æ”¯æŒçš„æµç¨‹æ§åˆ¶è¯­å¥ æ¡ä»¶è¯­å¥ é€‰æ‹©è¯­å¥ å¾ªç¯è¯­å¥ è·³è½¬è¯­å¥ ä¸ºäº†æ»¡è¶³æ›´ä¸°å¯Œçš„æ§åˆ¶éœ€æ±‚ï¼ŒGo è¯­è¨€è¿˜æ·»åŠ äº†å¦‚ä¸‹å…³é”®å­—ï¼šbreakã€ continueå’Œfallthroughã€‚ 4.1 æ¡ä»¶è¯­å¥ if a \u003c 5 { return 0 } else { return 1 } æ¡ä»¶è¯­å¥ä¸éœ€è¦ä½¿ç”¨æ‹¬å·å°†æ¡ä»¶åŒ…å«èµ·æ¥() æ— è®ºè¯­å¥ä½“å†…æœ‰å‡ æ¡è¯­å¥ï¼ŒèŠ±æ‹¬å·{}éƒ½æ˜¯å¿…é¡»å­˜åœ¨çš„ å·¦èŠ±æ‹¬å·{å¿…é¡»ä¸ if æˆ–è€… else å¤„äºåŒä¸€è¡Œ åœ¨ if ä¹‹åï¼Œæ¡ä»¶è¯­å¥ä¹‹å‰ï¼Œå¯ä»¥æ·»åŠ å˜é‡åˆå§‹åŒ–è¯­å¥ï¼Œä½¿ç”¨ï¼›é—´éš”ï¼› åœ¨æœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­ï¼Œä¸å…è®¸å°†â€œæœ€ç»ˆçš„â€return è¯­å¥åŒ…å«åœ¨ ifâ€¦elseâ€¦ç»“æ„ä¸­ï¼Œ å¦åˆ™ä¼šç¼–è¯‘å¤±è´¥ 4.2 é€‰æ‹©è¯­å¥ switch i { case 0: fmt.Printf(\"0\") case 1: fmt.Printf(\"1\") case 2: fallthrough case 3: fmt.Printf(\"3\") case 4, 5, 6: fmt.Printf(\"4, 5, 6\") default: fmt.Printf(\"Default\") } switch { case 0 \u003c= Num \u0026\u0026 Num \u003c= 3: fmt.Printf(\"0-3\") case 4 \u003c= Num \u0026\u0026 Num \u003c= 6: fmt.Printf(\"4-6\") case 7 \u003c= Num \u0026\u0026 Num \u003c= 9: fmt.Printf(\"7-9\") } å·¦èŠ±æ‹¬å·{å¿…é¡»ä¸ switch å¤„äºåŒä¸€è¡Œï¼› æ¡ä»¶è¡¨è¾¾å¼ä¸é™åˆ¶ä¸ºå¸¸é‡æˆ–è€…æ•´æ•°ï¼› å•ä¸ª case ä¸­ï¼Œå¯ä»¥å‡ºç°å¤šä¸ªç»“æœé€‰é¡¹ï¼› ä¸ C è¯­è¨€ç­‰è§„åˆ™ç›¸å**ï¼ŒGo è¯­è¨€ä¸éœ€è¦ç”¨ break æ¥æ˜ç¡®é€€å‡ºä¸€ä¸ª caseï¼›** åªæœ‰åœ¨ case ä¸­æ˜ç¡®æ·»åŠ  fallthrough å…³é”®å­—ï¼Œæ‰ä¼šç»§ç»­æ‰§è¡Œç´§è·Ÿçš„ä¸‹ä¸€ä¸ª caseï¼› å¯ä»¥ä¸è®¾å®š switch ä¹‹åçš„æ¡ä»¶è¡¨è¾¾å¼ï¼Œåœ¨æ­¤ç§æƒ…å†µä¸‹ï¼Œæ•´ä¸ª switch ç»“æ„ä¸å¤šä¸ª ifâ€¦elseâ€¦çš„é€»è¾‘ä½œç”¨ç­‰åŒã€‚ 4.3 å¾ªç¯è¯­å¥ Go è¯­è¨€ä¸­çš„å¾ªç¯è¯­å¥åªæ”¯æŒ for å…³é”®å­—ã€‚ a := []int{1, 2, 3, 4, 5, 6} for i, j := 0, len(a) â€“ 1; i \u003c j; i, j = i + 1, j â€“ 1 { a[i], a[j] = a[j], a[i] } å·¦èŠ±æ‹¬å·{å¿…é¡»ä¸ for å¤„äºåŒä¸€è¡Œã€‚ Go è¯­è¨€ä¸­çš„ for å¾ªç¯ä¸ C è¯­è¨€ä¸€æ ·ï¼Œéƒ½å…è®¸åœ¨å¾ªç¯æ¡ä»¶ä¸­å®šä¹‰å’Œåˆå§‹åŒ–å˜é‡ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼ŒGo è¯­è¨€ä¸æ”¯æŒä»¥é€—å·ä¸ºé—´éš”çš„å¤šä¸ªèµ‹å€¼è¯­å¥ï¼Œå¿…é¡»ä½¿ç”¨å¹³è¡Œèµ‹å€¼çš„æ–¹å¼æ¥åˆå§‹åŒ–å¤šä¸ªå˜é‡ã€‚ Go è¯­è¨€çš„ for å¾ªç¯åŒæ ·æ”¯æŒ continue å’Œ break æ¥æ§åˆ¶å¾ªç¯ï¼Œä½†æ˜¯å®ƒæä¾›äº†ä¸€ä¸ªæ›´é«˜çº§çš„ breakï¼Œå¯ä»¥é€‰æ‹©ä¸­æ–­å“ªä¸€ä¸ªå¾ªç¯ï¼Œå¦‚ä¸‹ä¾‹( æœ¬ä¾‹ä¸­ï¼Œbreak è¯­å¥ç»ˆæ­¢çš„æ˜¯ JLoop æ ‡ç­¾å¤„çš„å¤–å±‚å¾ªç¯ã€‚)ï¼š for j := 0; j \u003c 5; j++ { for i := 0; i \u003c 10; i++ { if i \u003e 5 { break JLoop } fmt.Println(i) } } JLoop: // ... 4.4 è·³è½¬è¯­å¥ goto è¯­å¥çš„è¯­ä¹‰éå¸¸ç®€å•ï¼Œå°±æ˜¯è·³è½¬åˆ°æœ¬å‡½æ•°å†…çš„æŸä¸ªæ ‡ç­¾ï¼Œå¦‚ï¼š func myfunc() { i := 0 HERE: fmt.Println(i) i++ if i \u003c 10 { goto HERE } } ","date":"2023-04-06","objectID":"/golang-quick/:3:4","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"5 å‡½æ•° 5.1 ä¸å®šå‚æ•° æŒ‡å®šç±»å‹çš„ä¸å®šå‚æ•° func myfunc(args ...int) { for _, arg := range args { fmt.Println(arg) } } **å½¢å¦‚...typeæ ¼å¼çš„ç±»å‹åªèƒ½ä½œä¸ºå‡½æ•°çš„å‚æ•°ç±»å‹å­˜åœ¨ï¼Œå¹¶ä¸”å¿…é¡»æ˜¯æœ€åä¸€ä¸ªå‚æ•°ã€‚å®ƒæ˜¯ä¸€ ä¸ªè¯­æ³•ç³–ï¼ˆsyntactic sugarï¼‰ã€‚å…¶æœ¬è´¨æ˜¯æ•°ç»„åˆ‡ç‰‡ã€‚** ä¸å®šç±»å‹çš„ä¸å®šå‚æ•° å¦‚æœä½ å¸Œæœ›ä¼ ä»»æ„ç±»å‹ï¼Œå¯ä»¥æŒ‡å®šç±»å‹ä¸º interface{}ã€‚ç”¨ interface{}ä¼ é€’ä»»æ„ç±»å‹æ•°æ®æ˜¯ Go è¯­è¨€çš„æƒ¯ä¾‹ç”¨æ³•ã€‚ func Printf(format string, args ...interface{}) { // ... } func MyPrintf(args ...interface{}) { for _, arg := range args { switch arg.(type) { case int: fmt.Println(arg, \"is an int value.\") case string: fmt.Println(arg, \"is a string value.\") case int64: fmt.Println(arg, \"is an int64 value.\") default: fmt.Println(arg, \"is an unknown type.\") } } } 5.2 åŒ¿åå‡½æ•°ä¸é—­åŒ… åŒ¿åå‡½æ•°æ˜¯æŒ‡ä¸éœ€è¦å®šä¹‰å‡½æ•°åçš„ä¸€ç§å‡½æ•°å®ç°æ–¹å¼ã€‚Go è¯­è¨€æ”¯æŒéšæ—¶åœ¨ä»£ç é‡Œå®šä¹‰åŒ¿åå‡½æ•°ã€‚åŒ¿åå‡½æ•°å¯ä»¥ç›´æ¥èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡æˆ–è€…ç›´æ¥æ‰§è¡Œã€‚ f := func(x, y int) int { return x + y } func(ch chan int) { ch \u003c- ACK } (reply_chan) // èŠ±æ‹¬å·åç›´æ¥è·Ÿå‚æ•°åˆ—è¡¨è¡¨ç¤ºå‡½æ•°è°ƒç”¨ Go çš„åŒ¿åå‡½æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚ åŸºæœ¬æ¦‚å¿µ é—­åŒ…æ˜¯å¯ä»¥åŒ…å«è‡ªç”±ï¼ˆæœªç»‘å®šåˆ°ç‰¹å®šå¯¹è±¡ï¼‰å˜é‡çš„ä»£ç å—ï¼Œè¿™äº›å˜é‡ä¸åœ¨è¿™ä¸ªä»£ç å—å†…æˆ–è€…ä»»ä½•å…¨å±€ä¸Šä¸‹æ–‡ä¸­å®šä¹‰ï¼Œè€Œæ˜¯åœ¨å®šä¹‰ä»£ç å—çš„ç¯å¢ƒä¸­å®šä¹‰ã€‚ é—­åŒ…çš„ä»·å€¼ é—­åŒ…çš„ä»·å€¼åœ¨äºå¯ä»¥ä½œä¸ºå‡½æ•°å¯¹è±¡æˆ–è€…åŒ¿åå‡½æ•°ï¼Œå¯¹äºç±»å‹ç³»ç»Ÿè€Œè¨€ï¼Œè¿™æ„å‘³ç€ä¸ä»…è¦è¡¨ç¤º æ•°æ®è¿˜è¦è¡¨ç¤ºä»£ç ã€‚ Go ä¸­çš„é—­åŒ… é—­åŒ…çš„å®ç°ç¡®ä¿åªè¦é—­åŒ…è¿˜è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆ è¢«é—­åŒ…å¼•ç”¨çš„å˜é‡ä¼šä¸€ç›´å­˜åœ¨ã€‚ package main import ( \"fmt\" ) func main() { var j int = 5 a := func() func() { var i int = 10 return func() { fmt.Printf(\"i, j: %d, %d\\n\", i, j) } }() a() j *= 2 a() } /* ç»“æœï¼š i, j: 10, 5 i, j: 10, 10 */ ","date":"2023-04-06","objectID":"/golang-quick/:3:5","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"6 é”™è¯¯å¤„ç† 6.1 error æ¥å£ Go è¯­è¨€å¼•å…¥äº†ä¸€ä¸ªå…³äºé”™è¯¯å¤„ç†çš„æ ‡å‡†æ¨¡å¼ï¼Œå³ error æ¥å£ã€‚ type error interface { Error() string } å¤„ç†é”™è¯¯çš„æ–¹å¼ï¼š if err != nil { // é”™è¯¯å¤„ç† } else { // ä½¿ç”¨è¿”å›å€¼n } å¦‚ä½•ä½¿ç”¨è‡ªå®šä¹‰çš„ error ç±»å‹? å®šä¹‰ä¸€ä¸ªç”¨äºæ‰¿è½½é”™è¯¯ä¿¡æ¯çš„ç±»å‹ã€‚Go è¯­è¨€ä¸­æ¥å£çš„çµæ´»æ€§ï¼Œä½ æ ¹æœ¬ä¸éœ€è¦ä» error æ¥å£ç»§æ‰¿ã€‚ type PathError struct { Op string Path string Err error } å®ç° Error()æ–¹æ³• func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() } 6.2 defer å‡½æ•°åœ¨é€€å‡ºå‰æ‰§è¡Œ defer æŒ‡å®šçš„æ“ä½œã€‚ä¸€ä¸ªå‡½æ•°ä¸­å¯ä»¥å­˜åœ¨å¤šä¸ª defer è¯­å¥ï¼Œå› æ­¤éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œdefer è¯­å¥çš„è°ƒç”¨æ˜¯éµç…§ å…ˆè¿›åå‡ºçš„åŸåˆ™ï¼Œå³æœ€åä¸€ä¸ª defer è¯­å¥å°†æœ€å…ˆè¢«æ‰§è¡Œã€‚ *6.3 panic ã€recover Go è¯­è¨€å¼•å…¥äº†ä¸¤ä¸ªå†…ç½®å‡½æ•°panic()å’Œrecover()ä»¥æŠ¥å‘Šå’Œå¤„ç†è¿è¡Œæ—¶é”™è¯¯å’Œç¨‹åºä¸­çš„é”™è¯¯åœºæ™¯ã€‚ panicå’Œrecoverç›¸å½“äº python ä¸­çš„try exceptã€‚ å½“åœ¨ä¸€ä¸ªå‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­è°ƒç”¨ panic()å‡½æ•°æ—¶ï¼Œæ­£å¸¸çš„å‡½æ•°æ‰§è¡Œæµç¨‹å°†ç«‹å³ç»ˆæ­¢ï¼Œä½†å‡½æ•°ä¸­ ä¹‹å‰ä½¿ç”¨ defer å…³é”®å­—å»¶è¿Ÿæ‰§è¡Œçš„è¯­å¥å°†æ­£å¸¸å±•å¼€æ‰§è¡Œï¼Œä¹‹åè¯¥å‡½æ•°å°†è¿”å›åˆ°è°ƒç”¨å‡½æ•°ï¼Œå¹¶å¯¼è‡´ é€å±‚å‘ä¸Šæ‰§è¡Œ panic æµç¨‹ï¼Œç›´è‡³æ‰€å±çš„ goroutine ä¸­æ‰€æœ‰æ­£åœ¨æ‰§è¡Œçš„å‡½æ•°è¢«ç»ˆæ­¢ã€‚é”™è¯¯ä¿¡æ¯å°†è¢«æŠ¥å‘Šï¼ŒåŒ…æ‹¬åœ¨è°ƒç”¨ panic()å‡½æ•°æ—¶ä¼ å…¥çš„å‚æ•°ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºé”™è¯¯å¤„ç†æµç¨‹ã€‚ recover()å‡½æ•°ç”¨äºç»ˆæ­¢é”™è¯¯å¤„ç†æµç¨‹ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œrecover()åº”è¯¥åœ¨ä¸€ä¸ªä½¿ç”¨ defer å…³é”®å­—çš„å‡½æ•°ä¸­æ‰§è¡Œä»¥æœ‰æ•ˆæˆªå–é”™è¯¯å¤„ç†æµç¨‹ã€‚å¦‚æœæ²¡æœ‰åœ¨å‘ç”Ÿå¼‚å¸¸çš„ goroutine ä¸­æ˜ç¡®è°ƒç”¨æ¢å¤è¿‡ç¨‹ï¼ˆä½¿ç”¨ recover å…³é”®å­—ï¼‰ï¼Œä¼šå¯¼è‡´è¯¥ goroutine æ‰€å±çš„è¿›ç¨‹æ‰“å°å¼‚å¸¸ä¿¡æ¯åç›´æ¥é€€å‡ºã€‚ package main import ( \"fmt\" ) func divide() { defer func() { if err := recover(); err != nil { fmt.Printf(\"Runtime panic caught: %v\\n\", err) } }() var i = 1 var j = 0 k := i / j fmt.Printf(\"%d / %d = %d\\n\", i, j, k) } func main() { divide() fmt.Println(\"divideæ–¹æ³•è°ƒç”¨å®Œæ¯•ï¼Œå›åˆ°mainå‡½æ•°\") } ","date":"2023-04-06","objectID":"/golang-quick/:3:6","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"é¢å‘å¯¹è±¡ Go è¯­è¨€å¯¹é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ”¯æŒæ˜¯è¯­è¨€ç±»å‹ç³»ç»Ÿä¸­çš„å¤©ç„¶ç»„æˆéƒ¨åˆ† ","date":"2023-04-06","objectID":"/golang-quick/:4:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 ç±»å‹ç³»ç»Ÿ ç±»å‹ç³»ç»Ÿæ˜¯æŒ‡ä¸€ä¸ªè¯­è¨€çš„ç±»å‹ä½“ç³»ç»“æ„ 1.1 ä¸ºç±»å‹æ·»åŠ æ–¹æ³• type Integer int func (a Integer) Less(b Integer) bool { return a \u003c b } å…³äºç»™ç±»å‹æ·»åŠ æ–¹æ³•çš„æ—¶å€™ï¼Œç±»å‹çš„å‚æ•°æ˜¯ä¼ å…¥æŒ‡é’ˆï¼Ÿè¿˜æ˜¯å€¼ä¼ é€’ï¼Ÿå¦‚ä¸‹ï¼š func (a *Integer) Add(b Integer) { *a += b } func (a Integer) Add(b Integer) { a += b } è¿™å–å†³äºï¼Œä½ æ˜¯å¦éœ€è¦éœ€è¦ä¿®æ”¹å¯¹è±¡ï¼è‹¥éœ€è¦ä¿®æ”¹å¯¹è±¡ï¼Œåˆ™éœ€è¦ä¼ å…¥æŒ‡é’ˆã€‚ç±»å‹éƒ½æ˜¯åŸºäºå€¼ä¼ é€’çš„ã€‚è¦æƒ³ä¿®æ”¹å˜é‡çš„å€¼ï¼Œåªèƒ½ ä¼ é€’æŒ‡é’ˆ 1.2 ç»“æ„ä½“ type Rect struct { x, y float64 width, height float64 } func (r *Rect) Area() float64 { return r.width * r.height } ","date":"2023-04-06","objectID":"/golang-quick/:4:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 åˆå§‹åŒ– rect1 := new(Rect) rect2 := \u0026Rect{} rect3 := \u0026Rect{0, 0, 100, 200} rect4 := \u0026Rect{width: 100, height: 200} æœªè¿›è¡Œæ˜¾å¼åˆå§‹åŒ–çš„å˜é‡éƒ½ä¼šè¢«åˆå§‹åŒ–ä¸ºè¯¥ç±»å‹çš„é›¶å€¼ã€‚ä¾‹å¦‚ bool ç±»å‹çš„é›¶ å€¼ä¸º falseï¼Œint ç±»å‹çš„é›¶å€¼ä¸º 0ï¼Œstring ç±»å‹çš„é›¶å€¼ä¸ºç©ºå­—ç¬¦ä¸²ã€‚ åœ¨ Go è¯­è¨€ä¸­æ²¡æœ‰æ„é€ å‡½æ•°çš„æ¦‚å¿µï¼Œå¯¹è±¡çš„åˆ›å»ºé€šå¸¸äº¤ç”±ä¸€ä¸ªå…¨å±€çš„åˆ›å»ºå‡½æ•°æ¥å®Œæˆï¼Œä»¥ NewXXX æ¥å‘½åï¼Œè¡¨ç¤ºâ€œæ„é€ å‡½æ•°â€ï¼š func NewRect(x, y, width, height float64) *Rect { return \u0026Rect{x, y, width, height} } ","date":"2023-04-06","objectID":"/golang-quick/:4:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 åŒ¿åç»„åˆ Go è¯­è¨€ä¹Ÿæä¾›äº†ç»§æ‰¿ï¼Œä½†æ˜¯é‡‡ç”¨äº†ç»„åˆçš„æ–‡æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å…¶ç§°ä¸ºåŒ¿åç»„åˆã€‚ type Base struct { Name string } func (base *Base) Foo() { ... } func (base *Base) Bar() { ... } type Foo struct { Base ... } func (foo *Foo) Bar() { foo.Base.Bar() ... } ","date":"2023-04-06","objectID":"/golang-quick/:4:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4 æ¥å£ Go è¯­è¨€åœ¨ç¼–ç¨‹å“²å­¦ä¸Šæ˜¯å˜é©æ´¾,æ˜¯å› ä¸º Go è¯­è¨€çš„ç±»å‹ç³»ç»Ÿï¼Œæ›´æ˜¯å› ä¸º Go è¯­è¨€çš„æ¥å£ â€œä¾µå…¥å¼â€çš„ä¸»è¦è¡¨ç°åœ¨äºå®ç°ç±»éœ€è¦æ˜ç¡®å£°æ˜è‡ªå·±å®ç°äº†æŸä¸ªæ¥å£ã€‚â€œéä¾µå…¥å¼â€åªéœ€è¦å®ç°æ¥å£çš„æ–¹æ³•ï¼Œä¸éœ€è¦å£°æ˜ã€‚ type File struct { // ... } func (f *File) Read(buf []byte) (n int, err error) func (f *File) Write(buf []byte) (n int, err error) func (f *File) Seek(off int64, whence int) (pos int64, err error) func (f *File) Close() error type IFile interface { Read(buf []byte) (n int, err error) Write(buf []byte) (n int, err error) Seek(off int64, whence int) (pos int64, err error) Close() error } type IReader interface { Read(buf []byte) (n int, err error) } type IWriter interface { Write(buf []byte) (n int, err error) } type ICloser interface { Close() error } var file1 IFile = new(File) var file2 IReader = new(File) var file3 IWriter = new(File) var file4 ICloser = new(File) å°½ç®¡ File ç±»å¹¶æ²¡æœ‰ä»è¿™äº›æ¥å£ç»§æ‰¿ï¼Œç”šè‡³å¯ä»¥ä¸çŸ¥é“è¿™äº›æ¥å£çš„å­˜åœ¨ï¼Œä½†æ˜¯ File ç±»å®ç°äº† è¿™äº›æ¥å£ï¼Œå¯ä»¥è¿›è¡Œèµ‹å€¼ã€‚ éä¾µå…¥å¼æ¥å£çš„å¥½å¤„ï¼š Go è¯­è¨€çš„æ ‡å‡†åº“ï¼Œå†ä¹Ÿä¸éœ€è¦ç»˜åˆ¶ç±»åº“çš„ç»§æ‰¿æ ‘å›¾ã€‚ å®ç°ç±»çš„æ—¶å€™ï¼Œåªéœ€è¦å…³å¿ƒè‡ªå·±åº”è¯¥æä¾›å“ªäº›æ–¹æ³•ï¼Œä¸ç”¨å†çº ç»“æ¥å£éœ€è¦æ‹†å¾—å¤šç»†æ‰åˆç†ã€‚ ä¸ç”¨ä¸ºäº†å®ç°ä¸€ä¸ªæ¥å£è€Œå¯¼å…¥ä¸€ä¸ªåŒ…ï¼Œå› ä¸ºå¤šå¼•ç”¨ä¸€ä¸ªå¤–éƒ¨çš„åŒ…ï¼Œå°±æ„å‘³ç€æ›´å¤šçš„è€¦åˆã€‚ åœ¨ Go è¯­è¨€ä¸­ï¼Œåªè¦ä¸¤ä¸ªæ¥å£æ‹¥ æœ‰ç›¸åŒçš„æ–¹æ³•åˆ—è¡¨ï¼ˆæ¬¡åºä¸åŒä¸è¦ç´§ï¼‰ï¼Œé‚£ä¹ˆå®ƒä»¬å°±æ˜¯ç­‰åŒçš„ï¼Œå¯ä»¥ç›¸äº’èµ‹å€¼ã€‚ 4.1 æ¥å£æŸ¥è¯¢ var file1 Writer = ... if file5, ok := file1.(two.IStream); ok { ... } è¿™ä¸ª if è¯­å¥æ£€æŸ¥ file1 æ¥å£æŒ‡å‘çš„å¯¹è±¡å®ä¾‹æ˜¯å¦å®ç°äº† two.IStream æ¥å£ï¼Œå¦‚æœå®ç°äº†ï¼Œåˆ™æ‰§ è¡Œç‰¹å®šçš„ä»£ç ã€‚ 4.2 ç±»å‹æŸ¥è¯¢ var v1 interface{} = ... switch v := v1.(type) { case int: // ç°åœ¨vçš„ç±»å‹æ˜¯int case string: // ç°åœ¨vçš„ç±»å‹æ˜¯string ... } ","date":"2023-04-06","objectID":"/golang-quick/:4:4","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"5 Any ç±»å‹ ç”±äº Go è¯­è¨€ä¸­ä»»ä½•å¯¹è±¡å®ä¾‹éƒ½æ»¡è¶³ç©ºæ¥å£ interface{}ï¼Œæ‰€ä»¥ interface{}çœ‹èµ·æ¥åƒæ˜¯å¯ä»¥æŒ‡å‘ä»»ä½•å¯¹è±¡çš„ Any ç±»å‹ã€‚ var v1 interface{} = 1 // å°†intç±»å‹èµ‹å€¼ç»™interface{} var v2 interface{} = \"abc\" // å°†stringç±»å‹èµ‹å€¼ç»™interface{} var v3 interface{} = \u0026v2 // å°†*interface{}ç±»å‹èµ‹å€¼ç»™interface{} var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026struct{ X int }{1} ","date":"2023-04-06","objectID":"/golang-quick/:4:5","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"å¹¶å‘å¤„ç† ","date":"2023-04-06","objectID":"/golang-quick/:5:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 å¹¶å‘åŸºç¡€ ç›®å‰å‡ ç§ä¸»æµçš„å®ç°æ¨¡å¼ï¼š å¤šè¿›ç¨‹ å¤šè¿›ç¨‹æ˜¯åœ¨æ“ä½œç³»ç»Ÿå±‚é¢è¿›è¡Œå¹¶å‘çš„åŸºæœ¬æ¨¡å¼ã€‚åŒæ—¶ä¹Ÿæ˜¯å¼€é”€æœ€å¤§çš„æ¨¡å¼ã€‚ å¤šçº¿ç¨‹ å¤šçº¿ç¨‹åœ¨å¤§éƒ¨åˆ†æ“ä½œç³»ç»Ÿä¸Šéƒ½å±äºç³»ç»Ÿå±‚é¢çš„å¹¶å‘æ¨¡å¼ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬ä½¿ç”¨æœ€å¤šçš„ æœ€æœ‰æ•ˆçš„ä¸€ç§æ¨¡å¼ã€‚å®ƒæ¯”å¤šè¿›ç¨‹çš„å¼€é”€å°å¾ˆå¤šï¼Œä½†æ˜¯å…¶å¼€é”€ä¾æ—§æ¯”è¾ƒå¤§ï¼Œä¸”åœ¨é«˜å¹¶å‘æ¨¡å¼ä¸‹ï¼Œæ•ˆç‡ä¼šæœ‰å½±å“ã€‚ åŸºäºå›è°ƒçš„éé˜»å¡/å¼‚æ­¥ IO ä½¿ç”¨å¤šçº¿ç¨‹æ¨¡å¼ä¼šå¾ˆå¿«è€—å°½æœåŠ¡å™¨çš„å†…å­˜å’Œ CPU èµ„æºã€‚è€Œè¿™ ç§æ¨¡å¼é€šè¿‡äº‹ä»¶é©±åŠ¨çš„æ–¹å¼ä½¿ç”¨å¼‚æ­¥ IOï¼Œä½¿æœåŠ¡å™¨æŒç»­è¿è½¬ï¼Œä¸”å°½å¯èƒ½åœ°å°‘ç”¨çº¿ç¨‹ï¼Œé™ ä½å¼€é”€ï¼Œå®ƒç›®å‰åœ¨ Node.js ä¸­å¾—åˆ°äº†å¾ˆå¥½çš„å®è·µã€‚ åç¨‹ åç¨‹ï¼ˆCoroutineï¼‰æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ç”¨æˆ·æ€çº¿ç¨‹ï¼Œä¸éœ€è¦æ“ä½œç³»ç»Ÿæ¥è¿›è¡ŒæŠ¢å å¼è°ƒåº¦ï¼Œ ä¸”åœ¨çœŸæ­£å®ç°å¯„å­˜äºçº¿ç¨‹ä¸­ï¼Œå› æ­¤ï¼Œç³»ç»Ÿå¼€é”€æå°ï¼Œå¯ä»¥æœ‰æ•ˆæé«˜çº¿ç¨‹çš„ä»»åŠ¡å¹¶å‘æ€§ï¼Œè€Œé¿å…å¤šçº¿ç¨‹çš„ç¼ºç‚¹ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 åç¨‹ Go è¯­è¨€åœ¨è¯­è¨€çº§åˆ«æ”¯æŒè½»é‡çº§çº¿ç¨‹ï¼Œå« goroutineã€‚Go è¯­è¨€æ ‡å‡†åº“æä¾›çš„æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨æ“ä½œï¼ˆå½“ç„¶ä¹ŸåŒ…æ‹¬æ‰€æœ‰åŒæ­¥ IO æ“ä½œï¼‰ï¼Œéƒ½ä¼šå‡ºè®© CPU ç»™å…¶ä»– goroutineã€‚è½»é‡çº§çº¿ç¨‹çš„åˆ‡æ¢ç®¡ç†ä¸ä¾èµ–äºç³»ç»Ÿçš„çº¿ç¨‹å’Œè¿›ç¨‹ï¼Œä¹Ÿä¸ä¾èµ–äº CPU çš„æ ¸å¿ƒæ•°é‡ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 goroutine goroutine æ˜¯ Go è¯­è¨€ä¸­çš„è½»é‡çº§çº¿ç¨‹å®ç°ï¼Œç”± Go è¿è¡Œæ—¶ï¼ˆruntimeï¼‰ç®¡ç†ã€‚ func Add(x, y int) { z := x + y fmt.Println(z) } go Add(1,1) éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœè¿™ä¸ªå‡½æ•°æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿™ä¸ª è¿”å›å€¼ä¼šè¢«ä¸¢å¼ƒã€‚ package main import \"fmt\" func Add(x, y int) { z := x + y fmt.Println(z) } func main() { for i := 0; i \u003c 10; i++ { go Add(i, i) } } Go ç¨‹åºä»åˆå§‹åŒ– main package å¹¶æ‰§è¡Œ main()å‡½æ•°å¼€å§‹ï¼Œå½“ main()å‡½æ•°è¿”å›æ—¶ï¼Œç¨‹åºé€€å‡ºï¼Œ ä¸”ç¨‹åºå¹¶ä¸ç­‰å¾…å…¶ä»– goroutineï¼ˆéä¸» goroutineï¼‰ç»“æŸã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4 å¹¶å‘é€šä¿¡ å¹¶å‘ç¼–ç¨‹çš„éš¾åº¦åœ¨äºåè°ƒï¼Œè€Œåè°ƒå°±è¦é€šè¿‡äº¤æµã€‚åœ¨å·¥ç¨‹ä¸Šï¼Œæœ‰ä¸¤ç§æœ€å¸¸è§çš„å¹¶å‘é€šä¿¡æ¨¡å‹ï¼šå…±äº«æ•°æ®å’Œæ¶ˆæ¯ã€‚ å…±äº«æ•°æ® æŒ‡å¤šä¸ªå¹¶å‘å•å…ƒåˆ†åˆ«ä¿æŒå¯¹åŒä¸€ä¸ªæ•°æ®çš„å¼•ç”¨ï¼Œå®ç°å¯¹è¯¥æ•°æ®çš„å…±äº«ã€‚è¢«å…±äº«çš„ æ•°æ®å¯èƒ½æœ‰å¤šç§å½¢å¼ï¼Œæ¯”å¦‚å†…å­˜æ•°æ®å—ã€ç£ç›˜æ–‡ä»¶ã€ç½‘ç»œæ•°æ®ç­‰ã€‚åœ¨å®é™…å·¥ç¨‹åº”ç”¨ä¸­æœ€å¸¸è§çš„æ—  ç–‘æ˜¯å†…å­˜äº†ï¼Œä¹Ÿå°±æ˜¯å¸¸è¯´çš„å…±äº«å†…å­˜ã€‚ æ¶ˆæ¯æœºåˆ¶ Go è¯­è¨€æä¾›çš„æ˜¯å¦ä¸€ç§é€šä¿¡æ¨¡å‹ï¼Œå³ä»¥æ¶ˆæ¯æœºåˆ¶è€Œéå…±äº«å†…å­˜ä½œä¸ºé€šä¿¡æ–¹å¼ã€‚æ¶ˆæ¯æœºåˆ¶è®¤ä¸ºæ¯ä¸ªå¹¶å‘å•å…ƒæ˜¯è‡ªåŒ…å«çš„ã€ç‹¬ç«‹çš„ä¸ªä½“ï¼Œå¹¶ä¸”éƒ½æœ‰è‡ªå·±çš„å˜é‡ï¼Œä½†åœ¨ä¸åŒå¹¶å‘ å•å…ƒé—´è¿™äº›å˜é‡ä¸å…±äº«ã€‚æ¯ä¸ªå¹¶å‘å•å…ƒçš„è¾“å…¥å’Œè¾“å‡ºåªæœ‰ä¸€ç§ï¼Œé‚£å°±æ˜¯æ¶ˆæ¯ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:4","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"5 channel channel æ˜¯è¿›ç¨‹å†…çš„é€šä¿¡æ–¹å¼ï¼Œå¦‚æœéœ€è¦è·¨è¿›ç¨‹é€šä¿¡ï¼Œæˆ‘ä»¬å»ºè®®ç”¨ åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ–¹æ³•æ¥è§£å†³ï¼Œæ¯”å¦‚ä½¿ç”¨ Socket æˆ–è€… HTTP ç­‰é€šä¿¡åè®®ã€‚ä¸€ä¸ª channel åªèƒ½ä¼ é€’ä¸€ç§ç±»å‹çš„å€¼ï¼Œè¿™ä¸ªç±»å‹éœ€è¦åœ¨å£°æ˜ channel æ—¶æŒ‡å®šã€‚ package main import \"fmt\" func Count(ch chan int) { ch \u003c- 1 fmt.Println(\"Counting\") } func main() { chs := make([]chan int, 10) for i := 0; i \u003c 10; i++ { chs[i] = make(chan int) go Count(chs[i]) } for _, ch := range chs { \u003c-ch } } åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªåŒ…å« 10 ä¸ª channel çš„æ•°ç»„ï¼ˆåä¸º chsï¼‰ï¼Œå¹¶æŠŠæ•°ç»„ä¸­çš„æ¯ä¸ª channel åˆ†é…ç»™ 10 ä¸ªä¸åŒçš„ goroutineã€‚åœ¨æ¯ä¸ª goroutine çš„ Add()å‡½æ•°å®Œæˆåï¼Œæˆ‘ä»¬é€šè¿‡ ch \u003c- 1 è¯­ å¥å‘å¯¹åº”çš„ channel ä¸­å†™å…¥ä¸€ä¸ªæ•°æ®ã€‚åœ¨è¿™ä¸ª channel è¢«è¯»å–å‰ï¼Œè¿™ä¸ªæ“ä½œæ˜¯é˜»å¡çš„ã€‚åœ¨æ‰€æœ‰çš„ goroutine å¯åŠ¨å®Œæˆåï¼Œæˆ‘ä»¬é€šè¿‡\u003c-ch è¯­å¥ä» 10 ä¸ª channel ä¸­ä¾æ¬¡è¯»å–æ•°æ®ã€‚åœ¨å¯¹åº”çš„ channel å†™å…¥ æ•°æ®å‰ï¼Œè¿™ä¸ªæ“ä½œä¹Ÿæ˜¯é˜»å¡çš„ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±ç”¨ channel å®ç°äº†ç±»ä¼¼é”çš„åŠŸèƒ½ï¼Œè¿›è€Œä¿è¯äº†æ‰€æœ‰ goroutine å®Œæˆåä¸»å‡½æ•°æ‰è¿”å›ã€‚ 5.1 åŸºæœ¬è¯­æ³• var ch chan int var m map[string] chan bool //å£°æ˜ä¸€ä¸ªmapï¼Œkeyæ˜¯stringï¼Œvalueæ˜¯channel ch := make(chan int) //å†™å…¥æ•°æ® ch \u003c- value //è¯»å‡ºæ•°æ® value := \u003c-ch å‘ channel å†™å…¥æ•°æ®é€šå¸¸ä¼šå¯¼è‡´ç¨‹åºé˜»å¡ï¼Œç›´åˆ°æœ‰å…¶ä»– goroutine ä»è¿™ä¸ª channel ä¸­è¯»å–æ•°æ®ã€‚å¦‚æœ channel ä¹‹å‰æ²¡æœ‰å†™å…¥æ•°æ®ï¼Œé‚£ä¹ˆä» channel ä¸­è¯»å–æ•°æ®ä¹Ÿä¼šå¯¼è‡´ç¨‹åºé˜»å¡ï¼Œç›´åˆ° channel ä¸­è¢«å†™å…¥æ•°æ®ä¸ºæ­¢ã€‚ ç»å…¸é”™è¯¯ï¼š package main import \"fmt\" func main(){ var msg chan int msg = make(chan int) msg\u003c- 1 data := \u003c- msg fmt.Println(data) } // æ‰§è¡Œæƒ…å†µï¼šfatal error: all goroutines are asleep - deadlock! è¯¥é”™è¯¯å¾ˆç»å…¸ï¼å› ä¸ºç”³è¯·çš„æ˜¯ä¸€ä¸ªæ— ç¼“å†²çš„é€šé“ï¼è¯¥é€šé“å†™å…¥æ•°æ®åä¼šå¯¼è‡´æ‰€åœ¨çº¿ç¨‹é˜»å¡ï¼Œç›´åˆ°å…¶ä»–çº¿ç¨‹å¯¹è¯¥é€šé“è¯»æ“ä½œåï¼Œé‚£ä¸ªè¢«é˜»å¡çš„çº¿ç¨‹æ‰ä¼šè¢«ç»§ç»­æ‰§è¡Œã€‚æ‰€ä»¥ä¸Šè¿°ä»£ç ï¼Œç¬¬ 9 è¡ŒåŠå…¶ä¹‹åçš„ä»£ç å°†ä¸ä¼šè¢«æ‰§è¡Œã€‚ package main import \"fmt\" func main(){ var msg chan int msg = make(chan int) go func() { data := \u003c- msg fmt.Println(data) }() msg\u003c- 1 } //æ‰§è¡Œæƒ…å†µï¼šå•¥ä¹Ÿä¸ä¼šè¾“å‡ºï¼Œæ­£å¸¸ç»“æŸ 5.2 select é€šè¿‡è°ƒç”¨ select()å‡½æ•°æ¥ç›‘æ§ä¸€ç³»åˆ—çš„æ–‡ä»¶å¥æŸ„ï¼Œä¸€æ—¦å…¶ä¸­ä¸€ä¸ªæ–‡ä»¶å¥æŸ„å‘ç”Ÿäº† IO åŠ¨ä½œï¼Œè¯¥ select()è°ƒç”¨å°±ä¼šè¢«è¿”å›ã€‚åæ¥è¯¥æœºåˆ¶ä¹Ÿè¢«ç”¨äº å®ç°é«˜å¹¶å‘çš„ Socket æœåŠ¡å™¨ç¨‹åºã€‚Go è¯­è¨€ç›´æ¥åœ¨è¯­è¨€çº§åˆ«æ”¯æŒ select å…³é”®å­—ï¼Œç”¨äºå¤„ç†å¼‚æ­¥ IO é—®é¢˜ã€‚ select æœ‰æ¯”è¾ƒå¤šçš„ é™åˆ¶ï¼Œå…¶ä¸­æœ€å¤§çš„ä¸€æ¡é™åˆ¶å°±æ˜¯æ¯ä¸ª case è¯­å¥é‡Œå¿…é¡»æ˜¯ä¸€ä¸ª IO æ“ä½œã€‚ select { case \u003c-chan1: // å¦‚æœchan1æˆåŠŸè¯»åˆ°æ•°æ®ï¼Œåˆ™è¿›è¡Œè¯¥caseå¤„ç†è¯­å¥ case chan2 \u003c- 1: // å¦‚æœæˆåŠŸå‘chan2å†™å…¥æ•°æ®ï¼Œåˆ™è¿›è¡Œè¯¥caseå¤„ç†è¯­å¥ default: // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰æˆåŠŸï¼Œåˆ™è¿›å…¥defaultå¤„ç†æµç¨‹ } select çš„æ¯ä¸ª case è¯­å¥éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªé¢å‘ channel çš„æ“ä½œã€‚ 5.3 ç¼“å†²æœºåˆ¶ ç»™ channel å¸¦ä¸Šç¼“å†²ï¼Œ ä»è€Œè¾¾åˆ°æ¶ˆæ¯é˜Ÿåˆ—çš„æ•ˆæœã€‚è¦åˆ›å»ºä¸€ä¸ªå¸¦ç¼“å†²çš„ channelï¼Œå…¶å®ä¹Ÿéå¸¸å®¹æ˜“ï¼š c := make(chan int, 1024) åœ¨è°ƒç”¨ make()æ—¶å°†ç¼“å†²åŒºå¤§å°ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ å…¥å³å¯ï¼Œæ¯”å¦‚ä¸Šé¢è¿™ä¸ªä¾‹å­å°±åˆ›å»ºäº†ä¸€ä¸ªå¤§å° ä¸º 1024 çš„ int ç±»å‹ channelï¼Œå³ä½¿æ²¡æœ‰è¯»å–æ–¹ï¼Œå†™å…¥æ–¹ä¹Ÿå¯ä»¥ä¸€ç›´å¾€ channel é‡Œå†™å…¥ï¼Œåœ¨ç¼“å†²åŒºè¢« å¡«å®Œä¹‹å‰éƒ½ä¸ä¼šé˜»å¡ã€‚ 5.4 è¶…æ—¶æœºåˆ¶ åœ¨å¹¶å‘ç¼–ç¨‹çš„é€šä¿¡è¿‡ç¨‹ä¸­ï¼Œæœ€éœ€è¦å¤„ç†çš„å°±æ˜¯è¶…æ—¶é—®é¢˜ï¼Œå³å‘ channel å†™æ•°æ®æ—¶å‘ç° channel å·²æ»¡ï¼Œæˆ–è€…ä» channel è¯•å›¾è¯»å–æ•°æ®æ—¶å‘ç° channel ä¸ºç©ºã€‚å¦‚æœä¸æ­£ç¡®å¤„ç†è¿™äº›æƒ…å†µï¼Œå¾ˆå¯èƒ½ä¼šå¯¼ è‡´æ•´ä¸ª goroutine é”æ­»ã€‚ ä½¿ç”¨ channel æ—¶éœ€è¦å°å¿ƒï¼Œæ¯”å¦‚å¯¹äºä»¥ä¸‹è¿™ä¸ªç”¨æ³•ï¼š i:= \u003c-ch å¦‚æœå‡ºç°äº†ä¸€ä¸ªé”™è¯¯æƒ…å†µï¼Œå³æ°¸è¿œéƒ½æ²¡æœ‰äººå¾€ ch é‡Œå†™æ•°æ®ï¼Œé‚£ ä¹ˆä¸Šè¿°è¿™ä¸ªè¯»å–åŠ¨ä½œä¹Ÿå°†æ°¸è¿œæ— æ³•ä» ch ä¸­è¯»å–åˆ°æ•°æ®ï¼Œå¯¼è‡´çš„ç»“æœå°±æ˜¯æ•´ä¸ª goroutine æ°¸è¿œé˜»å¡å¹¶ æ²¡æœ‰æŒ½å›çš„æœºä¼šã€‚ Go è¯­è¨€æ²¡æœ‰æä¾›ç›´æ¥çš„è¶…æ—¶å¤„ç†æœºåˆ¶ï¼Œä½†æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ select æœºåˆ¶ã€‚è™½ç„¶ select æœºåˆ¶ä¸æ˜¯ ä¸“ä¸ºè¶…æ—¶è€Œè®¾è®¡çš„ï¼Œå´èƒ½å¾ˆæ–¹ä¾¿åœ°è§£å†³è¶…æ—¶é—®é¢˜ã€‚å› ä¸º select çš„ç‰¹ç‚¹æ˜¯åªè¦å…¶ä¸­ä¸€ä¸ª case å·²ç» å®Œæˆï¼Œç¨‹åºå°±ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œè€Œä¸ä¼šè€ƒè™‘å…¶ä»– case çš„æƒ…å†µã€‚ timeout := make(chan bool, 1) go func() { time.Sleep(1e9) // ç­‰å¾…1ç§’é’Ÿ timeout \u003c- true }() // ç„¶åæˆ‘ä»¬æŠŠtimeoutè¿™ä¸ªchannelåˆ©ç”¨èµ·æ¥ select { case \u003c-ch: // ä»chä¸­è¯»å–åˆ°æ•°æ® case \u003c-timeout: // ä¸€ç›´æ²¡æœ‰ä»chä¸­è¯»å–åˆ°æ•°æ®ï¼Œä½†ä»timeoutä¸­è¯»å–åˆ°äº†æ•°æ® } è¿™æ ·ä½¿ç”¨ select æœºåˆ¶å¯ä»¥é¿å…æ°¸ä¹…ç­‰å¾…çš„é—®é¢˜ï¼Œæ˜¯åœ¨ Go è¯­è¨€å¼€å‘ä¸­é¿å… channel é€šä¿¡è¶…æ—¶çš„æœ€æœ‰æ•ˆæ–¹æ³•ã€‚ 5.5 channel çš„ä¼ é€’ channel æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåŸç”Ÿç±»å‹,å…·æœ‰å¯è¢«ä¼ é€’çš„ç‰¹æ€§ã€‚ ç¤ºä¾‹ï¼šå®šä¹‰ä¸€ç³»åˆ— PipeData çš„æ•°æ®ç»“æ„å¹¶ä¸€èµ·ä¼ é€’ç»™ä¸€ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥è¾¾åˆ°æµå¼å¤„ç†æ•°æ®çš„ç›®çš„ã€‚ type PipeData struct { value int handler func(int) int next chan int } func handle(queue chan *PipeData) { for data := range queue { data.next \u003c- data.handler(data.value) } } 5.6 å•å‘ channel å•å‘ channel åªèƒ½ç”¨äºå‘é€æˆ–è€…æ¥æ”¶æ•°æ®ã€‚channel æœ¬èº«å¿…ç„¶æ˜¯åŒæ—¶æ”¯æŒè¯»å†™çš„ï¼Œ å¦åˆ™æ ¹æœ¬æ²¡æ³•ç”¨ã€‚åœ¨æ­¤ï¼Œæˆ‘ä»¬åªæ˜¯å¯¹å…¶å¢åŠ ä¸€äº›é™åˆ¶ã€‚ å•å‘ channel å˜é‡çš„å£°æ˜éå¸¸ç®€å•ï¼Œå¦‚ä¸‹ï¼š var ch1 chan int // ch1æ˜¯ä¸€ä¸ªæ­£å¸¸çš„channelï¼Œä¸æ˜¯å•å‘çš„ var ch2 chan\u003c- float64// ch2æ˜¯å•å‘channelï¼Œåªç”¨äºå†™float64æ•°æ® var ch3 \u003c-chan int // ch3æ˜¯å•å‘channelï¼Œåªç”¨äºè¯»å–intæ•°æ® channel æ˜¯ä¸€ä¸ªåŸç”Ÿç±»å‹ï¼Œå› æ­¤ä¸ä»… æ”¯æŒè¢«ä¼ é€’ï¼Œè¿˜æ”¯æŒç±»å‹è½¬æ¢ã€‚ åˆå§‹åŒ–ï¼š ch4 := make(chan int) ch5 := \u003c-chan int(ch4) // ch5å°±æ˜¯ä¸€ä¸ªå•å‘çš„è¯»å–channel ch6 := chan\u003c- int(ch4) // ch6 æ˜¯ä¸€ä¸ªå•å‘çš„å†™å…¥channel åŸºäº ch4ï¼Œæˆ‘ä»¬é€šè¿‡ç±»å‹è½¬æ¢åˆå§‹åŒ–äº†ä¸¤ä¸ªå•å‘ channelï¼šå•å‘è¯»çš„ ch5 å’Œå•å‘å†™çš„ ch6ã€‚ 5.7 å…³é—­ channel å…³é—­ channel éå¸¸ç®€å•ï¼Œç›´æ¥ä½¿ç”¨ Go è¯­è¨€å†…ç½®çš„ close()å‡½æ•°å³å¯ï¼š close(ch) å¦‚ä½•åˆ¤æ–­ä¸€ä¸ª channel æ˜¯å¦å·²ç»è¢«å…³ é—­ï¼Ÿæˆ‘ä»¬å¯ä»¥åœ¨è¯»å–çš„æ—¶å€™ä½¿ç”¨å¤šé‡è¿”å›å€¼çš„æ–¹å¼ï¼š x,ok := \u003c- ch ","date":"2023-04-06","objectID":"/golang-quick/:5:5","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"6 å¤šæ ¸å¹¶è¡ŒåŒ– ä¸‹é¢æˆ‘ä»¬æ¥æ¨¡æ‹Ÿä¸€ä¸ªå®Œå…¨å¯ä»¥å¹¶è¡Œçš„è®¡ç®—ä»»åŠ¡ï¼šè®¡ç®— N ä¸ªæ•´å‹æ•°çš„æ€»å’Œã€‚æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æ•´ å‹æ•°åˆ†æˆ M ä»½ï¼ŒM å³ CPU çš„ä¸ªæ•°ã€‚è®©æ¯ä¸ª CPU å¼€å§‹è®¡ç®—åˆ†ç»™å®ƒçš„é‚£ä»½è®¡ç®—ä»»åŠ¡ï¼Œæœ€åå°†æ¯ä¸ª CPU çš„è®¡ç®—ç»“æœå†åšä¸€æ¬¡ç´¯åŠ ï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ°æ‰€æœ‰ N ä¸ªæ•´å‹æ•°çš„æ€»å’Œï¼š type Vector []float64 // åˆ†é…ç»™æ¯ä¸ªCPUçš„è®¡ç®—ä»»åŠ¡ func (v Vector) DoSome(i, n int, u Vector, c chan int) { for ; i \u003c n; i++ { v[i] += u.Op(v[i]) } c \u003c- 1 // å‘ä¿¡å·å‘Šè¯‰ä»»åŠ¡ç®¡ç†è€…æˆ‘å·²ç»è®¡ç®—å®Œæˆäº† } const NCPU = 16 // å‡è®¾æ€»å…±æœ‰16æ ¸ func (v Vector) DoAll(u Vector) { c := make(chan int, NCPU) // ç”¨äºæ¥æ”¶æ¯ä¸ªCPUçš„ä»»åŠ¡å®Œæˆä¿¡å· for i := 0; i \u003c NCPU; i++ { go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c) } // ç­‰å¾…æ‰€æœ‰CPUçš„ä»»åŠ¡å®Œæˆ for i := 0; i \u003c NCPU; i++ { \u003c-c // è·å–åˆ°ä¸€ä¸ªæ•°æ®ï¼Œè¡¨ç¤ºä¸€ä¸ªCPUè®¡ç®—å®Œæˆäº† } // åˆ°è¿™é‡Œè¡¨ç¤ºæ‰€æœ‰è®¡ç®—å·²ç»ç»“æŸ } è¿™æˆ–è®¸å¯èƒ½åªåœ¨ä¸€ä¸ªæ ¸ä¸Šè·‘ã€‚åœ¨ Go è¯­è¨€å‡çº§åˆ°é»˜è®¤æ”¯æŒå¤š CPU çš„æŸä¸ªç‰ˆæœ¬ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆé€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡ GOMAXPROCS çš„å€¼æ¥æ§åˆ¶ä½¿ç”¨å¤šå°‘ä¸ª CPU æ ¸å¿ƒã€‚å…·ä½“æ“ä½œæ–¹æ³•æ˜¯é€šè¿‡ç›´æ¥è®¾ç½®ç¯å¢ƒå˜é‡ GOMAXPROCS çš„å€¼ï¼Œæˆ–è€…åœ¨ä»£ç ä¸­å¯åŠ¨ goroutine ä¹‹å‰å…ˆè°ƒç”¨ä»¥ä¸‹è¿™ä¸ªè¯­å¥ä»¥è®¾ç½®ä½¿ç”¨ 16 ä¸ª CPU æ ¸å¿ƒï¼š runtime.GOMAXPROCS(16) åˆ°åº•åº”è¯¥è®¾ç½®å¤šå°‘ä¸ª CPU æ ¸å¿ƒå‘¢ï¼Œå…¶å®runtimeåŒ…ä¸­è¿˜æä¾›äº†å¦å¤–ä¸€ä¸ªå‡½æ•°**NumCPU()**æ¥è· å–æ ¸å¿ƒæ•°ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:6","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"7 å‡ºè®©æ—¶é—´ç‰‡ æˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸ª goroutine ä¸­æ§åˆ¶ä½•æ—¶ä¸»åŠ¨å‡ºè®©æ—¶é—´ç‰‡ç»™å…¶ä»– goroutineï¼Œè¿™å¯ä»¥ä½¿ç”¨ runtime åŒ…ä¸­çš„ Gosched()å‡½æ•°å®ç°ã€‚ å¦‚æœè¦æ¯”è¾ƒç²¾ç»†åœ°æ§åˆ¶ goroutine çš„è¡Œä¸ºï¼Œå°±å¿…é¡»æ¯”è¾ƒæ·±å…¥åœ°äº†è§£ Go è¯­è¨€å¼€å‘åŒ…ä¸­ runtime åŒ…æ‰€æä¾›çš„å…·ä½“åŠŸèƒ½ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:5:7","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"8 åŒæ­¥ Go è¯­è¨€åŒ…ä¸­çš„ sync åŒ…æä¾›äº†ä¸¤ç§é”ç±»å‹ï¼šsync.Mutexå’Œsync.RWMutexã€‚ å½“ä¸€ä¸ª goroutine è·å¾—äº† Mutex åï¼Œå…¶ä»– goroutine å°±åªèƒ½ä¹–ä¹–ç­‰ åˆ°è¿™ä¸ª goroutine é‡Šæ”¾è¯¥ Mutexã€‚RWMutex ç›¸å¯¹å‹å¥½äº›ï¼Œæ˜¯ç»å…¸çš„å•å†™å¤šè¯»æ¨¡å‹ã€‚ 8.1 å…¨å±€å”¯ä¸€æ€§æ“ä½œ Go è¯­è¨€æä¾›äº†ä¸€ä¸ª Once ç±»å‹æ¥ä¿è¯å…¨å±€çš„å”¯ä¸€æ€§æ“ä½œï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š var a string var once sync.Once func setup() { a = \"hello, world\" } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } once çš„ Do()æ–¹æ³•å¯ä»¥ä¿è¯åœ¨å…¨å±€èŒƒå›´å†…åªè°ƒç”¨æŒ‡å®šçš„å‡½æ•°ä¸€æ¬¡ï¼ˆè¿™é‡ŒæŒ‡ setup()å‡½æ•°ï¼‰ï¼Œè€Œä¸”æ‰€æœ‰å…¶ä»– goroutine åœ¨è°ƒç”¨åˆ°æ­¤è¯­å¥æ—¶ï¼Œå°†ä¼šå…ˆè¢«é˜»å¡ï¼Œç›´è‡³å…¨å±€å”¯ä¸€çš„ once.Do()è°ƒç”¨ç»“æŸåæ‰ç»§ç»­ï¼ˆç»§ç»­æ‰§è¡Œæ­¤è¯­å¥åçš„è¯­å¥ï¼Œæ­¤è¯­å¥ä¸å†æ‰§è¡Œï¼‰ã€‚ ä¸ºäº†æ›´å¥½åœ°æ§åˆ¶å¹¶è¡Œä¸­çš„åŸå­æ€§æ“ä½œï¼Œsync åŒ…ä¸­è¿˜åŒ…å«ä¸€ä¸ª atomic å­åŒ…ï¼Œå®ƒæä¾›äº†å¯¹äºä¸€ äº›åŸºç¡€æ•°æ®ç±»å‹çš„åŸå­æ“ä½œå‡½æ•°ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸ªå‡½æ•°ï¼š func CompareAndSwapUint64(val *uint64, old, new uint64) (swapped bool) å°±æä¾›äº†æ¯”è¾ƒå’Œäº¤æ¢ä¸¤ä¸ª uint64 ç±»å‹æ•°æ®çš„æ“ä½œã€‚è¿™è®©å¼€å‘è€…æ— éœ€å†ä¸ºè¿™æ ·çš„æ“ä½œä¸“é—¨æ·»åŠ  Lock æ“ä½œã€‚ 8.2 waitGroup WaitGroup ç”¨äºç­‰å¾…ä¸€ç»„çº¿ç¨‹çš„ç»“æŸã€‚çˆ¶çº¿ç¨‹è°ƒç”¨ Add æ–¹æ³•æ¥è®¾å®šåº”ç­‰å¾…çš„çº¿ç¨‹çš„æ•°é‡ã€‚æ¯ä¸ªè¢«ç­‰å¾…çš„çº¿ç¨‹åœ¨ç»“æŸæ—¶åº”è°ƒç”¨ Done æ–¹æ³•ã€‚åŒæ—¶ï¼Œä¸»çº¿ç¨‹é‡Œå¯ä»¥è°ƒç”¨ Wait æ–¹æ³•é˜»å¡è‡³æ‰€æœ‰çº¿ç¨‹ç»“æŸã€‚ ä½†åœ¨ä½¿ç”¨æ—¶ï¼Œä¹Ÿæœ‰ä¸€äº›é—®é¢˜éœ€è¦æ³¨æ„ é€šè¿‡ WaitGroup æä¾›çš„ä¸‰ä¸ªå‡½æ•°ï¼šAdd,Done,Waitï¼Œå¯ä»¥è½»æ¾å®ç°ç­‰å¾…æŸä¸ªåç¨‹æˆ–åç¨‹ç»„å®Œæˆçš„åŒæ­¥æ“ä½œã€‚ä½†åœ¨ä½¿ç”¨æ—¶è¦æ³¨æ„: Add çš„æ•°é‡å’Œ Done çš„è°ƒç”¨æ•°é‡å¿…é¡»ç›¸ç­‰ã€‚ WaitGroup ç»“æ„ä¸€æ—¦å®šä¹‰å°±ä¸èƒ½å¤åˆ¶ã€‚ WaitGroup åœ¨éœ€è¦ç­‰å¾…å¤šä¸ªä»»åŠ¡ç»“æŸå†è¿”å›çš„ä¸šåŠ¡æ¥è¯´è¿˜æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œä½†ç°å®ä¸­ç”¨çš„æ›´å¤šçš„å¯èƒ½æ˜¯ï¼Œå…ˆç­‰å¾…ä¸€ä¸ªåç¨‹ç»„ï¼Œè‹¥æ‰€æœ‰åç¨‹ç»„éƒ½æ­£ç¡®å®Œæˆï¼Œåˆ™ä¸€ç›´ç­‰åˆ°æ‰€æœ‰åç¨‹ç»„ç»“æŸï¼›è‹¥å…¶ä¸­æœ‰ä¸€ä¸ªåç¨‹å‘ç”Ÿé”™è¯¯ï¼Œåˆ™å‘Šè¯‰åç¨‹ç»„çš„å…¶ä»–åç¨‹ï¼Œå…¨éƒ¨åœæ­¢è¿è¡Œï¼ˆæœ¬æ¬¡ä»»åŠ¡å¤±è´¥ï¼‰ä»¥å…æµªè´¹ç³»ç»Ÿèµ„æºã€‚ è¯¥åœºæ™¯ WaitGroup æ˜¯æ— æ³•å®ç°çš„ï¼Œé‚£ä¹ˆè¯¥åœºæ™¯è¯¥å¦‚ä½•å®ç°å‘¢ï¼Œå°±éœ€è¦ç”¨åˆ°é€šçŸ¥æœºåˆ¶ï¼Œå…¶å®ä¹Ÿå¯ä»¥ç”¨ channel æ¥å®ç°ï¼Œå…·ä½“çš„è§£å†³åŠæ³•ï¼Œè¯·çœ‹åç»­çš„æ–‡ç« ã€‚ è¿™æ ·è¯´æ¥ï¼ŒWaitGroup çš„ä½¿ç”¨åœºæ™¯æ˜¯æœ‰é™çš„ã€‚ package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup() func handle(n int) { defer wg.Done() fmt.Println(n) } func main() { for i=0; i\u003c=10; i++{ wg.Add(1) go handle(i) } wg.Wait() } /* WaitGroupæ˜¯syncåŒ…ä¸­æä¾›çš„ï¼Œå®ƒå¯ä»¥è®©å­åç¨‹æ‰§è¡Œå®Œï¼Œä¸»åç¨‹å†æ­»äº¡ã€‚ä»è€Œè¾¾åˆ°ä¼˜é›…é€€å‡ºçš„æ•ˆæœã€‚ æ³¨æ„ï¼š 1. Addå‡½æ•°ï¼šå¼€å¯å‡ ä¸ªå­åç¨‹å°±éœ€è¦æ‰§è¡Œå‡ æ¬¡è¯¥å‡½æ•°ã€‚ 2. Doneå‡½æ•°ï¼šæ‰§è¡Œå‡ æ¬¡Addå‡½æ•°å°±éœ€è¦æ‰§è¡Œå‡ æ¬¡Doneå‡½æ•°ã€‚ 3. Waitå‡½æ•°ï¼šåªæ‰§è¡Œä¸€æ¬¡ï¼Œå°±æ˜¯åœ¨å­åç¨‹å…¨éƒ¨æ‰§è¡Œå®Œæˆåã€‚ */ 8.3 äº’æ–¥é”è¯»å†™é” äº’æ–¥é”å’Œè¯»å†™é”ç”¨äºå¤„ç†é«˜å¹¶å‘æ—¶å¯¹ä¸´ç•ŒåŒºèµ„æºæ“ä½œçš„åŒæ­¥é—®é¢˜ äº’æ–¥é”ï¼šåœ¨æŸä¸€æ–¹æ³•å¯¹æ•°æ®è¿›è¡Œæ“ä½œæ—¶ï¼Œä¼šå°†è¯¥æ•°æ®è¿›è¡Œä¸Šé”æ“ä½œï¼Œæ­¤æ—¶å…¶ä»–ä»»ä½•å¯¹è¯¥æ•°æ®è¿›è¡Œæ“ä½œçš„æ–¹æ³•éƒ½ä¼šè¿›å…¥ç­‰å¾…ï¼Œåªæœ‰å½“ä¸Šé”çš„æ–¹æ³•ä¸»åŠ¨è§£é”å…¶ä»–æ–¹æ³•æ‰èƒ½å¾—åˆ°å¯¹è¯¥æ•°æ®çš„æ“ä½œæƒã€‚ è¯»å†™é”ï¼šäº’æ–¥é”å½±å“äº†é«˜å¹¶å‘æœåŠ¡çš„æ€§èƒ½ã€‚è¯»å†™é”å°±æ˜¯ä¸ºäº†è§£å†³è¿™ç±»é—®é¢˜çš„ã€‚å†™æ•°æ®æ—¶ä¸Šé”ï¼Œå…¶ä»–åç¨‹éƒ½ä¸å¯ä»¥å¯¹è¯¥æ•°æ®è¿›è¡Œè¯»å’Œå†™ï¼›è¯»æ•°æ®æ—¶ä¸ä¸Šé”ï¼Œå…¶ä»–åç¨‹éƒ½å¯ä»¥è¯»å’Œå†™ã€‚ä¸Šè¯»é”æ—¶ï¼Œåªèƒ½è¯»ä¸å¯å†™ï¼›è¯»é”é‡Šæ”¾ï¼Œæ‰å¯å†™ã€‚ package main import ( \"fmt\" \"sync\" \"time\" ) var rwLock sync.RWMutex var wg sync.WaitGroup func read(){ defer wg.Done() rwLock.RLock() fmt.Println(\"è¯»å–æ•°æ®\") time.Sleep(time.Second) fmt.Println(\"è¯»å–æˆåŠŸ\") rwLock.RUnlock() } func write(){ defer wg.Done() rwLock.Lock() fmt.Println(\"ä¿®æ”¹æ•°æ®\") time.Sleep(time.Second*10) fmt.Println(\"ä¿®æ”¹æˆåŠŸ\") rwLock.Unlock() } func main() { wg.Add(10) for i := 0;i\u003c5;i++ { go read() } for i := 0;i\u003c5;i++ { go write() } wg.Wait() } 8.4 é€šé“æ“ä½œ é€šé“å¯ä»¥å®Œæˆå¤šä¸ªåç¨‹çš„é€šä¿¡ï¼Œé€šè¿‡çµæ´»ä½¿ç”¨ å„ç§ç±»å‹çš„é€šé“çš„è¯»å†™é€šé“æ“ä½œï¼Œå®Œæˆå¤æ‚çš„åŒæ­¥é€»è¾‘ã€‚ä¾‹å­å¦‚ä¸‹ç¤ºä¾‹ä»£ç æ‰€ç¤ºã€‚ æ— ç¼“å†²é€šé“ æœ‰ç¼“å†²é€šé“ å•å‘é€šé“ åŒå‘é€šé“ package main import ( \"encoding/csv\" \"fmt\" \"os\" \"strconv\" \"sync\" \"time\" ) type Server struct { } func (server *Server) Connect() chan []string { session := make(chan []string, 128) //ç›‘å¬session go func(c chan []string) { file, _ := os.OpenFile(\"./test.csv\", os.O_CREATE|os.O_TRUNC, 0666) defer file.Close() writer := csv.NewWriter(file) defer file.Close() for { strs := \u003c-c if strs[0] == \"CLOSE\" { writer.Write(strs) writer.Flush() fmt.Println(\"ç»“æŸé€šä¿¡\") break } writer.Write(strs) writer.Flush() } }(session) fmt.Println(\"å»ºç«‹è¿æ¥æˆåŠŸ!\") return session } func NewServer() *Server { return \u0026Server{ } } type Client struct { conn chan []string } func NewClient(server *Server) *Client { //å»ºç«‹å®¢æˆ·ç«¯çš„åŒæ—¶ï¼Œä½¿ç”¨é€šé“å»ºç«‹åç¨‹é—´çš„é€šä¿¡ c := server.Connect() return \u0026Client{c} } func (client *Client) Send(strs []string) { client.conn \u003c- strs } var wp sync.WaitGroup func main() { server := NewServer() client := NewClient(server) for i := 0; i \u003c 10000; i++ { wp.Add(1) go func() { defer wp.Done() client.Send([]string{\"hello\", strconv.Itoa(i)}) }() } //time.Sleep(time.Duration(1) * time.Second) wp.Wait() go client.Send([]string{\"CLOSE\"}) time.Sleep(time.Duration(1) * time.Second) } 8.5 select selet çš„åº”ç”¨æœ‰å¾ˆå¤šï¼Œæ¯”å¦‚ï¼šç›‘æ§å¼‚æ­¥ IOã€è¶…æ—¶å¤„ç†â€¦ å¦‚ä¸‹ä»£ç æ˜¯ä¸€ä¸ªè¶…æ—¶å¤„ç†çš„ demoï¼Œæ¯éš”ä¸¤ç§’å¾€é€šé“é‡Œå†™æ•°æ®ï¼Œselect ç›‘æ§åˆ°é€šé“è¢«å†™å…¥äº†æ•°æ®ï¼Œè¿™å°±ä»£è¡¨å·²ç»å‘ç”Ÿäº†è¶…æ—¶ï¼Œé‚£ä¹ˆ case åçš„è¯­å¥å°±å¯ä»¥åšä¸€äº›è¶…æ—¶çš„å¤„ç†æ“ä½œã€‚ import \"time\" import \"fmt\" func main() { c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 \u003c- \"result 1\" }() select { case res := \u003c-c1: fmt.Println(res) case \u003c-time.After(time.Second * 1): fmt.Println(\"timeout 1\") } } 8.6 context å½“æˆ‘ä»¬çš„ç¨‹åºé€»è¾‘è¾ƒä¸ºå¤æ‚çš„æ—¶å€™ï¼Œæ¯”å¦‚ï¼šä¸»çº¿ç¨‹è°ƒèµ·äº†ä¸€ä¸ªåç¨‹ï¼Œè¯¥åç¨‹åˆè°ƒèµ·äº†å¦å¤–ä¸€ä¸ªåç¨‹ï¼Œè¿™ç§è¾ƒä¸ºå¤æ‚çš„å¹¶å‘åœºæ™¯å¯¹åç¨‹çš„æ§åˆ¶éå¸¸é‡è¦ï¼ŒåŠæ—¶å…³é—­ä¸å¿…è¦çš„åç¨‹å¯ä»¥ä¿è¯ç¨‹åºçš„æ€§èƒ½ï¼Œé¿å…ä¸å¿…è¦çš„èµ„æºæµªè´¹ã€‚è¿™ä¸ªæ—¶å€™waitGroupå°±ä¸å¥½ç”¨äº†ï¼Œå› ä¸ºå®ƒå…¨å±€ä¸å¯å¤åˆ¶ï¼Œå¯¹äºå±‚çº§è¾ƒæ·±çš„åç¨‹ï¼Œå°±ä¸å¤ªé€‚ç”¨äº†ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå°±å¿…é¡»ä½¿ç”¨channelå’Œselectç»“åˆä½¿ç”¨äº†ã€‚Golang æ ‡å‡†åº“å·²ç»ä¸ºæˆ‘ä»¬å°è£…å¥½äº†è¿™ç§å·¥å…·","date":"2023-04-06","objectID":"/golang-quick/:5:8","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"ç½‘ç»œç¼–ç¨‹ ","date":"2023-04-06","objectID":"/golang-quick/:6:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 TCP 1.1 TCP Server package main import ( \"bufio\" \"fmt\" \"io\" \"net\" ) func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:5000\") if err != nil { fmt.Println(\"Error:\", err.Error()) } for { conn, err := server.Accept() if err != nil { fmt.Println(\"Error:\", err.Error()) } go func(c net.Conn) { defer c.Close() for { reader := bufio.NewReader(c) var receive [128]byte n, err := reader.Read(receive[:]) if err != nil { if err != io.EOF { fmt.Println(\"Error:\", err) } break } fmt.Println(\"receive:\", string(receive[:n])) c.Write([]byte(\"ä½ å¥½\")) } }(conn) } } 1.2 TCP Client func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") if err != nil { fmt.Println(\"Error:\", err.Error()) } defer conn.Close() _, err = conn.Write([]byte(\"hello\")) if err != nil { fmt.Println(\"Error:\", err.Error()) } response := [128]byte{} n, err := conn.Read(response[:]) if err != nil { fmt.Println(\"Error:\", err.Error()) } fmt.Println(\"response:\", string(response[:n])) } ","date":"2023-04-06","objectID":"/golang-quick/:6:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 UDP 2.1 UDP Server func main() { server, err := net.ListenUDP(\"udp\", \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 5000, }) if err != nil { fmt.Println(\"Error:\", err.Error()) } defer server.Close() for { var data [1024]byte n, addr, err := server.ReadFromUDP(data[:]) if err != nil { fmt.Println(\"Error:\", err.Error()) } fmt.Printf(\"data:%v addr:%v count:%v\\n\", string(data[:n]), addr, n) _, err = server.WriteToUDP(data[:n], addr) // å‘é€æ•°æ® if err != nil { fmt.Println(\"write to udp failed, err:\", err) continue } } } ","date":"2023-04-06","objectID":"/golang-quick/:6:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 HTTP 3.1 HTTP Server func ListenAndServe(addr string, handler Handler) error è¯¥æ–¹æ³•ç”¨äºåœ¨æŒ‡å®šçš„ TCP ç½‘ç»œåœ°å€ addr è¿›è¡Œç›‘å¬ï¼Œç„¶åè°ƒç”¨æœåŠ¡ç«¯å¤„ç†ç¨‹åºæ¥å¤„ç†ä¼ å…¥çš„è¿ æ¥è¯·æ±‚ã€‚è¯¥æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°ï¼šç¬¬ä¸€ä¸ªå‚æ•° addr å³ç›‘å¬åœ°å€ï¼›ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºæœåŠ¡ç«¯å¤„ç†ç¨‹åºï¼Œ é€šå¸¸ä¸ºç©ºï¼Œè¿™æ„å‘³ç€æœåŠ¡ç«¯è°ƒç”¨ http.DefaultServeMux è¿›è¡Œå¤„ç†ï¼Œè€ŒæœåŠ¡ç«¯ç¼–å†™çš„ä¸šåŠ¡é€» è¾‘å¤„ç†ç¨‹åº http.Handle() æˆ– http.HandleFunc() é»˜è®¤æ³¨å…¥ http.DefaultServeMux ä¸­ã€‚ package main import ( \"fmt\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) { defer request.Body.Close() if request.Method == \"GET\" { fmt.Fprint(writer, \"Hello\", request.RemoteAddr) return } if request.Method == \"POST\" { request.ParseForm() //è¿™é‡Œéœ€è¦å…ˆè§£æä¸€ä¸‹ï¼Œæ‰èƒ½æ‹¿åˆ°ç»“æœ params := request.PostForm for k, v := range params { fmt.Println(k,v) } return } }) err := http.ListenAndServe(\"0.0.0.0:5000\", nil) if err != nil { fmt.Println(\"Error:\", err.Error()) return } } 3.2 HTTP Client package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"net/url\" ) func MyGetNoParams(url_ string) (responseBody string, err error) { resp, err := http.Get(url_) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } return string(body), nil } func MyGetParams(url_ string) (responseBody string, err error) { params := url.Values{} params.Set(\"wd\", \"hello\") u, err := url.ParseRequestURI(url_) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } fmt.Println(u.String()) //http://www.baidu.com u.RawQuery = params.Encode() //å°†éœ€è¦æºå¸¦çš„å‚æ•°ä¿¡æ¯æ‹¼æ¥åˆ°å½“å‰urlçš„å°¾éƒ¨ fmt.Println(u.String()) //http://www.baidu.com?wd=hello return MyGetNoParams(u.String()) } func MyPost(url_ string) { params := url.Values{} params.Set(\"wd\", \"hello\") resp, err := http.PostForm(url_, params) if err!= nil{ fmt.Println(err) } defer resp.Body.Close() body,err := ioutil.ReadAll(resp.Body) if err!= nil{ fmt.Println(err) } fmt.Println(string(body)) } func main() { //resp, err := MyGetParams(\"http://www.baidu.com\") //if err != nil { // fmt.Println(\"Error:\", err) // return //} //fmt.Println(resp) MyPost(\"http://127.0.0.1:5000/\") } ","date":"2023-04-06","objectID":"/golang-quick/:6:3","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4 RPC go è¯­è¨€è¿›ç¨‹é—´é€šä¿¡çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼šHTTPã€RPCã€‚ RPCï¼ˆRemote Procedure Callï¼Œè¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼‰æ˜¯ä¸€ç§é€šè¿‡ç½‘ç»œä»è¿œç¨‹è®¡ç®—æœºç¨‹åºä¸Šè¯·æ±‚æœ åŠ¡ï¼Œè€Œä¸éœ€è¦äº†è§£åº•å±‚ç½‘ç»œç»†èŠ‚çš„åº”ç”¨ç¨‹åºé€šä¿¡åè®®ã€‚RPC åè®®æ„å»ºäº TCP æˆ– UDPï¼Œæˆ–è€…æ˜¯ HTTP ä¹‹ä¸Šï¼Œå…è®¸å¼€å‘è€…ç›´æ¥è°ƒç”¨å¦ä¸€å°è®¡ç®—æœºä¸Šçš„ç¨‹åºï¼Œè€Œå¼€å‘è€…æ— éœ€é¢å¤–åœ°ä¸ºè¿™ä¸ªè°ƒç”¨è¿‡ç¨‹ç¼–å†™ç½‘ ç»œé€šä¿¡ç›¸å…³ä»£ç ï¼Œä½¿å¾—å¼€å‘åŒ…æ‹¬ç½‘ç»œåˆ†å¸ƒå¼ç¨‹åºåœ¨å†…çš„åº”ç”¨ç¨‹åºæ›´åŠ å®¹æ˜“ã€‚ RPC é‡‡ç”¨å®¢æˆ·ç«¯â€”æœåŠ¡å™¨ï¼ˆClient/Serverï¼‰çš„å·¥ä½œæ¨¡å¼ã€‚è¯·æ±‚ç¨‹åºå°±æ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯ï¼ˆClientï¼‰ï¼Œ è€ŒæœåŠ¡æä¾›ç¨‹åºå°±æ˜¯ä¸€ä¸ªæœåŠ¡å™¨ï¼ˆServerï¼‰ã€‚å½“æ‰§è¡Œä¸€ä¸ªè¿œç¨‹è¿‡ç¨‹è°ƒç”¨æ—¶ï¼Œå®¢æˆ·ç«¯ç¨‹åºé¦–å…ˆå‘é€ä¸€ ä¸ªå¸¦æœ‰å‚æ•°çš„è°ƒç”¨ä¿¡æ¯åˆ°æœåŠ¡ç«¯ï¼Œç„¶åç­‰å¾…æœåŠ¡ç«¯å“åº”ã€‚åœ¨æœåŠ¡ç«¯ï¼ŒæœåŠ¡è¿›ç¨‹ä¿æŒç¡çœ çŠ¶æ€ç›´åˆ° å®¢æˆ·ç«¯çš„è°ƒç”¨ä¿¡æ¯åˆ°è¾¾ä¸ºæ­¢ã€‚å½“ä¸€ä¸ªè°ƒç”¨ä¿¡æ¯åˆ°è¾¾æ—¶ï¼ŒæœåŠ¡ç«¯è·å¾—è¿›ç¨‹å‚æ•°ï¼Œè®¡ç®—å‡ºç»“æœï¼Œå¹¶å‘ å®¢æˆ·ç«¯å‘é€åº”ç­”ä¿¡æ¯ï¼Œç„¶åç­‰å¾…ä¸‹ä¸€ä¸ªè°ƒç”¨ã€‚æœ€åï¼Œå®¢æˆ·ç«¯æ¥æ”¶æ¥è‡ªæœåŠ¡ç«¯çš„åº”ç­”ä¿¡æ¯ï¼Œè·å¾—è¿› ç¨‹ç»“æœï¼Œç„¶åè°ƒç”¨æ‰§è¡Œå¹¶ç»§ç»­è¿›è¡Œã€‚ ä¸€ä¸ª RPC æœåŠ¡ç«¯å¯ä»¥æ³¨å†Œå¤šä¸ªä¸åŒç±»å‹ çš„å¯¹è±¡ï¼Œä½†ä¸å…è®¸æ³¨å†ŒåŒä¸€ç±»å‹çš„å¤šä¸ªå¯¹è±¡ã€‚ ä¸€ä¸ªå¯¹è±¡ä¸­åªæœ‰æ»¡è¶³å¦‚ä¸‹è¿™äº›æ¡ä»¶çš„æ–¹æ³•ï¼Œæ‰èƒ½è¢« RPC æœåŠ¡ç«¯è®¾ç½®ä¸ºå¯ä¾›è¿œç¨‹è®¿é—®ï¼š å¿…é¡»æ˜¯åœ¨å¯¹è±¡å¤–éƒ¨å¯å…¬å¼€è°ƒç”¨çš„æ–¹æ³•ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰ï¼› å¿…é¡»æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œä¸”å‚æ•°çš„ç±»å‹éƒ½å¿…é¡»æ˜¯åŒ…å¤–éƒ¨å¯ä»¥è®¿é—®çš„ç±»å‹æˆ–è€…æ˜¯ Go å†…å»ºæ”¯æŒçš„ç±» å‹ï¼› ç¬¬äºŒä¸ªå‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼› æ–¹æ³•å¿…é¡»è¿”å›ä¸€ä¸ª error ç±»å‹çš„å€¼ã€‚ ä»¥ä¸Šå››ç‚¹å¯ä»¥ç”¨ä¸€è¡Œä»£ç è¡¨ç¤ºï¼šfunc (t *T) MethodName(argType T1, replyType *T2) error è¯¥æ–¹æ³•ï¼ˆMethodNameï¼‰çš„ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤ºç”± RPC å®¢æˆ·ç«¯ä¼ å…¥çš„å‚æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºè¦è¿” å›ç»™ RPC å®¢æˆ·ç«¯çš„ç»“æœï¼Œè¯¥æ–¹æ³•æœ€åè¿”å›ä¸€ä¸ª error ç±»å‹çš„å€¼ã€‚ 4.1 RPC æœåŠ¡ç«¯ RPC æœåŠ¡ç«¯å¯ä»¥é€šè¿‡è°ƒç”¨ rpc.ServeConn å¤„ç†å•ä¸ªè¿æ¥è¯·æ±‚ã€‚å¤šæ•°æƒ…å†µä¸‹ï¼Œé€šè¿‡ TCP æˆ– æ˜¯ HTTP åœ¨æŸä¸ªç½‘ç»œåœ°å€ä¸Šè¿›è¡Œç›‘å¬æ¥åˆ›å»ºè¯¥æœåŠ¡æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ã€‚ 4.2 RPC å®¢æˆ·ç«¯ åœ¨ RPC å®¢æˆ·ç«¯ï¼ŒGo çš„ net/rpc åŒ…æä¾›äº†ä¾¿åˆ©çš„ rpc.Dial() å’Œ rpc.DialHTTP() æ–¹æ³• æ¥ä¸æŒ‡å®šçš„ RPC æœåŠ¡ç«¯å»ºç«‹è¿æ¥ã€‚åœ¨å»ºç«‹è¿æ¥ä¹‹åï¼ŒGo çš„ net/rpc åŒ…å…è®¸æˆ‘ä»¬ä½¿ç”¨åŒæ­¥æˆ–è€… å¼‚æ­¥çš„æ–¹å¼æ¥æ”¶ RPC æœåŠ¡ç«¯çš„å¤„ç†ç»“æœã€‚è°ƒç”¨ RPC å®¢æˆ·ç«¯çš„ **Call() æ–¹æ³•åˆ™è¿›è¡ŒåŒæ­¥å¤„ç†ï¼Œ**è¿™ æ—¶å€™å®¢æˆ·ç«¯ç¨‹åºæŒ‰é¡ºåºæ‰§è¡Œï¼Œåªæœ‰æ¥æ”¶å®Œ RPC æœåŠ¡ç«¯çš„å¤„ç†ç»“æœä¹‹åæ‰å¯ä»¥ç»§ç»­æ‰§è¡Œåé¢çš„ç¨‹ åºã€‚å½“è°ƒç”¨ RPC å®¢æˆ·ç«¯çš„ Go() æ–¹æ³•æ—¶ï¼Œåˆ™å¯ä»¥è¿›è¡Œå¼‚æ­¥å¤„ç†ï¼ŒRPC å®¢æˆ·ç«¯ç¨‹åºæ— éœ€ç­‰å¾…æœåŠ¡ ç«¯çš„ç»“æœå³å¯æ‰§è¡Œåé¢çš„ç¨‹åºï¼Œè€Œå½“æ¥æ”¶åˆ° RPC æœåŠ¡ç«¯çš„å¤„ç†ç»“æœæ—¶ï¼Œå†å¯¹å…¶è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚ æ— è®ºæ˜¯è°ƒç”¨ RPC å®¢æˆ·ç«¯çš„ Call() æˆ–è€…æ˜¯ Go() æ–¹æ³•ï¼Œéƒ½å¿…é¡»æŒ‡å®šè¦è°ƒç”¨çš„æœåŠ¡åŠå…¶æ–¹æ³•åç§°ï¼Œ ä»¥åŠä¸€ä¸ªå®¢æˆ·ç«¯ä¼ å…¥å‚æ•°çš„å¼•ç”¨ï¼Œè¿˜æœ‰ä¸€ä¸ªç”¨äºæ¥æ”¶å¤„ç†ç»“æœå‚æ•°çš„æŒ‡é’ˆã€‚ å¦‚æœæ²¡æœ‰æ˜ç¡®æŒ‡å®š RPC ä¼ è¾“è¿‡ç¨‹ä¸­ä½¿ç”¨ä½•ç§ç¼–ç è§£ç å™¨ï¼Œé»˜è®¤å°†ä½¿ç”¨ Go æ ‡å‡†åº“æä¾›çš„ encoding/gob åŒ…è¿›è¡Œæ•°æ®ä¼ è¾“ã€‚ 4.3 RPC æœåŠ¡ç«¯ä¸å®¢æˆ·ç«¯ä»£ç ç¤ºä¾‹ package myRpc import \"errors\" type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(\"divide by zero\") } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } 4.3.1 RPC æœåŠ¡ç«¯ package main import ( \"go_learn/myNet/myRpc\" \"log\" \"net\" \"net/http\" \"net/rpc\" ) func main() { arith := new(myRpc.Arith) rpc.Register(arith) rpc.HandleHTTP() l, e := net.Listen(\"tcp\", \"127.0.0.1:1234\") if e != nil { log.Fatal(\"listen error:\", e) } http.Serve(l, nil) } æ­¤æ—¶ï¼ŒRPC æœåŠ¡ç«¯æ³¨å†Œäº†ä¸€ä¸ª Arith ç±»å‹çš„å¯¹è±¡åŠå…¶å…¬å¼€æ–¹æ³• Arith.Multiply()å’Œ Arith.Divide()ä¾› RPC å®¢æˆ·ç«¯è°ƒç”¨ã€‚ 4.3.2 RPC å®¢æˆ·ç«¯ RPC åœ¨è°ƒç”¨æœåŠ¡ç«¯æä¾›çš„æ–¹æ³•ä¹‹å‰ï¼Œå¿…é¡»å…ˆä¸ RPC æœåŠ¡ ç«¯å»ºç«‹è¿æ¥ã€‚ package main import ( \"fmt\" \"go_learn/myNet/myRpc\" \"log\" \"net/rpc\" ) func main() { client, err := rpc.DialHTTP(\"tcp\", \"127.0.0.1:1234\") if err != nil { log.Fatal(\"dialing:\", err) } //åŒæ­¥è°ƒç”¨ç¨‹åºé¡ºåºæ‰§è¡Œçš„æ–¹å¼ args := \u0026myRpc.Args{7, 8} var reply int err = client.Call(\"Arith.Multiply\", args, \u0026reply) if err != nil { log.Fatal(\"arith error:\", err) } fmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply) //å¼‚æ­¥è°ƒç”¨ //quotient := new(Quotient) //divCall := client.Go(\"Arith.Divide\", args, \u0026quotient, nil) //replyCall := \u003c-divCall.Done } ","date":"2023-04-06","objectID":"/golang-quick/:6:4","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"5 Gob Gob æ˜¯ Go çš„ä¸€ä¸ªåºåˆ—åŒ–æ•°æ®ç»“æ„çš„ç¼–ç è§£ç å·¥å…·ï¼Œåœ¨ Go æ ‡å‡†åº“ä¸­å†…ç½® encoding/gob åŒ… ä»¥ä¾›ä½¿ç”¨ã€‚ä¸€ä¸ªæ•°æ®ç»“æ„ä½¿ç”¨ Gob è¿›è¡Œåºåˆ—åŒ–ä¹‹åï¼Œèƒ½å¤Ÿç”¨äºç½‘ç»œä¼ è¾“ã€‚ä¸ JSON æˆ– XML è¿™ç§ åŸºäºæ–‡æœ¬æè¿°çš„æ•°æ®äº¤æ¢è¯­è¨€ä¸åŒï¼ŒGob æ˜¯äºŒè¿›åˆ¶ç¼–ç çš„æ•°æ®æµï¼Œå¹¶ä¸” Gob æµæ˜¯å¯ä»¥è‡ªè§£é‡Šçš„ï¼Œ å®ƒåœ¨ä¿è¯é«˜æ•ˆç‡çš„åŒæ—¶ï¼Œä¹Ÿå…·å¤‡å®Œæ•´çš„è¡¨è¾¾èƒ½åŠ›ã€‚ ç”±äº Gob ä»…å±€ é™äºä½¿ç”¨ Go è¯­è¨€å¼€å‘çš„ç¨‹åºï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬åªèƒ½ç”¨ Go çš„ RPC å®ç°è¿›ç¨‹é—´é€šä¿¡ï¼Œæˆ‘ä»¬ç”¨ Go ç¼–å†™çš„ RPC æœåŠ¡ç«¯ï¼ˆæˆ–å®¢æˆ·ç«¯ï¼‰ï¼Œå¯èƒ½æ›´å¸Œæœ›å®ƒæ˜¯é€šç”¨çš„ï¼Œä¸è¯­è¨€æ— å…³çš„ï¼Œæ—  è®ºæ˜¯ Python ã€ Java æˆ–å…¶ä»–ç¼–ç¨‹è¯­è¨€å®ç°çš„ RPC å®¢æˆ·ç«¯ï¼Œå‡å¯ä¸ä¹‹é€šä¿¡ã€‚ ","date":"2023-04-06","objectID":"/golang-quick/:6:5","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"6 JSON å¤„ç† Go è¯­è¨€çš„å¤§å¤šæ•°æ•°æ®ç±»å‹éƒ½å¯ä»¥è½¬åŒ–ä¸ºæœ‰æ•ˆçš„ JSON æ–‡æœ¬ï¼Œä½† channelã€complex å’Œå‡½æ•°è¿™å‡ ç§ ç±»å‹é™¤å¤–ã€‚ å¦‚æœè½¬åŒ–å‰çš„æ•°æ®ç»“æ„ä¸­å‡ºç°æŒ‡é’ˆï¼Œé‚£ä¹ˆå°†ä¼šè½¬åŒ–æŒ‡é’ˆæ‰€æŒ‡å‘çš„å€¼ï¼Œå¦‚æœæŒ‡é’ˆæŒ‡å‘çš„æ˜¯é›¶å€¼ï¼Œ é‚£ä¹ˆ null å°†ä½œä¸ºè½¬åŒ–åçš„ç»“æœè¾“å‡ºã€‚ å­—ç¬¦ä¸²å°†ä»¥ UTF-8 ç¼–ç è½¬åŒ–è¾“å‡ºä¸º Unicode å­—ç¬¦é›†çš„å­—ç¬¦ä¸²ï¼Œç‰¹æ®Šå­—ç¬¦æ¯”å¦‚\u003cå°†ä¼šè¢«è½¬ä¹‰ä¸º \\u003c å¦‚æœ JSON ä¸­çš„å­—æ®µåœ¨ Go ç›®æ ‡ç±»å‹ä¸­ä¸å­˜åœ¨ï¼Œjson.Unmarshal()å‡½æ•°åœ¨è§£ç è¿‡ç¨‹ä¸­ä¼šä¸¢å¼ƒ è¯¥å­—æ®µã€‚ ç›®æ ‡ç±»å‹ä¸­ä¸å¯è¢«å¯¼å‡ºçš„ç§æœ‰å­—æ®µï¼ˆéé¦– å­—æ¯å¤§å†™ï¼‰å°†ä¸ä¼šå—åˆ°è§£ç è½¬åŒ–çš„å½±å“ã€‚ 6.1 è§£ç æœªçŸ¥ç»“æ„çš„ JSON æ•°æ® ç©ºæ¥å£æ˜¯é€šç”¨ç±»å‹ã€‚å¦‚æœè¦è§£ç ä¸€æ®µæœªçŸ¥ç»“æ„çš„ JSONï¼Œåªéœ€å°†è¿™æ®µ JSON æ•°æ®è§£ç è¾“å‡ºåˆ°ä¸€ä¸ªç©ºæ¥å£å³å¯ã€‚ 6.2 JSON çš„æµå¼è¯»å†™ Go å†…å»ºçš„ encoding/json åŒ…è¿˜æä¾› Decoder å’Œ Encoder ä¸¤ä¸ªç±»å‹ï¼Œç”¨äºæ”¯æŒ JSON æ•°æ®çš„ æµå¼è¯»å†™ï¼Œå¹¶æä¾› NewDecoder()å’Œ NewEncoder()ä¸¤ä¸ªå‡½æ•°æ¥ä¾¿äºå…·ä½“å®ç°ã€‚ package main import ( \"encoding/json\" \"log\" \"os\" ) func main() { dec := json.NewDecoder(os.Stdin) enc := json.NewEncoder(os.Stdout) for { var v map[string]interface{} if err := dec.Decode(\u0026v); err != nil { log.Println(err) return } for k := range v { if k != \"Title\" { v[k] = nil, false } } if err := enc.Encode(\u0026v); err != nil { log.Println(err) } } } ","date":"2023-04-06","objectID":"/golang-quick/:6:6","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"å¸¸ç”¨å·¥å…·åº“ ","date":"2023-04-06","objectID":"/golang-quick/:7:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"1 å­—ç¬¦ä¸²æ“ä½œ func Compare(a, b string) int //æŒ‰å­—å…¸é¡ºåºæ¯”è¾ƒaå’Œbå­—ç¬¦ä¸²å¤§å° func Contains(s, substr string) bool //åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦åŒ…å«substrå­—ç¬¦ä¸² func ContainsAny(s, chars string) bool //åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦åŒ…å«charså­—ç¬¦ä¸²ä¸­çš„ä»»ä¸€å­—ç¬¦ func ContainsRune(s string, r rune) bool //åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦åŒ…å«unicodeç å€¼r func Count(s, sep string) int //è¿”å›å­—ç¬¦ä¸²såŒ…å«å­—ç¬¦ä¸²sepçš„ä¸ªæ•° func EqualFold(s, t string) bool //åˆ¤æ–­så’Œtä¸¤ä¸ªutf8å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼Œå¿½ç•¥å¤§å°å†™ func Fields(s string) []string //å°†å­—ç¬¦ä¸²sä»¥ç©ºç™½å­—ç¬¦åˆ†å‰²ï¼Œè¿”å›ä¸€ä¸ªåˆ‡ç‰‡ func FieldsFunc(s string, f func(rune) bool) []string //å°†å­—ç¬¦ä¸²sä»¥æ»¡è¶³f(r)==trueçš„å­—ç¬¦åˆ†å‰²ï¼Œè¿”å›ä¸€ä¸ªåˆ‡ç‰‡ func HasPrefix(s, prefix string) bool //åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦æœ‰å‰ç¼€å­—ç¬¦ä¸²prefix func HasSuffix(s, suffix string) bool //åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦æœ‰å‰ç¼€å­—ç¬¦ä¸²suffix func Index(s, sep string) int //è¿”å›å­—ç¬¦ä¸²sä¸­å­—ç¬¦ä¸²sepé¦–æ¬¡å‡ºç°çš„ä½ç½® func IndexAny(s, chars string) int //è¿”å›å­—ç¬¦ä¸²charsä¸­çš„ä»»ä¸€unicodeç å€¼råœ¨sä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½® func IndexByte(s string, c byte) int //è¿”å›å­—ç¬¦ä¸²sä¸­å­—ç¬¦cé¦–æ¬¡å‡ºç°ä½ç½® func IndexFunc(s string, f func(rune) bool) int //è¿”å›å­—ç¬¦ä¸²sä¸­æ»¡è¶³å‡½æ•°f(r)==trueå­—ç¬¦é¦–æ¬¡å‡ºç°çš„ä½ç½® func IndexRune(s string, r rune) int //è¿”å›unicodeç å€¼råœ¨å­—ç¬¦ä¸²ä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½® func Join(a []string, sep string) string //å°†aä¸­çš„æ‰€æœ‰å­—ç¬¦ä¸²è¿æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½¿ç”¨å­—ç¬¦ä¸²sepä½œä¸ºåˆ†éš”ç¬¦ func LastIndex(s, sep string) int //è¿”å›å­—ç¬¦ä¸²sä¸­å­—ç¬¦ä¸²sepæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½® func LastIndexAny(s, chars string) int //è¿”å›å­—ç¬¦ä¸²sä¸­ä»»æ„ä¸€ä¸ªunicodeç å€¼ræœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½® func LastIndexByte(s string, c byte) int //è¿”å›å­—ç¬¦ä¸²sä¸­å­—ç¬¦cæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½® func LastIndexFunc(s string, f func(rune) bool) int //è¿”å›å­—ç¬¦ä¸²sä¸­æ»¡è¶³å‡½æ•°f(r)==trueå­—ç¬¦æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½® func Map(mapping func(rune) rune, s string) string //å°†å­—ç¬¦ä¸²sä¸­çš„æ¯ä¸ªå­—ç¬¦ræŒ‰å‡½æ•°mapping(r)çš„è§„åˆ™è½¬æ¢å¹¶è¿”å› func Repeat(s string, count int) string //å°†å­—ç¬¦ä¸²sé‡å¤countæ¬¡è¿”å› func Replace(s, old, new string, n int) string //æ›¿æ¢å­—ç¬¦ä¸²sä¸­oldå­—ç¬¦ä¸ºnewå­—ç¬¦å¹¶è¿”å›ï¼Œn\u003c0æ˜¯æ›¿æ¢æ‰€æœ‰oldå­—ç¬¦ä¸² func Split(s, sep string) []string //å°†å­—ç¬¦ä¸²sä»¥sepä½œä¸ºåˆ†éš”ç¬¦è¿›è¡Œåˆ†å‰²ï¼Œåˆ†å‰²åå­—ç¬¦æœ€åå»æ‰sep func SplitAfter(s, sep string) []string //å°†å­—ç¬¦ä¸²sä»¥sepä½œä¸ºåˆ†éš”ç¬¦è¿›è¡Œåˆ†å‰²ï¼Œåˆ†å‰²åå­—ç¬¦æœ€åé™„ä¸Šsep func SplitAfterN(s, sep string, n int) []string //å°†å­—ç¬¦ä¸²sä»¥sepä½œä¸ºåˆ†éš”ç¬¦è¿›è¡Œåˆ†å‰²ï¼Œåˆ†å‰²åå­—ç¬¦æœ€åé™„ä¸Šsepï¼Œnå†³å®šè¿”å›çš„åˆ‡ç‰‡æ•° func SplitN(s, sep string, n int) []string //å°†å­—ç¬¦ä¸²sä»¥sepä½œä¸ºåˆ†éš”ç¬¦è¿›è¡Œåˆ†å‰²ï¼Œåˆ†å‰²åå­—ç¬¦æœ€åå»æ‰sepï¼Œnå†³å®šè¿”å›çš„åˆ‡ç‰‡æ•° func Title(s string) string //å°†å­—ç¬¦ä¸²sæ¯ä¸ªå•è¯é¦–å­—æ¯å¤§å†™è¿”å› func ToLower(s string) string //å°†å­—ç¬¦ä¸²sè½¬æ¢æˆå°å†™è¿”å› func ToLowerSpecial(_case unicode.SpecialCase, s string) string //å°†å­—ç¬¦ä¸²sä¸­æ‰€æœ‰å­—ç¬¦æŒ‰_caseæŒ‡å®šçš„æ˜ å°„è½¬æ¢æˆå°å†™è¿”å› func ToTitle(s string) string //å°†å­—ç¬¦ä¸²sè½¬æ¢æˆå¤§å†™è¿”å› func ToTitleSpecial(_case unicode.SpecialCase, s string) string //å°†å­—ç¬¦ä¸²sä¸­æ‰€æœ‰å­—ç¬¦æŒ‰_caseæŒ‡å®šçš„æ˜ å°„è½¬æ¢æˆå¤§å†™è¿”å› func ToUpper(s string) string //å°†å­—ç¬¦ä¸²sè½¬æ¢æˆå¤§å†™è¿”å› func ToUpperSpecial(_case unicode.SpecialCase, s string) string //å°†å­—ç¬¦ä¸²sä¸­æ‰€æœ‰å­—ç¬¦æŒ‰_caseæŒ‡å®šçš„æ˜ å°„è½¬æ¢æˆå¤§å†™è¿”å› func Trim(s string, cutset string) string //å°†å­—ç¬¦ä¸²sä¸­é¦–å°¾åŒ…å«cutsetä¸­çš„ä»»ä¸€å­—ç¬¦å»æ‰è¿”å› func TrimFunc(s string, f func(rune) bool) string //å°†å­—ç¬¦ä¸²sé¦–å°¾æ»¡è¶³å‡½æ•°f(r)==trueçš„å­—ç¬¦å»æ‰è¿”å› func TrimLeft(s string, cutset string) string //å°†å­—ç¬¦ä¸²så·¦è¾¹åŒ…å«cutsetä¸­çš„ä»»ä¸€å­—ç¬¦å»æ‰è¿”å› func TrimLeftFunc(s string, f func(rune) bool) string //å°†å­—ç¬¦ä¸²så·¦è¾¹æ»¡è¶³å‡½æ•°f(r)==trueçš„å­—ç¬¦å»æ‰è¿”å› func TrimPrefix(s, prefix string) string //å°†å­—ç¬¦ä¸²sä¸­å‰ç¼€å­—ç¬¦ä¸²prefixå»æ‰è¿”å› func TrimRight(s string, cutset string) string //å°†å­—ç¬¦ä¸²så³è¾¹åŒ…å«cutsetä¸­çš„ä»»ä¸€å­—ç¬¦å»æ‰è¿”å› func TrimRightFunc(s string, f func(rune) bool) string //å°†å­—ç¬¦ä¸²så³è¾¹æ»¡è¶³å‡½æ•°f(r)==trueçš„å­—ç¬¦å»æ‰è¿”å› func TrimSpace(s string) string //å°†å­—ç¬¦ä¸²sé¦–å°¾ç©ºç™½å»æ‰è¿”å› func TrimSuffix(s, suffix string) string //å°†å­—ç¬¦ä¸²sä¸­åç¼€å­—ç¬¦ä¸²prefixå»æ‰è¿”å› ","date":"2023-04-06","objectID":"/golang-quick/:8:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2 æ–‡ä»¶æ“ä½œ ä½¿ç”¨ io/ioutil è¿›è¡Œè¯»å†™æ“ä½œ ä½¿ç”¨ OS è¿›è¡Œè¯»å†™æ“ä½œ ","date":"2023-04-06","objectID":"/golang-quick/:9:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2.1 io/ioutil è¿›è¡Œè¯»å†™æ“ä½œ è¯»æ–‡ä»¶ï¼š package main import ( \"fmt\" \"io/ioutil\" ) func main() { b, err := ioutil.ReadFile(\"e:/tt.txt\") if err != nil { fmt.Println(err) } fmt.Println(b) str := string(b) fmt.Println(str) } å†™æ–‡ä»¶ï¼š package main import ( \"io/ioutil\" ) func check(e error) { if e != nil { panic(e) } } func main() { d1 := []byte(\"hello\\ngo\\n\") err := ioutil.WriteFile(\"e:tt2.txt\", d1, 0644) check(err) } ","date":"2023-04-06","objectID":"/golang-quick/:9:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"2.2 ä½¿ç”¨ OS è¯»å†™æ–‡ä»¶ å¸¦ç¼“å†²çš„å¤§æ–‡ä»¶è¯»å–ï¼š var path = \"...\" var savePath = \"...\" file, err := os.Open(path) defer file.Close() if err != nil { log.Println(\"æ–‡ä»¶æ‰“å¼€å¤±è´¥!\") } buf := bufio.NewReader(file) for { line, err := buf.ReadBytes('\\n') if err == io.EOF { log.Println(\"è¯»æ–‡ä»¶ç»“æŸï¼\") break } if err != nil { log.Println(\"è¯»æ–‡ä»¶å¤±è´¥:\", err) } } å†™æ–‡ä»¶ï¼š file, err := os.OpenFile(\"test.txt\", os.O_WRONLY | os.O_CREATE | os.O_APPEND, 0600) if err != nil { fmt.Println(\"æ‰“å¼€æ–‡ä»¶å¤±è´¥; err=\",err) return } defer file.Close() // ä½¿ç”¨ç¼“å†²çš„æ–¹å¼å†™å­—ç¬¦ä¸²åˆ°æ–‡ä»¶ writer := bufio.NewWriter(file) for i:=0; i\u003c3; i++ { if _, err := writer.WriteString(\"Hello åŒ—äº¬\"+\"\\n\"); err != nil { fmt.Println(\"æ–‡ä»¶å†™å…¥å¤±è´¥, err=\", err) break } } // ä½¿ç”¨ç¼“å†²çš„æ–¹å¼å†™byteåˆ‡ç‰‡åˆ°æ–‡ä»¶ sli := []byte(\"Hello åŒ—äº¬\\n\") for i:=0; i\u003c 3; i++ { if _, err := writer.Write(sli); err != nil { fmt.Println(\"æ–‡ä»¶å†™å…¥å¤±è´¥, err=\", err) break } } writer.Flush() ","date":"2023-04-06","objectID":"/golang-quick/:9:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3 Json å‚è€ƒ: golang å¼€æº json åº“ä½¿ç”¨ç¬”è®° encoding/json, å®˜æ–¹è‡ªå¸¦çš„, æ–‡æ¡£æœ€å¤š, æ˜“ç”¨æ€§å·®, æ€§èƒ½å·® go-simplejson, gabs, jason ç­‰è¡ç”ŸåŒ…, ç®€å•ä¸”æ˜“ç”¨, æ˜“äºé˜…è¯», ä¾¿äºç»´æŠ¤, ä½†æ€§èƒ½æœ€å·® easyjson, ffjson æ­¤ç±»åŒ…, é€‚åˆå›ºå®šç»“æ„çš„ json, æ˜“ç”¨æ€§ä¸€èˆ¬, ç»´æŠ¤æˆæœ¬é«˜, æ€§èƒ½ç‰¹åˆ«å¥½ jsonparser é€‚åˆåŠ¨æ€å’Œå›ºå®šç»“æ„çš„ json, ç®€å•ä¸”æ˜“ç”¨, ç»´æŠ¤æˆæœ¬ä½, æ€§èƒ½æå¥½ ","date":"2023-04-06","objectID":"/golang-quick/:10:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3.1 encoding/json func Marshal(v interface{}) ([]byte, error) // å°†Goä¸­æ•°æ®ç±»å‹è½¬æ¢ä¸º json å­—ç¬¦ä¸²çš„å­—èŠ‚åˆ‡ç‰‡ func Unmarshal(data []byte, v interface{}) error // ååºåˆ—åŒ–jsonå­—ç¬¦ä¸² func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error //ç¼©è¿›æ˜¾ç¤ºjsonå­—ç¬¦ä¸² func Compact(dst *bytes.Buffer, src []byte) error //å‹ç¼©æ— æ•ˆç©ºç™½ç¬¦ åºåˆ—åŒ–ï¼š package main import ( \"encoding/json\" \"fmt\" ) type Student struct { Id int `json:\"id\"` Name string `json:\"name\"` Hobby []Hobby } type Hobby struct { Name string describe string } func main() { var s0 = Student{ Id: 10001, Name: \"å¼ ä¸‰\", Hobby: []Hobby{ { Name: \"æ¸¸æ³³\", describe: \"æ¸¸æ³³ã€‚ã€‚ã€‚ã€‚\", }, { Name: \"é’“é±¼\", describe: \"å°é’“\", }, }, } ret, err := json.Marshal(\u0026s0) if err != nil { fmt.Println(\"åºåˆ—åŒ–å¤±è´¥\") return } fmt.Println(string(ret)) } // è¾“å‡ºï¼š{\"id\":10001,\"name\":\"å¼ ä¸‰\",\"Hobby\":[{\"Name\":\"æ¸¸æ³³\"},{\"Name\":\"é’“é±¼\"}]} ååºåˆ—åŒ–ï¼š package main import ( \"encoding/json\" \"fmt\" ) type User struct { Name string `json:\"name\"` Class []string `json:\"class\"` } func main() { str := `{\"10001\": {\"name\": \"å¼ ä¸‰\", \"class\": [\"ç‰©ç†\",\"åŒ–å­¦\",\"ç”Ÿç‰©\"]}}` var user01 interface{} if err := json.Unmarshal([]byte(str), \u0026user01); err != nil { fmt.Println(\"ååºåˆ—åŒ–å¤±è´¥,err=\", err) return } fmt.Printf(\"type:%T, value:%v\\n\", user01, user01) // ä½¿ç”¨ç±»å‹æ–­è¨€æ‰èƒ½å–å€¼ if user, ok := user01.(map[string]interface {}); ok { fmt.Printf(\"type:%T, value:%v\\n\", user[\"10001\"], user[\"10001\"]) } } ","date":"2023-04-06","objectID":"/golang-quick/:10:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"3.2 simplejson å¸¸ç”¨æ–¹æ³• å¸¸ç”¨äºä¸éœ€è¦åˆ›å»ºç»“æ„ä½“æ—¶ï¼Œé‡‡ç”¨é“¾å¼è°ƒç”¨å®Œæˆå¤„ç†ã€‚ # \"github.com/bitly/go-simplejson\" 1. Json ç»“æ„ä½“ type Json struct { // contains filtered or unexported fields } 2. æ„é€ å‡½æ•° func NewJson(body []byte) (*Json, error) 3. ä» io.Reader æ¥å£æ„é€  Jsonå¯¹è±¡ func NewFromReader(r io.Reader) (*Json, error) 4. æ–­è¨€ç›¸å…³çš„æ–¹æ³• func (j *Json) String() (string, error) func (j *Json) Int() (int, error) func (j *Json) Int64() (int64, error) func (j *Json) Uint64() (uint64, error) func (j *Json) Bool() (bool, error) func (j *Json) Bytes() ([]byte, error) func (j *Json) StringArray() ([]string, error) func (j *Json) Interface() interface{} func (j *Json) Map() (map[string]interface{}, error) func (j *Json) Array() ([]interface{}, error) 5. ä¿è¯è¿”å›æŒ‡å®šç±»å‹çš„ç»“æœ, args è®¾å®šé»˜è®¤å€¼ func (j *Json) MustInt(args ...int) int func (j *Json) MustString(args ...string) string func (j *Json) MustFloat64(args ...float64) float64 func (j *Json) MustBool(args ...bool) bool func (j *Json) MustStringArray(args ...[]string) []string func (j *Json) MustMap(args ...map[string]interface{}) map[string]interface{} func (j *Json) MustArray(args ...[]interface{}) []interface{} 6. åœ¨mapç±»å‹ä¸­ï¼Œæ ¹æ®keyå–å€¼ func (j *Json) Get(key string) *Json 7. æ›´æ–°json func (j *Json) Del(key string) func (j *Json) Set(key string, val interface{}) 8. åºåˆ—åŒ– func (j *Json) Encode() ([]byte, error) func (j *Json) EncodePretty() ([]byte, error) // å¸¦ç¼©è¿› æ¡ˆä¾‹ï¼š json å­—ç¬¦ä¸²ï¼š { \"deploy_type\":\"task\", \"uniqid\":\"task-01\", \"labels\":{ \"deploy_type\":\"db\" }, \"callback_url\":\"https://xxx.xxx.xxx\", \"tasks\":[ { \"cluster_type\":\"vm_cluster\", \"deploy_type\":\"vm_cluster\", \"action\":\"create\", \"labels\":{ \"deploy_type\":\"cluster\" }, \"uniqid\":\"cluster01\", \"name\":\"cluster01\", \"options\":{ \"cadvisor\":true } } ] } 3.2.1 å–å€¼ func main() { sJson, err := simplejson.NewJson([]byte(str)) if err != nil { fmt.Printf(\"New json failed, err:%s\\n\", err.Error()) return } // å–labels res1 := sJson.Get(\"labels\").Get(\"deploy_type\").MustString(\"null\") tmp1, _ := json.Marshal(sJson.Get(\"tasks\").MustArray()[0]) // è¿”å›å€¼ä¸º interfaceï¼Œéœ€è¦é‡æ–°åºåˆ—åŒ– tmp2, _ := simplejson.NewJson(tmp1) res2 := tmp2.Get(\"labels\").Get(\"deploy_type\").MustString() fmt.Printf(\"res1:%s,res2:%s\\n\", res1, res2) } 3.2.2 ä¿®æ”¹å€¼ func main() { sJson, err := simplejson.NewJson([]byte(str)) if err != nil { fmt.Printf(\"New json failed, err:%s\\n\", err.Error()) return } // åˆ é™¤å€¼ sJson.Del(\"tasks\") // åˆ é™¤taskå­—æ®µ res1, _:= sJson.EncodePretty() fmt.Println(string(res1)) // ä¿®æ”¹å€¼ sJson.Set(\"labels\", false) // ä¿®æ”¹labelså­—æ®µ res2, _:= sJson.EncodePretty() fmt.Println(string(res2)) } ","date":"2023-04-06","objectID":"/golang-quick/:10:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4 csv ","date":"2023-04-06","objectID":"/golang-quick/:11:0","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4.1 æµå¼è¯»æ–‡ä»¶ func readCsv() { file, err := os.Open(\"./test.csv\") if err != nil { panic(err.Error()) } defer file.Close() reader := csv.NewReader(file) //è‹¥è¦ä¿®æ”¹åˆ†éš”ç¬¦ï¼Œåˆ™å¯ä½¿ç”¨ï¼šreader.Comma='\\t' ; for { read, err := reader.Read() //æ¯æ¬¡è¯»ä¸€è¡Œï¼Œè¿”å›ä¸€ä¸ªåˆ‡ç‰‡ if err == io.EOF { break } if err != nil { panic(err.Error()) } fmt.Println(read) } } ","date":"2023-04-06","objectID":"/golang-quick/:11:1","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"},{"categories":["Golang"],"content":"4.2 å†™æ–‡ä»¶ func writeCsv() { file, err := os.OpenFile(\"./test.csv\", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666) //0666æ˜¯linuxçš„æ–‡ä»¶æƒé™è®¾å®šï¼ˆ0777ï¼š-rwxrwxrwx ï¼›0666ï¼š-rw-rw-rw-ï¼‰ if err != nil { panic(err.Error()) } defer file.Close() writer := csv.NewWriter(file) data := [][]string{{\"2\", \"3\", \"sdasd\"}} for _, v := range data { err := writer.Write(v) if err != nil { panic(err.Error()) } } writer.Flush() fmt.Println(\"write succï¼\") } ","date":"2023-04-06","objectID":"/golang-quick/:11:2","tags":["Golang"],"title":"Golangæé€Ÿä¸Šæ‰‹","uri":"/golang-quick/"}]