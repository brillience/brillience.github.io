[{"categories":["Golang","设计模式"],"content":"设计模式golang实现","date":"2023-04-06","objectID":"/design_pattern/","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"设计模式 6 大原则 golang 设计模式 ** 设计模式（Design pattern）**是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 ","date":"2023-04-06","objectID":"/design_pattern/:1:0","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"1. 开闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。 优点： 复用性高 易维护 ","date":"2023-04-06","objectID":"/design_pattern/:1:1","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"2. 里氏代换原则 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类和子类对象的区别。也就是说，在软件里面，把父类替换成它的子类，程序的行为没有变化。 优点： 需求变化时，只须继承，而别的东西不会改变。由于里氏代换原则才使得开放封闭成为可能。这样使得子类在父类无需修改的话就可以扩展。 ","date":"2023-04-06","objectID":"/design_pattern/:1:2","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"3. 单一职责原则 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 ","date":"2023-04-06","objectID":"/design_pattern/:1:3","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"4. 依赖倒置原则 程序要依赖于抽象接口，不要依赖于具体实现。 优点： 降低类之间的耦合性 提高系统的稳定性 增加代码的可维护性 ","date":"2023-04-06","objectID":"/design_pattern/:1:4","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"5. 接口隔离原则 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 优点： 提高系统的灵活性和可维护性 ","date":"2023-04-06","objectID":"/design_pattern/:1:5","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"6. 最少知识法则（迪米莱法则） 一个软件实体应当尽可能少地与其他实体发生相互作用。 ","date":"2023-04-06","objectID":"/design_pattern/:1:6","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"创建型模式 ","date":"2023-04-06","objectID":"/design_pattern/:2:0","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"简单工厂模式 go 语言没有构造函数一说，所以一般会定义 NewXXX 函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说 Golang 的一般推荐做法就是简单工厂。 在这个 simplefactory 包中只有 API 接口和 NewAPI 函数为包外可见，封装了实现细节。 simple.go 代码: package simplefactory import \"fmt\" //API is interface type API interface { Say(name string) string } //NewAPI return Api instance by type func NewAPI(t int) API { if t == 1 { return \u0026hiAPI{} } else if t == 2 { return \u0026helloAPI{} } return nil } //hiAPI is one of API implement type hiAPI struct{} //Say hi to name func (*hiAPI) Say(name string) string { return fmt.Sprintf(\"Hi, %s\", name) } //HelloAPI is another API implement type helloAPI struct{} //Say hello to name func (*helloAPI) Say(name string) string { return fmt.Sprintf(\"Hello, %s\", name) } simple_test.go 代码 package simplefactory import \"testing\" //TestType1 test get hiapi with factory func TestType1(t *testing.T) { api := NewAPI(1) s := api.Say(\"Tom\") if s != \"Hi, Tom\" { t.Fatal(\"Type1 test fail\") } } func TestType2(t *testing.T) { api := NewAPI(2) s := api.Say(\"Tom\") if s != \"Hello, Tom\" { t.Fatal(\"Type2 test fail\") } } ","date":"2023-04-06","objectID":"/design_pattern/:2:1","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"工厂方法模式 简单工厂模式只能生产单一的产品（该产品的实现细节对外不可见）。 工厂方法模式可以生产多种产品，所有产品的共性由产品基类实现，产品之间的个性由产品基类的子类实现。即：创建过程延迟到子类进行 factorymethod.go //产品基类接口 type Operator interface { SetA(int) SetB(int) Result() int } //产品基类 实现产品的共性 //OperatorBase 是Operator 接口实现的基类，封装公用方法 type OperatorBase struct { a, b int } //SetA 设置 A func (o *OperatorBase) SetA(a int) { o.a = a } //SetB 设置 B func (o *OperatorBase) SetB(b int) { o.b = b } //个性产品实现 //PlusOperator Operator 的实际加法实现 type PlusOperator struct { *OperatorBase } //Result 获取结果 func (o PlusOperator) Result() int { return o.a + o.b } //此时，PlusOperator 就是一个 Operator 的 “个性产品” //工厂实现 //OperatorFactory 是工厂接口 type OperatorFactory interface { Create() Operator } //PlusOperatorFactory 是 PlusOperator 的工厂类 type PlusOperatorFactory struct{} func (PlusOperatorFactory) Create() Operator { return \u0026PlusOperator{ OperatorBase: \u0026OperatorBase{}, } } factorymethod_test.go package factorymethod import \"testing\" func compute(factory OperatorFactory, a, b int) int { op := factory.Create() op.SetA(a) op.SetB(b) return op.Result() } func TestOperator(t *testing.T) { var ( factory OperatorFactory ) factory = PlusOperatorFactory{} if compute(factory, 1, 2) != 3 { t.Fatal(\"error with factory method pattern\") } factory = MinusOperatorFactory{} if compute(factory, 4, 2) != 2 { t.Fatal(\"error with factory method pattern\") } } ","date":"2023-04-06","objectID":"/design_pattern/:2:2","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。 如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。 比如本例子中使用 RDB 和 XML 存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。 如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。 abstractfactory.go package AbstractFactory import \"fmt\" //DAOFactory DAO 抽象模式工厂接口 type DAOFactory interface { CreateOrderMainDAO() OrderMainDAO CreateOrderDetailDAO() OrderDetailDAO } //OrderMainDAO 为订单主记录 type OrderMainDAO interface { SaveOrderMain() } //OrderDetailDAO 为订单详情纪录 type OrderDetailDAO interface { SaveOrderDetail() } //RDBMainDAP 为关系型数据库的OrderMainDAO实现 type RDBMainDAO struct{} //SaveOrderMain ... func (*RDBMainDAO) SaveOrderMain() { fmt.Print(\"rdb main save\\n\") } //RDBDetailDAO 为关系型数据库的OrderDetailDAO实现 type RDBDetailDAO struct{} // SaveOrderDetail ... func (*RDBDetailDAO) SaveOrderDetail() { fmt.Print(\"rdb detail save\\n\") } //RDBDAOFactory 是RDB 抽象工厂实现 type RDBDAOFactory struct{} func (*RDBDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026RDBMainDAO{} } func (*RDBDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026RDBDetailDAO{} } //XMLMainDAO XML存储 type XMLMainDAO struct{} //SaveOrderMain ... func (*XMLMainDAO) SaveOrderMain() { fmt.Print(\"xml main save\\n\") } //XMLDetailDAO XML存储 type XMLDetailDAO struct{} // SaveOrderDetail ... func (*XMLDetailDAO) SaveOrderDetail() { fmt.Print(\"xml detail save\") } //XMLDAOFactory 是RDB 抽象工厂实现 type XMLDAOFactory struct{} func (*XMLDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026XMLMainDAO{} } func (*XMLDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026XMLDetailDAO{} } abstractfactory_test.go package abstractfactory func getMainAndDetail(factory DAOFactory) { factory.CreateOrderMainDAO().SaveOrderMain() factory.CreateOrderDetailDAO().SaveOrderDetail() } func ExampleRdbFactory() { var factory DAOFactory factory = \u0026RDBDAOFactory{} getMainAndDetail(factory) // Output: // rdb main save // rdb detail save } func ExampleXmlFactory() { var factory DAOFactory factory = \u0026XMLDAOFactory{} getMainAndDetail(factory) // Output: // xml main save // xml detail save } ","date":"2023-04-06","objectID":"/design_pattern/:2:3","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"创建者模式 创建者模式：将一个复杂对象的构建分离成多个简单对象的构建组合 package Builder //Builder 是生成器接口 type Builder interface { Part1() Part2() Part3() } type Director struct { builder Builder } // NewDirector ... func NewDirector(builder Builder) *Director { return \u0026Director{ builder: builder, } } //Construct Product func (d *Director) Construct() { d.builder.Part1() d.builder.Part2() d.builder.Part3() } type Builder1 struct { result string } func (b *Builder1) Part1() { b.result += \"1\" } func (b *Builder1) Part2() { b.result += \"2\" } func (b *Builder1) Part3() { b.result += \"3\" } func (b *Builder1) GetResult() string { return b.result } type Builder2 struct { result int } func (b *Builder2) Part1() { b.result += 1 } func (b *Builder2) Part2() { b.result += 2 } func (b *Builder2) Part3() { b.result += 3 } func (b *Builder2) GetResult() int { return b.result } package Builder import \"testing\" func TestBuilder1(t *testing.T) { builder := \u0026Builder1{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != \"123\" { t.Fatalf(\"Builder1 fail expect 123 acture %s\", res) } } func TestBuilder2(t *testing.T) { builder := \u0026Builder2{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != 6 { t.Fatalf(\"Builder2 fail expect 6 acture %d\", res) } } ","date":"2023-04-06","objectID":"/design_pattern/:2:4","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 package ProtoType //Cloneable 是原型对象需要实现的接口 type Cloneable interface { Clone() Cloneable } type PrototypeManager struct { prototypes map[string]Cloneable } func NewPrototypeManager() *PrototypeManager { return \u0026PrototypeManager{ prototypes: make(map[string]Cloneable), } } func (p *PrototypeManager) Get(name string) Cloneable { return p.prototypes[name] } func (p *PrototypeManager) Set(name string, prototype Cloneable) { p.prototypes[name] = prototype } package ProtoType import \"testing\" var manager *PrototypeManager type Type1 struct { name string } func (t *Type1) Clone() Cloneable { tc := *t return \u0026tc } type Type2 struct { name string } func (t *Type2) Clone() Cloneable { tc := *t return \u0026tc } func TestClone(t *testing.T) { t1 := manager.Get(\"t1\") t2 := t1.Clone() if t1 == t2 { t.Fatal(\"error! get clone not working\") } } func TestCloneFromManager(t *testing.T) { c := manager.Get(\"t1\").Clone() t1 := c.(*Type1) if t1.name != \"type1\" { t.Fatal(\"error\") } } func init() { manager = NewPrototypeManager() t1 := \u0026Type1{ name: \"type1\", } manager.Set(\"t1\", t1) } ","date":"2023-04-06","objectID":"/design_pattern/:2:5","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"单例模式 **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。 **主要解决：**一个全局使用的类频繁地创建与销毁。 **何时使用：**当您想控制实例数目，节省系统资源的时候。 **如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 使用懒惰模式的单例模式，使用双重检查加锁保证线程安全 package Singleton import \"sync\" //Singleton 是单例模式类 type Singleton struct{} var singleton *Singleton var once sync.Once //GetInstance 用于获取单例模式对象 func GetInstance() *Singleton { once.Do(func() { singleton = \u0026Singleton{} }) return singleton } package Singleton import ( \"sync\" \"testing\" ) const parCount = 100 func TestSingleton(t *testing.T) { ins1 := GetInstance() ins2 := GetInstance() if ins1 != ins2 { t.Fatal(\"instance is not equal\") } } func TestParallelSingleton(t *testing.T) { wg := sync.WaitGroup{} wg.Add(parCount) instances := [parCount]*Singleton{} for i := 0; i \u003c parCount; i++ { go func(index int) { instances[index] = GetInstance() wg.Done() }(i) } wg.Wait() for i := 1; i \u003c parCount; i++ { if instances[i] != instances[i-1] { t.Fatal(\"instance is not equal\") } } } ","date":"2023-04-06","objectID":"/design_pattern/:2:6","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"结构型模式 ","date":"2023-04-06","objectID":"/design_pattern/:3:0","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"代理模式 结构型模式：描述如何将类或对象按照某种方式组织成更大的结构。 客户端不直接声明真实主体，而是声明代理类，通过调用代理类的方法来间接执行真实主体类的行为。 package proxy type Subject interface { Do() string } type RealSubject struct{} func (RealSubject) Do() string { return \"real\" } type Proxy struct { real RealSubject } func (p Proxy) Do() string { var res string // 在调用真实对象之前的工作，检查缓存，判断权限，实例化真实对象等。。 res += \"pre:\" // 调用真实对象 res += p.real.Do() // 调用之后的操作，如缓存结果，对结果进行处理等。。 res += \":after\" return res } ","date":"2023-04-06","objectID":"/design_pattern/:3:1","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"适配器模式 适配器模式（Adapter Pattern）将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 说白了就是让适配者的实现类，同时实现适配器的接口和目标类的接口。 package adapter //Target 是适配的目标接口 type Target interface { Request() string } //Adaptee 是被适配的目标接口 type Adaptee interface { SpecificRequest() string } //NewAdaptee 是被适配接口的工厂函数 func NewAdaptee() Adaptee { return \u0026adapteeImpl{} } //AdapteeImpl 是被适配的目标类 type adapteeImpl struct{} //SpecificRequest 是目标类的一个方法 func (*adapteeImpl) SpecificRequest() string { return \"adaptee method\" } //NewAdapter 是Adapter的工厂函数 func NewAdapter(adaptee Adaptee) Target { return \u0026adapter{ Adaptee: adaptee, } } //Adapter 是转换Adaptee为Target接口的适配器 type adapter struct { Adaptee } //Request 实现Target接口 func (a *adapter) Request() string { return a.SpecificRequest() } ","date":"2023-04-06","objectID":"/design_pattern/:3:2","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"桥接模式 桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接（Bridge）模式的优点是： 抽象与实现分离，扩展能力强 符合开闭原则 符合合成复用原则 其实现细节对客户透明 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。 package bridge import \"fmt\" // 抽象消息 type AbstractMessage interface { SendMessage(text, to string) } //消息的实施者 type MessageImplementer interface { Send(text, to string) } type MessageSMS struct{} //不同的功能；这些功能都要返回消息的实施者这个接口 func ViaSMS() MessageImplementer { return \u0026MessageSMS{} } func (*MessageSMS) Send(text, to string) { fmt.Printf(\"send %s to %s via SMS\", text, to) } type MessageEmail struct{} //不同的功能 func ViaEmail() MessageImplementer { return \u0026MessageEmail{} } func (*MessageEmail) Send(text, to string) { fmt.Printf(\"send %s to %s via Email\", text, to) } type CommonMessage struct { method MessageImplementer } func NewCommonMessage(method MessageImplementer) *CommonMessage { return \u0026CommonMessage{ method: method, } } func (m *CommonMessage) SendMessage(text, to string) { m.method.Send(text, to) } type UrgencyMessage struct { method MessageImplementer } func NewUrgencyMessage(method MessageImplementer) *UrgencyMessage { return \u0026UrgencyMessage{ method: method, } } func (m *UrgencyMessage) SendMessage(text, to string) { m.method.Send(fmt.Sprintf(\"[Urgency] %s\", text), to) } ","date":"2023-04-06","objectID":"/design_pattern/:3:3","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"装饰器模式 装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。 装饰器模式的主要优点有： 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果 装饰器模式完全遵守开闭原则 其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。 package decorator // 组件接口 type Component interface { Calc() int } // 具体组件 type ConcreteComponent struct{} func (*ConcreteComponent) Calc() int { return 0 } //乘法装饰器 type MulDecorator struct { Component num int } func WarpMulDecorator(c Component, num int) Component { return \u0026MulDecorator{ Component: c, num: num, } } func (d *MulDecorator) Calc() int { return d.Component.Calc() * d.num } //加法装饰器 type AddDecorator struct { Component num int } func WarpAddDecorator(c Component, num int) Component { return \u0026AddDecorator{ Component: c, num: num, } } func (d *AddDecorator) Calc() int { return d.Component.Calc() + d.num } ","date":"2023-04-06","objectID":"/design_pattern/:3:4","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"外观模式 外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。 外观（Facade）模式的主要缺点如下。 不能很好地限制客户使用子系统类，很容易带来未知风险。 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 package main import ( \"fmt\" ) type DataHandler struct { decoder *Decoder //解码子系统 handler *MainHandler //处理子系统 encoder *Encoder //编码子系统 } func (pD *DataHandler) Working() { pD.decoder.Working() pD.handler.Working() pD.encoder.Working() } type Decoder struct { } func (pD *Decoder) Working() { fmt.Println(\"解码子系统先XXX格式数据,并转换为xxxx结构数据\") } type MainHandler struct { } func (pM *MainHandler) Working() { fmt.Println(\"数据处理子系统，处理数据\") } type Encoder struct { } func (pE *Encoder) Working() { fmt.Println(\"编码子系统将xxx数据格式转换为Json格式\") } func main() { worker := \u0026DataHandler{decoder: \u0026Decoder{}, handler: \u0026MainHandler{}, encoder: \u0026Encoder{}} worker.Working() return } ","date":"2023-04-06","objectID":"/design_pattern/:3:5","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"享元模式 享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。 享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 其主要缺点是： 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新的对象。 //Shape 模型接口 type Shape interface { Draw() } //Circle 圆形类 type Circle struct { X int Y int Radius int Color string } //NewCircle 实例化圆形类 func NewCircle(color string) *Circle { return \u0026Circle{ Color: color, } } //SetX 设置圆形类的x轴 func (c *Circle) SetX(x int) { c.X = x } //SetY 设置圆形类的y轴 func (c *Circle) SetY(y int) { c.Y = y } //SetRadius 设置圆形类的半径 func (c *Circle) SetRadius(radius int) { c.Radius = radius } //Draw 圆形类的Draw方法，实现Shape接口 func (c *Circle) Draw() { fmt.Printf(\"Circle Draw() [Color: %s, x: %d, y: %d, radius: %d] \\n\", c.Color, c.X, c.Y, c.Radius) } //ShapeFactory 模型工厂类，包含一个circle的map type ShapeFactory struct { circleMap map[string]Shape } //NewShapeFactory 实例化模型工厂类 func NewShapeFactory() *ShapeFactory { return \u0026ShapeFactory{ circleMap: make(map[string]Shape), } } //GetCircle 获取一个圆形实例 //color: 需要获取实例的颜色 func (sf *ShapeFactory) GetCircle(color string) Shape { circle := sf.circleMap[color] if circle == nil { circle = NewCircle(color) sf.circleMap[color] = circle fmt.Println(\"Creating circleof color: \", color) } return circle } ","date":"2023-04-06","objectID":"/design_pattern/:3:6","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"组合模式 组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型设计模式。 组合模式的主要优点有： 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 其主要缺点是： 设计较复杂，客户端需要花更多时间理清类之间的层次关系； 不容易限制容器中的构件； 不容易用继承的方法来增加构件的新功能； package composite import ( \"container/list\" \"reflect\" \"strconv\" ) //Employee 职员类 type Employee struct { Name string Dept string Salary int Subordinates *list.List } //NewEmployee 实例化职员类 func NewEmployee(name, dept string, salary int) *Employee { sub := list.New() return \u0026Employee{ Name: name, Dept: dept, Salary: salary, Subordinates: sub, } } //Add 添加职员的下属 func (e *Employee) Add(emp Employee) { e.Subordinates.PushBack(emp) } //Remove 删除职员的下属 func (e *Employee) Remove(emp Employee) { for i := e.Subordinates.Front(); i != nil; i = i.Next() { if reflect.DeepEqual(i.Value, emp) { e.Subordinates.Remove(i) } } } //GetSubordinates 获取职员下属列表 func (e *Employee) GetSubordinates() *list.List { return e.Subordinates } //ToString 获取职员的string信息 func (e *Employee) ToString() string { return \"[ Name: \" + e.Name + \", dept: \" + e.Dept + \", Salary: \" + strconv.Itoa(e.Salary) + \" ]\" } ","date":"2023-04-06","objectID":"/design_pattern/:3:7","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"行为型模式 ","date":"2023-04-06","objectID":"/design_pattern/:4:0","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"责任链模式 责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 注意：责任链模式也叫职责链模式。 责任链模式是一种对象行为型模式，其主要优点如下。 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。 其主要缺点如下。 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 // Package chain_of_responsibility is an example of the Chain Of Responsibility Pattern. package chain_of_responsibility // Handler provides a handler interface. type Handler interface { SendRequest(message int) string } // ConcreteHandlerA implements handler \"A\". type ConcreteHandlerA struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerA) SendRequest(message int) (result string) { if message == 1 { result = \"Im handler 1\" } else if h.next != nil { result = h.next.SendRequest(message) } return } // ConcreteHandlerB implements handler \"B\". type ConcreteHandlerB struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerB) SendRequest(message int) (result string) { if message == 2 { result = \"Im handler 2\" } else if h.next != nil { result = h.next.SendRequest(message) } return } // ConcreteHandlerC implements handler \"C\". type ConcreteHandlerC struct { next Handler } // SendRequest implementation. func (h *ConcreteHandlerC) SendRequest(message int) (result string) { if message == 3 { result = \"Im handler 3\" } else if h.next != nil { result = h.next.SendRequest(message) } return } ","date":"2023-04-06","objectID":"/design_pattern/:4:1","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"命令模式 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。 命令模式的主要优点如下。 通过引入中间件（抽象接口）降低系统的耦合度。 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。 其缺点是： 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。 package command import \"fmt\" // 命令接口 type Command interface { Execute() } // 开启命令 type StartCommand struct { mb *MotherBoard } func NewStartCommand(mb *MotherBoard) *StartCommand { return \u0026StartCommand{ mb: mb, } } func (c *StartCommand) Execute() { c.mb.Start() } // 重启命令 type RebootCommand struct { mb *MotherBoard } func NewRebootCommand(mb *MotherBoard) *RebootCommand { return \u0026RebootCommand{ mb: mb, } } func (c *RebootCommand) Execute() { c.mb.Reboot() } // 主板，它实现了所有的命令 type MotherBoard struct{} func (*MotherBoard) Start() { fmt.Print(\"system starting\\n\") } func (*MotherBoard) Reboot() { fmt.Print(\"system rebooting\\n\") } // 盒子里装了所有命令，通过按钮，执行不同的命令 type Box struct { button1 Command button2 Command } func NewBox(button1, button2 Command) *Box { return \u0026Box{ button1: button1, button2: button2, } } func (b *Box) PressButton1() { b.button1.Execute() } func (b *Box) PressButton2() { b.button2.Execute() } ","date":"2023-04-06","objectID":"/design_pattern/:4:2","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"解释器模式 在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。 解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 优点： 可拓展性高，灵活 易于实现简单的文法 缺点： 可使用场景少 对于复杂的文法较难维护 解释器模式会引起类膨胀 解释器模式采用递归调用的方法 //Expression 语句接口 type Expression interface { Interpret(context string) bool } //TerminalExpression 终端语句类 type TerminalExpression struct { Data string } //NewTerminalExpression 实例化终端语句类 func NewTerminalExpression(data string) *TerminalExpression { return \u0026TerminalExpression{ Data: data, } } //Interpret 终端语句类的解释器 func (te *TerminalExpression) Interpret(context string) bool { if strings.Contains(context, te.Data) { return true } return false } //OrExpression 或语句类 type OrExpression struct { Expr1 Expression Expr2 Expression } //NewOrExpression 实例化或语句 func NewOrExpression(expr1, expr2 Expression) *OrExpression { return \u0026OrExpression{ Expr1: expr1, Expr2: expr2, } } //Interpret 解释器 func (oe *OrExpression) Interpret(context string) bool { return oe.Expr1.Interpret(context) || oe.Expr2.Interpret(context) } //AndExpression 与语句类 type AndExpression struct { Expr1 Expression Expr2 Expression } //NewAndExpression 实例化与语句 func NewAndExpression(expr1, expr2 Expression) *AndExpression { return \u0026AndExpression{ Expr1: expr1, Expr2: expr2, } } //Interpret 解释器 func (ae *AndExpression) Interpret(context string) bool { return ae.Expr1.Interpret(context) \u0026\u0026 ae.Expr2.Interpret(context) } func OrExpressionTest(t *testing.T) { //规则，lee 和 wang 是男性 lee := NewTerminalExpression(\"Lee\") wang := NewTerminalExpression(\"Wang\") isMale := NewOrExpression(lee, wang) fmt.Println(\"lee is male? \", isMale.Interpret(\"Lee\")) } func AndExpressionTest(t *testing.T) { //规则，yang是已婚女性 yang := NewTerminalExpression(\"Yang\") married := NewTerminalExpression(\"Married\") isMarried := NewAndExpression(yang, married) fmt.Println(\"Yang is a married women? \", isMarried.Interpret(\"Married Yang\")) } ","date":"2023-04-06","objectID":"/design_pattern/:4:3","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"迭代器模式 迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。 访问一个聚合对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的聚合结构提供一个统一的接口。 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。 // Package iterator is an example of the Iterator Pattern. package iterator // Iterator provides a iterator interface. type Iterator interface { Index() int Value() interface{} Has() bool Next() Prev() Reset() End() } // Aggregate provides a collection interface. type Aggregate interface { Iterator() Iterator } // BookIterator implements the Iterator interface. type BookIterator struct { shelf *BookShelf index int internal int } // Index returns current index func (i *BookIterator) Index() int { return i.index } // Value returns current value func (i *BookIterator) Value() interface{} { return i.shelf.Books[i.index] } // Has implementation. func (i *BookIterator) Has() bool { if i.internal \u003c 0 || i.internal \u003e= len(i.shelf.Books) { return false } return true } // Next goes to the next item. func (i *BookIterator) Next() { i.internal++ if i.Has() { i.index++ } } // Prev goes to the previous item. func (i *BookIterator) Prev() { i.internal-- if i.Has() { i.index-- } } // Reset resets iterator. func (i *BookIterator) Reset() { i.index = 0 i.internal = 0 } // End goes to the last item. func (i *BookIterator) End() { i.index = len(i.shelf.Books) - 1 i.internal = i.index } // BookShelf implements the Aggregate interface. type BookShelf struct { Books []*Book } // Iterator creates and returns the iterator over the collection. func (b *BookShelf) Iterator() Iterator { return \u0026BookIterator{shelf: b} } // Add adds an item to the collection. func (b *BookShelf) Add(book *Book) { b.Books = append(b.Books, book) } // Book implements a item of the collection. type Book struct { Name string } package iterator import ( \"testing\" ) func TestIterator(t *testing.T) { shelf := new(BookShelf) books := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"} for _, book := range books { shelf.Add(\u0026Book{Name: book}) } for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() { index, value := iterator.Index(), iterator.Value().(*Book) if value.Name != books[index] { t.Errorf(\"Expect Book.Name to %s, but %s\", books[index], value.Name) } } } ","date":"2023-04-06","objectID":"/design_pattern/:4:4","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"中介者模式 中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 中介者模式是一种对象行为型模式，其主要优点如下。 类之间各司其职，符合迪米特法则。 降低了对象之间的耦合性，使得对象易于独立地被复用。 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。 其主要缺点是：中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。 package mediator import ( \"fmt\" \"strings\" ) type CDDriver struct { Data string } func (c *CDDriver) ReadData() { c.Data = \"music,image\" fmt.Printf(\"CDDriver: reading data %s\\n\", c.Data) GetMediatorInstance().changed(c) } type CPU struct { Video string Sound string } func (c *CPU) Process(data string) { sp := strings.Split(data, \",\") c.Sound = sp[0] c.Video = sp[1] fmt.Printf(\"CPU: split data with Sound %s, Video %s\\n\", c.Sound, c.Video) GetMediatorInstance().changed(c) } type VideoCard struct { Data string } func (v *VideoCard) Display(data string) { v.Data = data fmt.Printf(\"VideoCard: display %s\\n\", v.Data) GetMediatorInstance().changed(v) } type SoundCard struct { Data string } func (s *SoundCard) Play(data string) { s.Data = data fmt.Printf(\"SoundCard: play %s\\n\", s.Data) GetMediatorInstance().changed(s) } type Mediator struct { CD *CDDriver CPU *CPU Video *VideoCard Sound *SoundCard } var mediator *Mediator func GetMediatorInstance() *Mediator { if mediator == nil { mediator = \u0026Mediator{} } return mediator } func (m *Mediator) changed(i interface{}) { switch inst := i.(type) { case *CDDriver: m.CPU.Process(inst.Data) case *CPU: m.Sound.Play(inst.Sound) m.Video.Display(inst.Video) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:5","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"备忘录模式 备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。 备忘录模式是一种对象行为型模式，其主要优点如下。 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 //Memento 备忘录类 type Memento struct { state string } //NewMemento 实例化备忘录类 func NewMemento(st string) *Memento { return \u0026Memento{ state: st, } } //GetState 获取备忘录类的状态 func (m *Memento) GetState() string { return m.state } //Originator 初始类 type Originator struct { state string } //NewOriginator 实例化初始类 func NewOriginator(st string) *Originator { return \u0026Originator{ state: st, } } //SetState 初始化类设置状态 func (o *Originator) SetState(st string) { o.state = st } //GetState 从初始类中获取状态 func (o *Originator) GetState() string { return o.state } //SaveStateToMemento 将初始类状态保存到备忘录类 func (o *Originator) SaveStateToMemento() *Memento { return NewMemento(o.state) } //GetStateFromMemento 将备忘录类的状态读取到初始类 func (o *Originator) GetStateFromMemento(memento *Memento) { o.state = memento.GetState() } //CareTaker 保存类，用于存储备忘录实例 type CareTaker struct { MementoList map[int]*Memento } //NewCareTaker 实例化保存类 func NewCareTaker() *CareTaker { return \u0026CareTaker{ MementoList: make(map[int]*Memento), } } //Add 保存类添加备忘录实例 func (ct *CareTaker) Add(index int, memento *Memento) { ct.MementoList[index] = memento } //Get 保存类获取备忘录实例 func (ct *CareTaker) Get(index int) *Memento { return ct.MementoList[index] } ","date":"2023-04-06","objectID":"/design_pattern/:4:6","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"观察者模式 观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 观察者模式是一种对象行为型模式，其主要优点如下。 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。 目标与观察者之间建立了一套触发机制。 它的主要缺点如下。 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 package main import ( \"container/list\" ) type Subject interface { Attach(Observer) //注册观察者 Detach(Observer) //释放观察者 Notify() //通知所有注册的观察者 } type Observer interface { Update(Subject) //观察者进行更新状态 } //implements Subject type ConcreteSubject struct { observers *list.List value int } func NewConcreteSubject() *ConcreteSubject { s := new(ConcreteSubject) s.observers = list.New() return s } func (s *ConcreteSubject) Attach(observe Observer) { //注册观察者 s.observers.PushBack(observe) } func (s *ConcreteSubject) Detach(observer Observer) { //释放观察者 for ob := s.observers.Front(); ob != nil; ob = ob.Next() { if ob.Value.(*Observer) == \u0026observer { s.observers.Remove(ob) break } } } func (s *ConcreteSubject) Notify() { //通知所有观察者 for ob := s.observers.Front(); ob != nil; ob = ob.Next() { ob.Value.(Observer).Update(s) } } func (s *ConcreteSubject) setValue(value int) { s.value = value s.Notify() } func (s *ConcreteSubject) getValue() int { return s.value } /** * 具体观察者 implements Observer * */ type ConcreteObserver1 struct { } func (c *ConcreteObserver1) Update(subject Subject) { println(\"ConcreteObserver1 value is \", subject.(*ConcreteSubject).getValue()) } /** * 具体观察者 implements Observer * */ type ConcreteObserver2 struct { } func (c *ConcreteObserver2) Update(subject Subject) { println(\"ConcreteObserver2 value is \", subject.(*ConcreteSubject).getValue()) } func main() { subject := NewConcreteSubject() observer1 := new(ConcreteObserver1) observer2 := new(ConcreteObserver2) subject.Attach(observer1) subject.Attach(observer2) subject.setValue(5) } ","date":"2023-04-06","objectID":"/design_pattern/:4:7","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"状态模式 状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 状态模式是一种对象行为型模式，其主要优点如下。 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。 状态模式的主要缺点如下。 状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。 // Package state is an example of the State Pattern. package state // MobileAlertStater provides a common interface for various states. type MobileAlertStater interface { Alert() string } // MobileAlert implements an alert depending on its state. type MobileAlert struct { state MobileAlertStater } // Alert returns a alert string func (a *MobileAlert) Alert() string { return a.state.Alert() } // SetState changes state func (a *MobileAlert) SetState(state MobileAlertStater) { a.state = state } // NewMobileAlert is the MobileAlert constructor. func NewMobileAlert() *MobileAlert { return \u0026MobileAlert{state: \u0026MobileAlertVibration{}} } // MobileAlertVibration implements vibration alert type MobileAlertVibration struct { } // Alert returns a alert string func (a *MobileAlertVibration) Alert() string { return \"Vrrr... Brrr... Vrrr...\" } // MobileAlertSong implements beep alert type MobileAlertSong struct { } // Alert returns a alert string func (a *MobileAlertSong) Alert() string { return \"Белые розы, Белые розы. Беззащитны шипы...\" } package state import ( \"testing\" ) func TestState(t *testing.T) { expect := \"Vrrr... Brrr... Vrrr...\" + \"Vrrr... Brrr... Vrrr...\" + \"Белые розы, Белые розы. Беззащитны шипы...\" mobile := NewMobileAlert() result := mobile.Alert() result += mobile.Alert() mobile.SetState(\u0026MobileAlertSong{}) result += mobile.Alert() if result != expect { t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:8","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"策略模式 策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 策略模式的主要优点如下。 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if…else 语句、switch…case 语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 其主要缺点如下。 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。 策略模式造成很多的策略类，增加维护难度。 // Package strategy is an example of the Strategy Pattern. package strategy // StrategySort provides an interface for sort algorithms. type StrategySort interface { Sort([]int) } // BubbleSort implements bubble sort algorithm. type BubbleSort struct { } // Sort sorts data. func (s *BubbleSort) Sort(a []int) { size := len(a) if size \u003c 2 { return } for i := 0; i \u003c size; i++ { for j := size - 1; j \u003e= i+1; j-- { if a[j] \u003c a[j-1] { a[j], a[j-1] = a[j-1], a[j] } } } } // InsertionSort implements insertion sort algorithm. type InsertionSort struct { } // Sort sorts data. func (s *InsertionSort) Sort(a []int) { size := len(a) if size \u003c 2 { return } for i := 1; i \u003c size; i++ { var j int var buff = a[i] for j = i - 1; j \u003e= 0; j-- { if a[j] \u003c buff { break } a[j+1] = a[j] } a[j+1] = buff } } // Context provides a context for execution of a strategy. type Context struct { strategy StrategySort } // Algorithm replaces strategies. func (c *Context) Algorithm(a StrategySort) { c.strategy = a } // Sort sorts data according to the chosen strategy. func (c *Context) Sort(s []int) { c.strategy.Sort(s) } package strategy import ( \"strconv\" \"testing\" ) func TestStrategy(t *testing.T) { data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4} data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4} ctx := new(Context) ctx.Algorithm(\u0026BubbleSort{}) ctx.Sort(data1) ctx.Algorithm(\u0026InsertionSort{}) ctx.Sort(data2) expect := \"1,2,3,4,5,6,7,8,9,\" var result1 string for _, val := range data1 { result1 += strconv.Itoa(val) + \",\" } if result1 != expect { t.Errorf(\"Expect result1 to equal %s, but %s.\\n\", expect, result1) } var result2 string for _, val := range data2 { result2 += strconv.Itoa(val) + \",\" } if result2 != expect { t.Errorf(\"Expect result2 to equal %s, but %s.\\n\", expect, result2) } } ","date":"2023-04-06","objectID":"/design_pattern/:4:9","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"模板方法模式 模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 该模式的主要优点如下。 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 该模式的主要缺点如下。 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。 //Game 模板基类 type Game struct { Initialize func() StartPlay func() EndPlay func() } //Play 模板基类的Play方法 func (g Game) Play() { g.Initialize() g.StartPlay() g.EndPlay() } //FootBall 子类，继承ame类 type FootBall struct { Game } //NewFootBall 实例化football子类 func NewFootBall() *FootBall { ft := new(FootBall) ft.Game.Initialize = ft.Initialize ft.Game.StartPlay = ft.StartPlay ft.Game.EndPlay = ft.EndPlay return ft } //Initialize 子类的Initialize方法 func (ft *FootBall) Initialize() { fmt.Println(\"Football game initialize\") } //StartPlay 子类的StartPlay方法 func (ft *FootBall) StartPlay() { fmt.Println(\"Football game started.\") } //EndPlay 子类的EndPlay方法 func (ft *FootBall) EndPlay() { fmt.Println(\"Football game Finished!\") } func TemplateTest(t *testing.T) { football := NewFootBall() football.Play() fmt.Println(\"-------------------\") basketball := NewBasketball() basketball.Play() } ","date":"2023-04-06","objectID":"/design_pattern/:4:10","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang","设计模式"],"content":"访问者模式 访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。 访问者（Visitor）模式的主要缺点如下。 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。 package Visitor import \"fmt\" type IVisitor interface { Visit() } type WeiBoVisitor struct { } func (w WeiBoVisitor) Visit() { fmt.Println(\"visit weibo\") } type IQIYIVisitor struct { } func (I IQIYIVisitor) Visit() { fmt.Println(\"visit iqiyi\") } type IElement interface { Accept(visitor IVisitor) } type Element struct { } func (e Element) Accept(v IVisitor) { v.Visit() } package Visitor import \"testing\" func TestElement_Accept(t *testing.T) { e := new(Element) e.Accept(new(WeiBoVisitor)) e.Accept(new(IQIYIVisitor)) } ","date":"2023-04-06","objectID":"/design_pattern/:4:11","tags":["Golang","设计模式"],"title":"设计模式","uri":"/design_pattern/"},{"categories":["Golang"],"content":"快速掌握golang的语法知识","date":"2023-04-06","objectID":"/golang_quick/","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"代码规范 ","date":"2023-04-06","objectID":"/golang_quick/:1:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1. 为什么需要代码规范 代码规范不是强制的，也就是你不遵循代码规范写出来的代码运行也是完全没有问题的 代码规范目的是方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。 规范并不是唯一的，也就是说理论上每个公司都可以制定自己的规范，不过一般来说整体上规范差异不会很大。 ","date":"2023-04-06","objectID":"/golang_quick/:1:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2. 代码规范 2.1 命名规范 命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。 a. 当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）； b. 命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ） 2.1.1 包名：package 保持 package 的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。 package model package main 2.1.2 文件名 尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。 user_model.go 2.1.3 结构体命名 采用驼峰命名法，首字母根据访问控制大写或者小写 struct 申明和初始化格式采用多行，例如下面： // 多行申明 type User struct{ Username string Email string } // 多行初始化 u := User{ Username: \"bobby\", Email: \"bobby@imooc.com\", } 2.1.4 接口命名 命名规则基本和上面的结构体类型 单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。 type Reader interface { Read(p []byte) (n int, err error) } 2.1.5 变量命名 和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： 如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID 错误示例：UrlArray，应该写成 urlArray 或者 URLArray 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头 var isExist bool var hasConflict bool var canManage bool var allowGitHook bool 2.1.6 常量命名 常量均需使用全部大写字母组成，并使用下划线分词 如果是枚举类型的常量，需要先创建相应类型： ","date":"2023-04-06","objectID":"/golang_quick/:1:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2.2 注释 Go 提供 C 风格的/* */块注释和 C ++风格的//行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释 多行注释也叫块注释，均已以 /_ 开头，并以 _/ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段 go 语言自带的 go doc 工具可以根据注释生成文档，生成可以自动生成对应的网站（golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在 package 子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在 godoc 页面上，并应设置下面的详细文档。 2.2.1 包注释 每个包都应该有一个包注释，一个位于 package 子句之前的块注释或行注释。包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）： 包的基本简介（包名，简介） 创建者，格式： 创建人： rtx 名 创建时间，格式：创建时间： yyyyMMdd 2.2.2 结构（接口）注释 每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下： 2.2.3 函数（方法）注释 每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）： 简要说明，格式说明：以函数名开头，“，”分隔说明部分 参数列表：每行一个参数，参数名开头，“，”分隔说明部分 返回值： 每行一个返回值 2.2.4 代码逻辑注释 对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下： 2.2.5 注释风格 统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如： 上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。 建议全部使用单行注释 和代码的规范一样，单行注释不要过长，禁止超过 120 字符。 ","date":"2023-04-06","objectID":"/golang_quick/:1:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2.3 import 规范 import 在多行的情况下，goimports 会自动帮你格式化，但是我们这里还是规范一下 import 的一些规范，如果你在一个文件里面引入了一个 package，还是建议采用如下格式： 如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包： 有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。 在项目中不要使用相对路径引入包： 但是如果是引入本项目中的其他包，最好使用相对路径。 ","date":"2023-04-06","objectID":"/golang_quick/:1:4","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2.4 错误处理 错误处理的原则就是不能丢弃任何有返回 err 的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回 err，或者使用 log 记录下来 尽早 return：一旦有错误发生，马上返回 尽量不要使用 panic，除非你知道你在做什么 错误描述如果是英文必须为小写，不需要标点结尾 采用独立的错误流进行处理 ","date":"2023-04-06","objectID":"/golang_quick/:1:5","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"语言特性 ","date":"2023-04-06","objectID":"/golang_quick/:2:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 Go 语言主要特性 自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 1.1 自动垃圾回收 内存泄露的最佳解决方案是在语言级别引入自动垃圾回收算法（Garbage Collection，简称 GC）。 所谓垃圾回收，即所有的内存分配动作都会被在运行时记录，同时任何对 该内存的使用也都会被记录，然后垃圾回收器会对所有已经分配的内存进行跟踪监测，一旦发现 有些内存已经不再被任何人使用，就阶段性地回收这些没人用的内存。 使用 Go 语言，系统会自动帮我们判断，并在合适的时候（比如 CPU 相对空闲的时候）进行自动垃圾收集工作。 1.2 更丰富的内置类型 map （可以认为是字典） slice（一种可动态增长的数组） 1.3 函数多返回值 Go 语言革命性地在静态开发语言阵营中率先提供了多返回值功能。 1.4 错误处理 Go 语言引入了 3 个关键字用于标准的错误处理流程，这 3 个关键字分别为defer、panic 和 recover。Go 语言的错误处理机制可以大量减少代码量，让开发者也无需仅仅为了程序安全性而添加大量 一层套一层的 try-catch 语句。 1.5 匿名函数和闭包 在 Go 语言中，所有的函数也是值类型，可以作为参数传递。Go 语言支持常规的匿名函数和闭包。 1.6 类型和接口 类型的定义使用struct关键字。引入了一个无比强大的**“非侵入式” 接口**的概念。 //定义一个鸟类型 type Bird struct { ... } //鸟类型的方法 func (b *Bird) Fly() { // 以鸟的方式飞行 } //定义一个IFly接口 type IFly interface { Fly() } //使用接口 func main() { var fly IFly = new(Bird) fly.Fly() } 可以看出，虽然 Bird 类型实现的时候，没有声明与接口 IFly 的关系，但接口和类型可以直接转换，甚至接口的定义都不用在类型定义之前，这种比较松散的对应关系可以大幅降低因为接口调整而导致的大量代码调整工作。 1.7 并发编程 引入了 goroutine 概念，使用消息传递来共享内存。Go 语言让并发编程变得更加轻盈和安全。 通过在函数调用前使用关键字 go，我们即可让该函数以 goroutine 方式执行。goroutine是一种比线程更加轻盈、更省资源的协程。。Go 语言通过系统的线程来多路派遣这些函数的执行，使得每个用 go 关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗 CPU 调度的规模不下于每秒百万次，这使得我们能够创建大量的 goroutine，从而可以很轻松地编写高并发程序，达到我们想要的目的。 使用 CSP(通信顺序进程，Communicating Sequential Process)模型来作为 goroutine 间的推荐通信方式。(在 CSP 模型中，一个并发系统由若干并行运行的顺序进程组成，每个进程不 能对其他进程的变量赋值。进程之间只能通过一对通信原语实现协作。)Go 语言用channel（通道） 这个概念来轻巧地实现了 CSP 模型，可以方便地进行跨 goroutine 的通信。 由于一个进程内创建的所有 goroutine 运行在同一个内存地址空间中，因此如果不同的 goroutine 不得不去访问共享的内存变量，访问前应该先获取相应的读写锁。Go 语言标准库中的 sync 包提供了完备的读写锁功能 //由两个goroutine进行并行的累加计算，待这两个计算过程都完成后打印计算结果 package main import \"fmt\" func sum(values [] int, resultChan chan int) { sum := 0 for _, value := range values { sum += value } resultChan \u003c- sum // 将计算结果发送到channel中 } func main() { values := [] int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} resultChan := make(chan int, 2) go sum(values[:len(values)/2], resultChan) go sum(values[len(values)/2:], resultChan) sum1, sum2 := \u003c-resultChan, \u003c-resultChan // 接收结果 fmt.Println(\"Result:\", sum1, sum2, sum1 + sum2) } 1.8 反射 反射(reflection)，通过反射，你可以获取对象类型的详细信息，并可动态操作对象。 反射最常见的使用场景是做对象的序列化(serialization，有时候也叫 Marshal \u0026 Unmarshal)。 //以利用反射功能列出某个类型中所有成员变量的值 package main import ( \"fmt\" \"reflect\" ) type Bird struct { Name string LifeExpectance int } func (b *Bird) Fly() { fmt.Println(\"I am flying...\") } func main() { sparrow := \u0026Bird{\"Sparrow\", 3} s := reflect.ValueOf(sparrow).Elem() typeOfT := s.Type() for i := 0; i \u003c s.NumField(); i++ { f := s.Field(i) fmt.Printf(\"%d: %s %s = %v\\n\", i,typeOfT.Field(i).Name,f.Type(), f.Interface()) } } 1.9 语言交互性 Cgo 既是语言特性,同时也是一个工具的名称,用于重用现有 C 模块。在 Go 代码中，可以按 Cgo 的特定语法混合编写 C 语言代码，然后 Cgo 工具可以将这些混合的 C 代码提取并生成对于 C 功能的调用包装代码。开发者基本上可以完全忽略这个 Go 语言和 C 语言的边界是如何跨越的。 ","date":"2023-04-06","objectID":"/golang_quick/:2:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 hello world package main import \"fmt\"// 我们需要使用fmt包中的Println()函数 func main() { fmt.Println(\"Hello, world. 你好，世界！\") } package : 每个 Go 源代码文件的开头都是一个 package 声明，表示该 Go 代码所属的包。包是 Go 语言里 最基本的分发单位，也是工程管理中依赖关系的体现。要生成 Go 可执行程序，必须建立一个名字为 main 的包，并且在该包中包含一个叫 main()的函数（该函数是 Go 可执行程序的执行起点）。 main() : **Go 语言的 main()函数不能带参数，也不能定义返回值。**命令行传入的参数在 os.Args 变量 中保存。如果需要支持命令行开关，可使用 flag 包。 函数: 在函数返回时没有被明确赋值的返回值都会被设置为默认 值，比如 result 会被设为 0.0，err 会被设为 nil。 func Compute(value1 int, value2 float64) (result float64, err error) { // 函数体 } 2.1 编译并运行 使用这个命令，会将编译、链接和运行 3 个步骤合并为一步，运行完后在当前目录下也看不 到任何中间文件和最终的可执行文件。 go run hello.go 只生成编译结果而不自动运行。编译结果为 hello 的可执行文件。 go build hello.go ","date":"2023-04-06","objectID":"/golang_quick/:2:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 工程管理 Go 命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推 导工程结构和构建顺序。 示例： 这样一个程序： $ calc help USAGE: calc command [arguments] ... The commands are: sqrt Square root of a non-negative value. add Addition of two values. $ calc sqrt 4 # 开根号 2 $ calc add 1 2 # 加法 3 工程结构： 一个正常的工程目录组织应该如下所示： \u003ccalcproj\u003e ├─\u003csrc\u003e ├─\u003ccalc\u003e ├─calc.go ├─\u003csimplemath\u003e ├─add.go ├─add_test.go ├─sqrt.go ├─sqrt_test.go ├─\u003cbin\u003e ├─\u003cpkg\u003e＃包将被安装到此处 可执行程序，名为 calc，内部只包含一个 calc.go 文件； 算法库，名为 simplemath，每个 command 对应于一个同名的 go 文件，比如 add.go。 在上面的结构里，带尖括号的名字表示其为目录。xxx_test.go 表示的是一个对于 xxx.go 的单元 测试，这也是 Go 工程里的命名规则。 //calc.go package main import \"os\" // 用于获得命令行参数os.Args import \"fmt\" import \"simplemath\" import \"strconv\" var Usage = func() { fmt.Println(\"USAGE: calc command [arguments] ...\") fmt.Println(\"\\nThe commands are:\\n\\tadd\\tAddition of two values.\\n\\tsqrt\\tSquar root of a non - negative value.\") } func main() { args := os.Args if args == nil || len(args) \u003c 2 { Usage() return } switch args[0] { case \"add\": if len(args) != 3 { fmt.Println(\"USAGE: calc add \u003cinteger1\u003e\u003cinteger2\u003e\") return } v1, err1 := strconv.Atoi(args[1]) v2, err2 := strconv.Atoi(args[2]) if err1 != nil || err2 != nil { fmt.Println(\"USAGE: calc add \u003cinteger1\u003e\u003cinteger2\u003e\") return } ret := simplemath.Add(v1, v2) fmt.Println(\"Result: \", ret) case \"sqrt\": if len(args) != 2 { fmt.Println(\"USAGE: calc sqrt \u003cinteger\u003e\") return } v, err := strconv.Atoi(args[1]) if err != nil { fmt.Println(\"USAGE: calc sqrt \u003cinteger\u003e\") return } ret := simplemath.Sqrt(v) fmt.Println(\"Result: \", ret) default: Usage() } } // add.go package simplemath func Add(a int, b int) int { return a + b } // add_test.go package simplemath import \"testing\" func TestAdd1(t *testing.T) { r := Add(1, 2) if r != 3 { t.Errorf(\"Add(1, 2) failed. Got %d, expected 3.\", r) } } // sqrt.go package simplemath import \"math\" func Sqrt(i int) int { v := math.Sqrt(float64(i)) return int(v) } // sqrt_test.go package simplemath import \"testing\" func TestSqrt1(t *testing.T) { v := Sqrt(16) if v != 4 { t.Errorf(\"Sqrt(16) failed. Got %v, expected 4.\", v) } } 将当前的工程的根目录添加到环境变量 GOPATH 中。 生成可执行文件。加入放到当前工程根目录的 bin 文件夹中： cd /calcproj mkdir bin go build calc 我们不需要写 makefile，因为这个工具会替我们分析，知道目标代码的编译结果应该是一个包还是一个可执行文件，并分析 import 语句以了解包的依赖关系，从而在编译 calc.go 之前先把依赖的 simplemath 编译打包好。 由于已经写了测试代码，并且已添加到环境变量 GOPATH 中，所以可以直接测试： go test simplemath 若需要调试，可直接使用 gdb 调试编译后的可执行文件(gdb version \u003e7.1)，eg： gdb calc ","date":"2023-04-06","objectID":"/golang_quick/:2:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"基本语法 ","date":"2023-04-06","objectID":"/golang_quick/:3:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 变量 1.1 声明 var v1 int var v2 string var v3 [10]int //数组 var v4 []int //数组切片 var v5 struct{ f int } var v6 *int //指针 var v7 map[string] int //map key为string value为int var v8 func(a int) int // 匿名函数 //将若干个变量声明在一起，避免了重复写var var ( v1 int v2 string ) 1.2 初始化 var v1 int = 10 // 正确的使用方式1 var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型 v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型 PS：出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误。 1.3 赋值 支持多重赋值功能： i,j=j,i 1.4 匿名变量 在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。这个时候就可以使用匿名变量来接收不需要的值。eg： func GetName() (firstName, lastName, nickName string) { return \"May\", \"Chan\", \"Chibi Maruko\" } _,_,nickName := GetName() ","date":"2023-04-06","objectID":"/golang_quick/:3:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 常量 Go 语言中，常量是指编译期间就已知且不可改变的值。常量可以是数值类型（包括整型、 浮点型和复数类型）、布尔类型、字符串类型等。 2.1 字面常量 所谓字面常量（literal），是指程序中硬编码的常量。eg： -12 3.14159265358979323846 // 浮点类型的常量 3.2+12i // 复数类型的常量 true // 布尔类型的常量 \"foo\" // 字符串常量 Go 语言的字面常量更接近我们自然语言中的常量概念，它是无类型的。只要这个常量在相应类型的值域范围内，就可以作为该类型的常量，比如上面的常量-12，它可以赋值给 int、uint、int32、 int64、float32、float64、complex64、complex128 等类型的变量。 2.2 常量的定义 通过 const 关键字，给字面常量指定一个友好的名字。 const Pi float64 = 3.14159265358979323846 const zero = 0.0 // 无类型浮点常量 const ( size int64 = 1024 eof = -1 // 无类型整型常量 ) const u, v float32 = 0, 3 // u = 0.0, v = 3.0，常量的多重赋值 const a, b, c = 3, 4, \"foo\" // a = 3, b = 4, c = \"foo\", 无类型整型和字符串常量 Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么它 与字面常量一样，是无类型常量。 常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达式。 2.3 预定义常量 Go 语言预定义了这些常量：true、false 和 iota。 iota : iota 比较特殊，可以被认为是一个可被编译器修改的常量，在每一个 const 关键字出现时被 重置为 0，然后在下一个 const 出现之前，每出现一次 iota，其所代表的数字会自动增 1。如果两个 const 的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。 const ( // iota被重设为0 c0 = iota // c0 == 0 c1 = iota // c1 == 1 c2 = iota // c2 == 2 ) const ( a = 1 \u003c\u003c iota // a == 1 (iota在每个const开头被重设为0) b = 1 \u003c\u003c iota // b == 2 c = 1 \u003c\u003c iota // c == 4 ) const ( u = iota * 42 // u == 0 v float64 = iota * 42 // v == 42.0 w = iota * 42 // w == 84 ) const x = iota // x == 0 (因为iota又被重设为0了) const y = iota // y == 0 (同上) const ( // iota被重设为0 c0 = iota // c0 == 0 c1 // c1 == 1 c2 // c2 == 2 ) const ( a = 1 \u003c\u003c iota // a == 1 (iota在每个const开头被重设为0) b // b == 2 c // c == 4 ) 2.4 枚举 在 const 后跟一对圆括号的方式定义一组常量，这种定义法在 Go 语言中通常用于定义枚举值。 const ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday numberOfDays // 这个常量没有导出 包内私有 ) ","date":"2023-04-06","objectID":"/golang_quick/:3:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 类型 内置基础类型 布尔类型：bool 整型： int8、byte、int16、int、uint、uintptr 等 浮点类型：float32、float64 复数类型：complex64、complex128 字符串：string 字符类型：rune 错误类型：error 复合类型 指针（pointer） 数组（array） 切片（slice） 字典（map） 通道（chan） 结构体（struct） 接口（interface） 3.1 布尔类型 布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。 3.2 整型 类型 字节 int8 1 int16 2 int64 8 int 平台相关 uint8 1 uint16 2 uint32 4 uint64 8 uint 平台相关 uintptr 同指针（32 位平台为 4 字节，63 位平台下位 8 字节） int32 4 整形之间不可以直接值转换，需要做强制类型转换。 var value2 int32 value1:=64 value2=int32(value1) 3.3 浮点型 类型 字节 float32 4 float64 8 3.4 复数类型 复数实际上由两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示 虚部（imag）。 var value1 complex64 // 由2个float32构成的复数类型 value1 = 3.2 + 12i value2 := 3.2 + 12i // value2是complex128类型 value3 := complex(3.2, 12) // value3结果同 value2 3.5 字符串 字符串不可以被修改，是常量。字符串操作包括：+、len(s)、s[i]等，更多操作，见 strings 包。 str := \"Hello,世界\" for i, ch := range str { fmt.Println(i, ch)//ch的类型为rune } str := \"Hello,世界\" n := len(str) for i := 0; i \u003c n; i++ { ch := str[i] // 依据下标取字符串中的字符，类型为byte fmt.Println(i, ch) } 3.6 字符类型 类型 备注 byte UTF-8 字符串的单个字节的值 rune 代表单个 Unicode 字符 3.7 数组 数组就是指一系列同一类型数据 的集合。数组中包含的每个数据被称为数组元素（element），一个数组包含的元素个数被称为数 组的长度。 //声明方式 [32]byte // 长度为32的数组，每个元素为一个字节 [2*N] struct { x, y int32 } // 复杂类型数组 [1000]*float64 // 指针数组 [3][5]int // 二维数组 [2][2][2]float64 // 等同于[2]([2]([2]float64)) 需要特别注意的是，在 Go 语言中数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。数组的长度在定义之后无法再次修改。 3.8 数组切片 与数组相比，数组切片多了一个存储能力（capacity）的概念，即元素个数和分配的空间可以是两个不同的值。合理地设置存储能力的 值，可以大幅降低数组切片内部重新分配内存和搬送内存块的频率，从而大大提高程序性能。 数组切片的数据结构可以抽象为以下 3 个变量： 一个指向原生数组的指针 数组切片中的元素个数 数组切片已分配的存储空间 数组切片添加了一系 列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复 复制。 创建方法有两种： 基于数组 直接创建 // 先定义一个数组 var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} // 基于数组创建一个数组切片 var mySlice []int = myArray[:5] fmt.Println(\"Elements of myArray: \") for _, v := range myArray { fmt.Print(v, \" \") } fmt.Println(\"\\nElements of mySlice: \") for _, v := range mySlice { fmt.Print(v, \" \") } //直接创建 //创建一个初始元素个数为5的数组切片，元素初始值为0： mySlice1 := make([]int, 5) //创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间： mySlice2 := make([]int, 5, 10) //直接创建并初始化包含5个元素的数组切片： mySlice3 := []int{1, 2, 3, 4, 5} cap()函数,返回的是数组切片分配的空间大小 len()函数,返回的是数组切片中当前所存储的元素个数。 append()函数,继续新增元素。 注意：在第二个参数 mySlice2 后面加了三个点，即一个省略号，如果没有这个省 略号的话，会有编译错误，因为按 append()的语义，从第二个参数起的所有参数都是待附加的 元素。因为 mySlice 中的元素类型为 int，所以直接传递 mySlice2 是行不通的。加上省略号相当于把 mySlice2 包含的所有元素打散后传入。 mySlice2 := []int{8, 9, 10} myslice := make([]int, 5, 10) myslice = append(myslice, 8, 9, 10) // 给mySlice后面添加另一个数组切片 mySlice = append(mySlice, mySlice2...) //上句等价于 mySlice = append(mySlice, 8, 9, 10) copy()函数,将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。 slice1 := []int{1, 2, 3, 4, 5} slice2 := []int{5, 4, 3} copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中 copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 3.9 map map 是一堆键值对的未排序集合。 package main import \"fmt\" // PersonInfo是一个包含个人详细信息的类型 type PersonInfo struct { ID string Name string Address string } func main() { var personDB map[string]PersonInfo personDB = make(map[string]PersonInfo) // 往这个map里插入几条数据 personDB[\"12345\"] = PersonInfo{\"12345\", \"Tom\", \"Room 203,...\"} personDB[\"1\"] = PersonInfo{\"1\", \"Jack\", \"Room 101,...\"} // 从这个map查找键为\"1234\"的信息 person, ok := personDB[\"1234\"] // ok是一个返回的bool型，返回true表示找到了对应的数据 if ok { fmt.Println(\"Found person\", person.Name, \"with ID 1234.\") } else { fmt.Println(\"Did not find person with ID 1234.\") } } 变量声明 var myMap map[string] PersonInfo 创建 myMap = make(map[string] PersonInfo) myMap = make(map[string] PersonInfo, 100)//存储能力为100 //创建并初始化 myMap = map[string] PersonInfo{ \"1234\": PersonInfo{\"1\", \"Jack\", \"Room 101,...\"}, } 元素赋值 myMap[\"1234\"] = PersonInfo{\"1\", \"Jack\", \"Room 101,...\"} 元素删除 delete(myMap, \"1234\") 元素查找 value, ok := myMap[\"1234\"] if ok { // 找到了 // 处理找到的value } ","date":"2023-04-06","objectID":"/golang_quick/:3:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4 流程控制 流程控制语句的作用： 选择 循环 跳转 go 语言支持的流程控制语句 条件语句 选择语句 循环语句 跳转语句 为了满足更丰富的控制需求，Go 语言还添加了如下关键字：break、 continue和fallthrough。 4.1 条件语句 if a \u003c 5 { return 0 } else { return 1 } 条件语句不需要使用括号将条件包含起来() 无论语句体内有几条语句，花括号{}都是必须存在的 左花括号{必须与 if 或者 else 处于同一行 在 if 之后，条件语句之前，可以添加变量初始化语句，使用；间隔； 在有返回值的函数中，不允许将“最终的”return 语句包含在 if…else…结构中， 否则会编译失败 4.2 选择语句 switch i { case 0: fmt.Printf(\"0\") case 1: fmt.Printf(\"1\") case 2: fallthrough case 3: fmt.Printf(\"3\") case 4, 5, 6: fmt.Printf(\"4, 5, 6\") default: fmt.Printf(\"Default\") } switch { case 0 \u003c= Num \u0026\u0026 Num \u003c= 3: fmt.Printf(\"0-3\") case 4 \u003c= Num \u0026\u0026 Num \u003c= 6: fmt.Printf(\"4-6\") case 7 \u003c= Num \u0026\u0026 Num \u003c= 9: fmt.Printf(\"7-9\") } 左花括号{必须与 switch 处于同一行； 条件表达式不限制为常量或者整数； 单个 case 中，可以出现多个结果选项； 与 C 语言等规则相反**，Go 语言不需要用 break 来明确退出一个 case；** 只有在 case 中明确添加 fallthrough 关键字，才会继续执行紧跟的下一个 case； 可以不设定 switch 之后的条件表达式，在此种情况下，整个 switch 结构与多个 if…else…的逻辑作用等同。 4.3 循环语句 Go 语言中的循环语句只支持 for 关键字。 a := []int{1, 2, 3, 4, 5, 6} for i, j := 0, len(a) – 1; i \u003c j; i, j = i + 1, j – 1 { a[i], a[j] = a[j], a[i] } 左花括号{必须与 for 处于同一行。 Go 语言中的 for 循环与 C 语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go 语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。 Go 语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例( 本例中，break 语句终止的是 JLoop 标签处的外层循环。)： for j := 0; j \u003c 5; j++ { for i := 0; i \u003c 10; i++ { if i \u003e 5 { break JLoop } fmt.Println(i) } } JLoop: // ... 4.4 跳转语句 goto 语句的语义非常简单，就是跳转到本函数内的某个标签，如： func myfunc() { i := 0 HERE: fmt.Println(i) i++ if i \u003c 10 { goto HERE } } ","date":"2023-04-06","objectID":"/golang_quick/:3:4","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"5 函数 5.1 不定参数 指定类型的不定参数 func myfunc(args ...int) { for _, arg := range args { fmt.Println(arg) } } **形如...type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。它是一 个语法糖（syntactic sugar）。其本质是数组切片。** 不定类型的不定参数 如果你希望传任意类型，可以指定类型为 interface{}。用 interface{}传递任意类型数据是 Go 语言的惯例用法。 func Printf(format string, args ...interface{}) { // ... } func MyPrintf(args ...interface{}) { for _, arg := range args { switch arg.(type) { case int: fmt.Println(arg, \"is an int value.\") case string: fmt.Println(arg, \"is a string value.\") case int64: fmt.Println(arg, \"is an int64 value.\") default: fmt.Println(arg, \"is an unknown type.\") } } } 5.2 匿名函数与闭包 匿名函数是指不需要定义函数名的一种函数实现方式。Go 语言支持随时在代码里定义匿名函数。匿名函数可以直接赋值给一个变量或者直接执行。 f := func(x, y int) int { return x + y } func(ch chan int) { ch \u003c- ACK } (reply_chan) // 花括号后直接跟参数列表表示函数调用 Go 的匿名函数是一个闭包。 基本概念 闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。 闭包的价值 闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示 数据还要表示代码。 Go 中的闭包 闭包的实现确保只要闭包还被使用，那么 被闭包引用的变量会一直存在。 package main import ( \"fmt\" ) func main() { var j int = 5 a := func() func() { var i int = 10 return func() { fmt.Printf(\"i, j: %d, %d\\n\", i, j) } }() a() j *= 2 a() } /* 结果： i, j: 10, 5 i, j: 10, 10 */ ","date":"2023-04-06","objectID":"/golang_quick/:3:5","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"6 错误处理 6.1 error 接口 Go 语言引入了一个关于错误处理的标准模式，即 error 接口。 type error interface { Error() string } 处理错误的方式： if err != nil { // 错误处理 } else { // 使用返回值n } 如何使用自定义的 error 类型? 定义一个用于承载错误信息的类型。Go 语言中接口的灵活性，你根本不需要从 error 接口继承。 type PathError struct { Op string Path string Err error } 实现 Error()方法 func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() } 6.2 defer 函数在退出前执行 defer 指定的操作。一个函数中可以存在多个 defer 语句，因此需要注意的是，defer 语句的调用是遵照 先进后出的原则，即最后一个 defer 语句将最先被执行。 *6.3 panic 、recover Go 语言引入了两个内置函数panic()和recover()以报告和处理运行时错误和程序中的错误场景。 panic和recover相当于 python 中的try except。 当在一个函数执行过程中调用 panic()函数时，正常的函数执行流程将立即终止，但函数中 之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致 逐层向上执行 panic 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic()函数时传入的参数，这个过程称为错误处理流程。 recover()函数用于终止错误处理流程。一般情况下，recover()应该在一个使用 defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的 goroutine 中明确调用恢复过程（使用 recover 关键字），会导致该 goroutine 所属的进程打印异常信息后直接退出。 package main import ( \"fmt\" ) func divide() { defer func() { if err := recover(); err != nil { fmt.Printf(\"Runtime panic caught: %v\\n\", err) } }() var i = 1 var j = 0 k := i / j fmt.Printf(\"%d / %d = %d\\n\", i, j, k) } func main() { divide() fmt.Println(\"divide方法调用完毕，回到main函数\") } ","date":"2023-04-06","objectID":"/golang_quick/:3:6","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"面向对象 Go 语言对面向对象编程的支持是语言类型系统中的天然组成部分 ","date":"2023-04-06","objectID":"/golang_quick/:4:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 类型系统 类型系统是指一个语言的类型体系结构 1.1 为类型添加方法 type Integer int func (a Integer) Less(b Integer) bool { return a \u003c b } 关于给类型添加方法的时候，类型的参数是传入指针？还是值传递？如下： func (a *Integer) Add(b Integer) { *a += b } func (a Integer) Add(b Integer) { a += b } 这取决于，你是否需要需要修改对象！若需要修改对象，则需要传入指针。类型都是基于值传递的。要想修改变量的值，只能 传递指针 1.2 结构体 type Rect struct { x, y float64 width, height float64 } func (r *Rect) Area() float64 { return r.width * r.height } ","date":"2023-04-06","objectID":"/golang_quick/:4:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 初始化 rect1 := new(Rect) rect2 := \u0026Rect{} rect3 := \u0026Rect{0, 0, 100, 200} rect4 := \u0026Rect{width: 100, height: 200} 未进行显式初始化的变量都会被初始化为该类型的零值。例如 bool 类型的零 值为 false，int 类型的零值为 0，string 类型的零值为空字符串。 在 Go 语言中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以 NewXXX 来命名，表示“构造函数”： func NewRect(x, y, width, height float64) *Rect { return \u0026Rect{x, y, width, height} } ","date":"2023-04-06","objectID":"/golang_quick/:4:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 匿名组合 Go 语言也提供了继承，但是采用了组合的文法，所以我们将其称为匿名组合。 type Base struct { Name string } func (base *Base) Foo() { ... } func (base *Base) Bar() { ... } type Foo struct { Base ... } func (foo *Foo) Bar() { foo.Base.Bar() ... } ","date":"2023-04-06","objectID":"/golang_quick/:4:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4 接口 Go 语言在编程哲学上是变革派,是因为 Go 语言的类型系统，更是因为 Go 语言的接口 “侵入式”的主要表现在于实现类需要明确声明自己实现了某个接口。“非侵入式”只需要实现接口的方法，不需要声明。 type File struct { // ... } func (f *File) Read(buf []byte) (n int, err error) func (f *File) Write(buf []byte) (n int, err error) func (f *File) Seek(off int64, whence int) (pos int64, err error) func (f *File) Close() error type IFile interface { Read(buf []byte) (n int, err error) Write(buf []byte) (n int, err error) Seek(off int64, whence int) (pos int64, err error) Close() error } type IReader interface { Read(buf []byte) (n int, err error) } type IWriter interface { Write(buf []byte) (n int, err error) } type ICloser interface { Close() error } var file1 IFile = new(File) var file2 IReader = new(File) var file3 IWriter = new(File) var file4 ICloser = new(File) 尽管 File 类并没有从这些接口继承，甚至可以不知道这些接口的存在，但是 File 类实现了 这些接口，可以进行赋值。 非侵入式接口的好处： Go 语言的标准库，再也不需要绘制类库的继承树图。 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。 不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。 在 Go 语言中，只要两个接口拥 有相同的方法列表（次序不同不要紧），那么它们就是等同的，可以相互赋值。 4.1 接口查询 var file1 Writer = ... if file5, ok := file1.(two.IStream); ok { ... } 这个 if 语句检查 file1 接口指向的对象实例是否实现了 two.IStream 接口，如果实现了，则执 行特定的代码。 4.2 类型查询 var v1 interface{} = ... switch v := v1.(type) { case int: // 现在v的类型是int case string: // 现在v的类型是string ... } ","date":"2023-04-06","objectID":"/golang_quick/:4:4","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"5 Any 类型 由于 Go 语言中任何对象实例都满足空接口 interface{}，所以 interface{}看起来像是可以指向任何对象的 Any 类型。 var v1 interface{} = 1 // 将int类型赋值给interface{} var v2 interface{} = \"abc\" // 将string类型赋值给interface{} var v3 interface{} = \u0026v2 // 将*interface{}类型赋值给interface{} var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026struct{ X int }{1} ","date":"2023-04-06","objectID":"/golang_quick/:4:5","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"并发处理 ","date":"2023-04-06","objectID":"/golang_quick/:5:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 并发基础 目前几种主流的实现模式： 多进程 多进程是在操作系统层面进行并发的基本模式。同时也是开销最大的模式。 多线程 多线程在大部分操作系统上都属于系统层面的并发模式，也是我们使用最多的 最有效的一种模式。它比多进程的开销小很多，但是其开销依旧比较大，且在高并发模式下，效率会有影响。 基于回调的非阻塞/异步 IO 使用多线程模式会很快耗尽服务器的内存和 CPU 资源。而这 种模式通过事件驱动的方式使用异步 IO，使服务器持续运转，且尽可能地少用线程，降 低开销，它目前在 Node.js 中得到了很好的实践。 协程 协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度， 且在真正实现寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。 ","date":"2023-04-06","objectID":"/golang_quick/:5:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 协程 Go 语言在语言级别支持轻量级线程，叫 goroutine。Go 语言标准库提供的所有系统调用操作（当然也包括所有同步 IO 操作），都会出让 CPU 给其他 goroutine。轻量级线程的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量。 ","date":"2023-04-06","objectID":"/golang_quick/:5:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 goroutine goroutine 是 Go 语言中的轻量级线程实现，由 Go 运行时（runtime）管理。 func Add(x, y int) { z := x + y fmt.Println(z) } go Add(1,1) 需要注意的是，如果这个函数有返回值，那么这个 返回值会被丢弃。 package main import \"fmt\" func Add(x, y int) { z := x + y fmt.Println(z) } func main() { for i := 0; i \u003c 10; i++ { go Add(i, i) } } Go 程序从初始化 main package 并执行 main()函数开始，当 main()函数返回时，程序退出， 且程序并不等待其他 goroutine（非主 goroutine）结束。 ","date":"2023-04-06","objectID":"/golang_quick/:5:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4 并发通信 并发编程的难度在于协调，而协调就要通过交流。在工程上，有两种最常见的并发通信模型：共享数据和消息。 共享数据 指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。被共享的 数据可能有多种形式，比如内存数据块、磁盘文件、网络数据等。在实际工程应用中最常见的无 疑是内存了，也就是常说的共享内存。 消息机制 Go 语言提供的是另一种通信模型，即以消息机制而非共享内存作为通信方式。消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发 单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。 ","date":"2023-04-06","objectID":"/golang_quick/:5:4","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"5 channel channel 是进程内的通信方式，如果需要跨进程通信，我们建议用 分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。一个 channel 只能传递一种类型的值，这个类型需要在声明 channel 时指定。 package main import \"fmt\" func Count(ch chan int) { ch \u003c- 1 fmt.Println(\"Counting\") } func main() { chs := make([]chan int, 10) for i := 0; i \u003c 10; i++ { chs[i] = make(chan int) go Count(chs[i]) } for _, ch := range chs { \u003c-ch } } 在这个例子中，我们定义了一个包含 10 个 channel 的数组（名为 chs），并把数组中的每个 channel 分配给 10 个不同的 goroutine。在每个 goroutine 的 Add()函数完成后，我们通过 ch \u003c- 1 语 句向对应的 channel 中写入一个数据。在这个 channel 被读取前，这个操作是阻塞的。在所有的 goroutine 启动完成后，我们通过\u003c-ch 语句从 10 个 channel 中依次读取数据。在对应的 channel 写入 数据前，这个操作也是阻塞的。这样，我们就用 channel 实现了类似锁的功能，进而保证了所有 goroutine 完成后主函数才返回。 5.1 基本语法 var ch chan int var m map[string] chan bool //声明一个map，key是string，value是channel ch := make(chan int) //写入数据 ch \u003c- value //读出数据 value := \u003c-ch 向 channel 写入数据通常会导致程序阻塞，直到有其他 goroutine 从这个 channel 中读取数据。如果 channel 之前没有写入数据，那么从 channel 中读取数据也会导致程序阻塞，直到 channel 中被写入数据为止。 经典错误： package main import \"fmt\" func main(){ var msg chan int msg = make(chan int) msg\u003c- 1 data := \u003c- msg fmt.Println(data) } // 执行情况：fatal error: all goroutines are asleep - deadlock! 该错误很经典！因为申请的是一个无缓冲的通道！该通道写入数据后会导致所在线程阻塞，直到其他线程对该通道读操作后，那个被阻塞的线程才会被继续执行。所以上述代码，第 9 行及其之后的代码将不会被执行。 package main import \"fmt\" func main(){ var msg chan int msg = make(chan int) go func() { data := \u003c- msg fmt.Println(data) }() msg\u003c- 1 } //执行情况：啥也不会输出，正常结束 5.2 select 通过调用 select()函数来监控一系列的文件句柄，一旦其中一个文件句柄发生了 IO 动作，该 select()调用就会被返回。后来该机制也被用于 实现高并发的 Socket 服务器程序。Go 语言直接在语言级别支持 select 关键字，用于处理异步 IO 问题。 select 有比较多的 限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作。 select { case \u003c-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u003c- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } select 的每个 case 语句都必须是一个面向 channel 的操作。 5.3 缓冲机制 给 channel 带上缓冲， 从而达到消息队列的效果。要创建一个带缓冲的 channel，其实也非常容易： c := make(chan int, 1024) 在调用 make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小 为 1024 的 int 类型 channel，即使没有读取方，写入方也可以一直往 channel 里写入，在缓冲区被 填完之前都不会阻塞。 5.4 超时机制 在并发编程的通信过程中，最需要处理的就是超时问题，即向 channel 写数据时发现 channel 已满，或者从 channel 试图读取数据时发现 channel 为空。如果不正确处理这些情况，很可能会导 致整个 goroutine 锁死。 使用 channel 时需要小心，比如对于以下这个用法： i:= \u003c-ch 如果出现了一个错误情况，即永远都没有人往 ch 里写数据，那 么上述这个读取动作也将永远无法从 ch 中读取到数据，导致的结果就是整个 goroutine 永远阻塞并 没有挽回的机会。 Go 语言没有提供直接的超时处理机制，但我们可以利用 select 机制。虽然 select 机制不是 专为超时而设计的，却能很方便地解决超时问题。因为 select 的特点是只要其中一个 case 已经 完成，程序就会继续往下执行，而不会考虑其他 case 的情况。 timeout := make(chan bool, 1) go func() { time.Sleep(1e9) // 等待1秒钟 timeout \u003c- true }() // 然后我们把timeout这个channel利用起来 select { case \u003c-ch: // 从ch中读取到数据 case \u003c-timeout: // 一直没有从ch中读取到数据，但从timeout中读取到了数据 } 这样使用 select 机制可以避免永久等待的问题，是在 Go 语言开发中避免 channel 通信超时的最有效方法。 5.5 channel 的传递 channel 本身也是一个原生类型,具有可被传递的特性。 示例：定义一系列 PipeData 的数据结构并一起传递给一个函数，就可以达到流式处理数据的目的。 type PipeData struct { value int handler func(int) int next chan int } func handle(queue chan *PipeData) { for data := range queue { data.next \u003c- data.handler(data.value) } } 5.6 单向 channel 单向 channel 只能用于发送或者接收数据。channel 本身必然是同时支持读写的， 否则根本没法用。在此，我们只是对其增加一些限制。 单向 channel 变量的声明非常简单，如下： var ch1 chan int // ch1是一个正常的channel，不是单向的 var ch2 chan\u003c- float64// ch2是单向channel，只用于写float64数据 var ch3 \u003c-chan int // ch3是单向channel，只用于读取int数据 channel 是一个原生类型，因此不仅 支持被传递，还支持类型转换。 初始化： ch4 := make(chan int) ch5 := \u003c-chan int(ch4) // ch5就是一个单向的读取channel ch6 := chan\u003c- int(ch4) // ch6 是一个单向的写入channel 基于 ch4，我们通过类型转换初始化了两个单向 channel：单向读的 ch5 和单向写的 ch6。 5.7 关闭 channel 关闭 channel 非常简单，直接使用 Go 语言内置的 close()函数即可： close(ch) 如何判断一个 channel 是否已经被关 闭？我们可以在读取的时候使用多重返回值的方式： x,ok := \u003c- ch ","date":"2023-04-06","objectID":"/golang_quick/:5:5","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"6 多核并行化 下面我们来模拟一个完全可以并行的计算任务：计算 N 个整型数的总和。我们可以将所有整 型数分成 M 份，M 即 CPU 的个数。让每个 CPU 开始计算分给它的那份计算任务，最后将每个 CPU 的计算结果再做一次累加，这样就可以得到所有 N 个整型数的总和： type Vector []float64 // 分配给每个CPU的计算任务 func (v Vector) DoSome(i, n int, u Vector, c chan int) { for ; i \u003c n; i++ { v[i] += u.Op(v[i]) } c \u003c- 1 // 发信号告诉任务管理者我已经计算完成了 } const NCPU = 16 // 假设总共有16核 func (v Vector) DoAll(u Vector) { c := make(chan int, NCPU) // 用于接收每个CPU的任务完成信号 for i := 0; i \u003c NCPU; i++ { go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c) } // 等待所有CPU的任务完成 for i := 0; i \u003c NCPU; i++ { \u003c-c // 获取到一个数据，表示一个CPU计算完成了 } // 到这里表示所有计算已经结束 } 这或许可能只在一个核上跑。在 Go 语言升级到默认支持多 CPU 的某个版本之前，我们可以先通过设置环境变量 GOMAXPROCS 的值来控制使用多少个 CPU 核心。具体操作方法是通过直接设置环境变量 GOMAXPROCS 的值，或者在代码中启动 goroutine 之前先调用以下这个语句以设置使用 16 个 CPU 核心： runtime.GOMAXPROCS(16) 到底应该设置多少个 CPU 核心呢，其实runtime包中还提供了另外一个函数**NumCPU()**来获 取核心数。 ","date":"2023-04-06","objectID":"/golang_quick/:5:6","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"7 出让时间片 我们可以在每个 goroutine 中控制何时主动出让时间片给其他 goroutine，这可以使用 runtime 包中的 Gosched()函数实现。 如果要比较精细地控制 goroutine 的行为，就必须比较深入地了解 Go 语言开发包中 runtime 包所提供的具体功能。 ","date":"2023-04-06","objectID":"/golang_quick/:5:7","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"8 同步 Go 语言包中的 sync 包提供了两种锁类型：sync.Mutex和sync.RWMutex。 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等 到这个 goroutine 释放该 Mutex。RWMutex 相对友好些，是经典的单写多读模型。 8.1 全局唯一性操作 Go 语言提供了一个 Once 类型来保证全局的唯一性操作，具体代码如下： var a string var once sync.Once func setup() { a = \"hello, world\" } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } once 的 Do()方法可以保证在全局范围内只调用指定的函数一次（这里指 setup()函数），而且所有其他 goroutine 在调用到此语句时，将会先被阻塞，直至全局唯一的 once.Do()调用结束后才继续（继续执行此语句后的语句，此语句不再执行）。 为了更好地控制并行中的原子性操作，sync 包中还包含一个 atomic 子包，它提供了对于一 些基础数据类型的原子操作函数，比如下面这个函数： func CompareAndSwapUint64(val *uint64, old, new uint64) (swapped bool) 就提供了比较和交换两个 uint64 类型数据的操作。这让开发者无需再为这样的操作专门添加 Lock 操作。 8.2 waitGroup WaitGroup 用于等待一组线程的结束。父线程调用 Add 方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用 Done 方法。同时，主线程里可以调用 Wait 方法阻塞至所有线程结束。 但在使用时，也有一些问题需要注意 通过 WaitGroup 提供的三个函数：Add,Done,Wait，可以轻松实现等待某个协程或协程组完成的同步操作。但在使用时要注意: Add 的数量和 Done 的调用数量必须相等。 WaitGroup 结构一旦定义就不能复制。 WaitGroup 在需要等待多个任务结束再返回的业务来说还是很有用的，但现实中用的更多的可能是，先等待一个协程组，若所有协程组都正确完成，则一直等到所有协程组结束；若其中有一个协程发生错误，则告诉协程组的其他协程，全部停止运行（本次任务失败）以免浪费系统资源。 该场景 WaitGroup 是无法实现的，那么该场景该如何实现呢，就需要用到通知机制，其实也可以用 channel 来实现，具体的解决办法，请看后续的文章。 这样说来，WaitGroup 的使用场景是有限的。 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup() func handle(n int) { defer wg.Done() fmt.Println(n) } func main() { for i=0; i\u003c=10; i++{ wg.Add(1) go handle(i) } wg.Wait() } /* WaitGroup是sync包中提供的，它可以让子协程执行完，主协程再死亡。从而达到优雅退出的效果。 注意： 1. Add函数：开启几个子协程就需要执行几次该函数。 2. Done函数：执行几次Add函数就需要执行几次Done函数。 3. Wait函数：只执行一次，就是在子协程全部执行完成后。 */ 8.3 互斥锁读写锁 互斥锁和读写锁用于处理高并发时对临界区资源操作的同步问题 互斥锁：在某一方法对数据进行操作时，会将该数据进行上锁操作，此时其他任何对该数据进行操作的方法都会进入等待，只有当上锁的方法主动解锁其他方法才能得到对该数据的操作权。 读写锁：互斥锁影响了高并发服务的性能。读写锁就是为了解决这类问题的。写数据时上锁，其他协程都不可以对该数据进行读和写；读数据时不上锁，其他协程都可以读和写。上读锁时，只能读不可写；读锁释放，才可写。 package main import ( \"fmt\" \"sync\" \"time\" ) var rwLock sync.RWMutex var wg sync.WaitGroup func read(){ defer wg.Done() rwLock.RLock() fmt.Println(\"读取数据\") time.Sleep(time.Second) fmt.Println(\"读取成功\") rwLock.RUnlock() } func write(){ defer wg.Done() rwLock.Lock() fmt.Println(\"修改数据\") time.Sleep(time.Second*10) fmt.Println(\"修改成功\") rwLock.Unlock() } func main() { wg.Add(10) for i := 0;i\u003c5;i++ { go read() } for i := 0;i\u003c5;i++ { go write() } wg.Wait() } 8.4 通道操作 通道可以完成多个协程的通信，通过灵活使用 各种类型的通道的读写通道操作，完成复杂的同步逻辑。例子如下示例代码所示。 无缓冲通道 有缓冲通道 单向通道 双向通道 package main import ( \"encoding/csv\" \"fmt\" \"os\" \"strconv\" \"sync\" \"time\" ) type Server struct { } func (server *Server) Connect() chan []string { session := make(chan []string, 128) //监听session go func(c chan []string) { file, _ := os.OpenFile(\"./test.csv\", os.O_CREATE|os.O_TRUNC, 0666) defer file.Close() writer := csv.NewWriter(file) defer file.Close() for { strs := \u003c-c if strs[0] == \"CLOSE\" { writer.Write(strs) writer.Flush() fmt.Println(\"结束通信\") break } writer.Write(strs) writer.Flush() } }(session) fmt.Println(\"建立连接成功!\") return session } func NewServer() *Server { return \u0026Server{ } } type Client struct { conn chan []string } func NewClient(server *Server) *Client { //建立客户端的同时，使用通道建立协程间的通信 c := server.Connect() return \u0026Client{c} } func (client *Client) Send(strs []string) { client.conn \u003c- strs } var wp sync.WaitGroup func main() { server := NewServer() client := NewClient(server) for i := 0; i \u003c 10000; i++ { wp.Add(1) go func() { defer wp.Done() client.Send([]string{\"hello\", strconv.Itoa(i)}) }() } //time.Sleep(time.Duration(1) * time.Second) wp.Wait() go client.Send([]string{\"CLOSE\"}) time.Sleep(time.Duration(1) * time.Second) } 8.5 select selet 的应用有很多，比如：监控异步 IO、超时处理… 如下代码是一个超时处理的 demo，每隔两秒往通道里写数据，select 监控到通道被写入了数据，这就代表已经发生了超时，那么 case 后的语句就可以做一些超时的处理操作。 import \"time\" import \"fmt\" func main() { c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 \u003c- \"result 1\" }() select { case res := \u003c-c1: fmt.Println(res) case \u003c-time.After(time.Second * 1): fmt.Println(\"timeout 1\") } } 8.6 context 当我们的程序逻辑较为复杂的时候，比如：主线程调起了一个协程，该协程又调起了另外一个协程，这种较为复杂的并发场景对协程的控制非常重要，及时关闭不必要的协程可以保证程序的性能，避免不必要的资源浪费。这个时候waitGroup就不好用了，因为它全局不可复制，对于层级较深的协程，就不太适用了。这个时候，就必须使用channel和select结合使用了。Golang 标准库已经为我们封装好了这种工具","date":"2023-04-06","objectID":"/golang_quick/:5:8","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"网络编程 ","date":"2023-04-06","objectID":"/golang_quick/:6:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 TCP 1.1 TCP Server package main import ( \"bufio\" \"fmt\" \"io\" \"net\" ) func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:5000\") if err != nil { fmt.Println(\"Error:\", err.Error()) } for { conn, err := server.Accept() if err != nil { fmt.Println(\"Error:\", err.Error()) } go func(c net.Conn) { defer c.Close() for { reader := bufio.NewReader(c) var receive [128]byte n, err := reader.Read(receive[:]) if err != nil { if err != io.EOF { fmt.Println(\"Error:\", err) } break } fmt.Println(\"receive:\", string(receive[:n])) c.Write([]byte(\"你好\")) } }(conn) } } 1.2 TCP Client func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") if err != nil { fmt.Println(\"Error:\", err.Error()) } defer conn.Close() _, err = conn.Write([]byte(\"hello\")) if err != nil { fmt.Println(\"Error:\", err.Error()) } response := [128]byte{} n, err := conn.Read(response[:]) if err != nil { fmt.Println(\"Error:\", err.Error()) } fmt.Println(\"response:\", string(response[:n])) } ","date":"2023-04-06","objectID":"/golang_quick/:6:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 UDP 2.1 UDP Server func main() { server, err := net.ListenUDP(\"udp\", \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 5000, }) if err != nil { fmt.Println(\"Error:\", err.Error()) } defer server.Close() for { var data [1024]byte n, addr, err := server.ReadFromUDP(data[:]) if err != nil { fmt.Println(\"Error:\", err.Error()) } fmt.Printf(\"data:%v addr:%v count:%v\\n\", string(data[:n]), addr, n) _, err = server.WriteToUDP(data[:n], addr) // 发送数据 if err != nil { fmt.Println(\"write to udp failed, err:\", err) continue } } } ","date":"2023-04-06","objectID":"/golang_quick/:6:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 HTTP 3.1 HTTP Server func ListenAndServe(addr string, handler Handler) error 该方法用于在指定的 TCP 网络地址 addr 进行监听，然后调用服务端处理程序来处理传入的连 接请求。该方法有两个参数：第一个参数 addr 即监听地址；第二个参数表示服务端处理程序， 通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻 辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中。 package main import ( \"fmt\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) { defer request.Body.Close() if request.Method == \"GET\" { fmt.Fprint(writer, \"Hello\", request.RemoteAddr) return } if request.Method == \"POST\" { request.ParseForm() //这里需要先解析一下，才能拿到结果 params := request.PostForm for k, v := range params { fmt.Println(k,v) } return } }) err := http.ListenAndServe(\"0.0.0.0:5000\", nil) if err != nil { fmt.Println(\"Error:\", err.Error()) return } } 3.2 HTTP Client package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"net/url\" ) func MyGetNoParams(url_ string) (responseBody string, err error) { resp, err := http.Get(url_) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } return string(body), nil } func MyGetParams(url_ string) (responseBody string, err error) { params := url.Values{} params.Set(\"wd\", \"hello\") u, err := url.ParseRequestURI(url_) if err != nil { fmt.Println(\"Error:\", err) return \"\", err } fmt.Println(u.String()) //http://www.baidu.com u.RawQuery = params.Encode() //将需要携带的参数信息拼接到当前url的尾部 fmt.Println(u.String()) //http://www.baidu.com?wd=hello return MyGetNoParams(u.String()) } func MyPost(url_ string) { params := url.Values{} params.Set(\"wd\", \"hello\") resp, err := http.PostForm(url_, params) if err!= nil{ fmt.Println(err) } defer resp.Body.Close() body,err := ioutil.ReadAll(resp.Body) if err!= nil{ fmt.Println(err) } fmt.Println(string(body)) } func main() { //resp, err := MyGetParams(\"http://www.baidu.com\") //if err != nil { // fmt.Println(\"Error:\", err) // return //} //fmt.Println(resp) MyPost(\"http://127.0.0.1:5000/\") } ","date":"2023-04-06","objectID":"/golang_quick/:6:3","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4 RPC go 语言进程间通信的方法有两种：HTTP、RPC。 RPC（Remote Procedure Call，远程过程调用）是一种通过网络从远程计算机程序上请求服 务，而不需要了解底层网络细节的应用程序通信协议。RPC 协议构建于 TCP 或 UDP，或者是 HTTP 之上，允许开发者直接调用另一台计算机上的程序，而开发者无需额外地为这个调用过程编写网 络通信相关代码，使得开发包括网络分布式程序在内的应用程序更加容易。 RPC 采用客户端—服务器（Client/Server）的工作模式。请求程序就是一个客户端（Client）， 而服务提供程序就是一个服务器（Server）。当执行一个远程过程调用时，客户端程序首先发送一 个带有参数的调用信息到服务端，然后等待服务端响应。在服务端，服务进程保持睡眠状态直到 客户端的调用信息到达为止。当一个调用信息到达时，服务端获得进程参数，计算出结果，并向 客户端发送应答信息，然后等待下一个调用。最后，客户端接收来自服务端的应答信息，获得进 程结果，然后调用执行并继续进行。 一个 RPC 服务端可以注册多个不同类型 的对象，但不允许注册同一类型的多个对象。 一个对象中只有满足如下这些条件的方法，才能被 RPC 服务端设置为可供远程访问： 必须是在对象外部可公开调用的方法（首字母大写）； 必须有两个参数，且参数的类型都必须是包外部可以访问的类型或者是 Go 内建支持的类 型； 第二个参数必须是一个指针； 方法必须返回一个 error 类型的值。 以上四点可以用一行代码表示：func (t *T) MethodName(argType T1, replyType *T2) error 该方法（MethodName）的第一个参数表示由 RPC 客户端传入的参数，第二个参数表示要返 回给 RPC 客户端的结果，该方法最后返回一个 error 类型的值。 4.1 RPC 服务端 RPC 服务端可以通过调用 rpc.ServeConn 处理单个连接请求。多数情况下，通过 TCP 或 是 HTTP 在某个网络地址上进行监听来创建该服务是个不错的选择。 4.2 RPC 客户端 在 RPC 客户端，Go 的 net/rpc 包提供了便利的 rpc.Dial() 和 rpc.DialHTTP() 方法 来与指定的 RPC 服务端建立连接。在建立连接之后，Go 的 net/rpc 包允许我们使用同步或者 异步的方式接收 RPC 服务端的处理结果。调用 RPC 客户端的 **Call() 方法则进行同步处理，**这 时候客户端程序按顺序执行，只有接收完 RPC 服务端的处理结果之后才可以继续执行后面的程 序。当调用 RPC 客户端的 Go() 方法时，则可以进行异步处理，RPC 客户端程序无需等待服务 端的结果即可执行后面的程序，而当接收到 RPC 服务端的处理结果时，再对其进行相应的处理。 无论是调用 RPC 客户端的 Call() 或者是 Go() 方法，都必须指定要调用的服务及其方法名称， 以及一个客户端传入参数的引用，还有一个用于接收处理结果参数的指针。 如果没有明确指定 RPC 传输过程中使用何种编码解码器，默认将使用 Go 标准库提供的 encoding/gob 包进行数据传输。 4.3 RPC 服务端与客户端代码示例 package myRpc import \"errors\" type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(\"divide by zero\") } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } 4.3.1 RPC 服务端 package main import ( \"go_learn/myNet/myRpc\" \"log\" \"net\" \"net/http\" \"net/rpc\" ) func main() { arith := new(myRpc.Arith) rpc.Register(arith) rpc.HandleHTTP() l, e := net.Listen(\"tcp\", \"127.0.0.1:1234\") if e != nil { log.Fatal(\"listen error:\", e) } http.Serve(l, nil) } 此时，RPC 服务端注册了一个 Arith 类型的对象及其公开方法 Arith.Multiply()和 Arith.Divide()供 RPC 客户端调用。 4.3.2 RPC 客户端 RPC 在调用服务端提供的方法之前，必须先与 RPC 服务 端建立连接。 package main import ( \"fmt\" \"go_learn/myNet/myRpc\" \"log\" \"net/rpc\" ) func main() { client, err := rpc.DialHTTP(\"tcp\", \"127.0.0.1:1234\") if err != nil { log.Fatal(\"dialing:\", err) } //同步调用程序顺序执行的方式 args := \u0026myRpc.Args{7, 8} var reply int err = client.Call(\"Arith.Multiply\", args, \u0026reply) if err != nil { log.Fatal(\"arith error:\", err) } fmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply) //异步调用 //quotient := new(Quotient) //divCall := client.Go(\"Arith.Divide\", args, \u0026quotient, nil) //replyCall := \u003c-divCall.Done } ","date":"2023-04-06","objectID":"/golang_quick/:6:4","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"5 Gob Gob 是 Go 的一个序列化数据结构的编码解码工具，在 Go 标准库中内置 encoding/gob 包 以供使用。一个数据结构使用 Gob 进行序列化之后，能够用于网络传输。与 JSON 或 XML 这种 基于文本描述的数据交换语言不同，Gob 是二进制编码的数据流，并且 Gob 流是可以自解释的， 它在保证高效率的同时，也具备完整的表达能力。 由于 Gob 仅局 限于使用 Go 语言开发的程序，这意味着我们只能用 Go 的 RPC 实现进程间通信，我们用 Go 编写的 RPC 服务端（或客户端），可能更希望它是通用的，与语言无关的，无 论是 Python 、 Java 或其他编程语言实现的 RPC 客户端，均可与之通信。 ","date":"2023-04-06","objectID":"/golang_quick/:6:5","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"6 JSON 处理 Go 语言的大多数数据类型都可以转化为有效的 JSON 文本，但 channel、complex 和函数这几种 类型除外。 如果转化前的数据结构中出现指针，那么将会转化指针所指向的值，如果指针指向的是零值， 那么 null 将作为转化后的结果输出。 字符串将以 UTF-8 编码转化输出为 Unicode 字符集的字符串，特殊字符比如\u003c将会被转义为 \\u003c 如果 JSON 中的字段在 Go 目标类型中不存在，json.Unmarshal()函数在解码过程中会丢弃 该字段。 目标类型中不可被导出的私有字段（非首 字母大写）将不会受到解码转化的影响。 6.1 解码未知结构的 JSON 数据 空接口是通用类型。如果要解码一段未知结构的 JSON，只需将这段 JSON 数据解码输出到一个空接口即可。 6.2 JSON 的流式读写 Go 内建的 encoding/json 包还提供 Decoder 和 Encoder 两个类型，用于支持 JSON 数据的 流式读写，并提供 NewDecoder()和 NewEncoder()两个函数来便于具体实现。 package main import ( \"encoding/json\" \"log\" \"os\" ) func main() { dec := json.NewDecoder(os.Stdin) enc := json.NewEncoder(os.Stdout) for { var v map[string]interface{} if err := dec.Decode(\u0026v); err != nil { log.Println(err) return } for k := range v { if k != \"Title\" { v[k] = nil, false } } if err := enc.Encode(\u0026v); err != nil { log.Println(err) } } } ","date":"2023-04-06","objectID":"/golang_quick/:6:6","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"常用工具库 ","date":"2023-04-06","objectID":"/golang_quick/:7:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"1 字符串操作 func Compare(a, b string) int //按字典顺序比较a和b字符串大小 func Contains(s, substr string) bool //判断字符串s是否包含substr字符串 func ContainsAny(s, chars string) bool //判断字符串s是否包含chars字符串中的任一字符 func ContainsRune(s string, r rune) bool //判断字符串s是否包含unicode码值r func Count(s, sep string) int //返回字符串s包含字符串sep的个数 func EqualFold(s, t string) bool //判断s和t两个utf8字符串是否相等，忽略大小写 func Fields(s string) []string //将字符串s以空白字符分割，返回一个切片 func FieldsFunc(s string, f func(rune) bool) []string //将字符串s以满足f(r)==true的字符分割，返回一个切片 func HasPrefix(s, prefix string) bool //判断字符串s是否有前缀字符串prefix func HasSuffix(s, suffix string) bool //判断字符串s是否有前缀字符串suffix func Index(s, sep string) int //返回字符串s中字符串sep首次出现的位置 func IndexAny(s, chars string) int //返回字符串chars中的任一unicode码值r在s中首次出现的位置 func IndexByte(s string, c byte) int //返回字符串s中字符c首次出现位置 func IndexFunc(s string, f func(rune) bool) int //返回字符串s中满足函数f(r)==true字符首次出现的位置 func IndexRune(s string, r rune) int //返回unicode码值r在字符串中首次出现的位置 func Join(a []string, sep string) string //将a中的所有字符串连接成一个字符串，使用字符串sep作为分隔符 func LastIndex(s, sep string) int //返回字符串s中字符串sep最后一次出现的位置 func LastIndexAny(s, chars string) int //返回字符串s中任意一个unicode码值r最后一次出现的位置 func LastIndexByte(s string, c byte) int //返回字符串s中字符c最后一次出现的位置 func LastIndexFunc(s string, f func(rune) bool) int //返回字符串s中满足函数f(r)==true字符最后一次出现的位置 func Map(mapping func(rune) rune, s string) string //将字符串s中的每个字符r按函数mapping(r)的规则转换并返回 func Repeat(s string, count int) string //将字符串s重复count次返回 func Replace(s, old, new string, n int) string //替换字符串s中old字符为new字符并返回，n\u003c0是替换所有old字符串 func Split(s, sep string) []string //将字符串s以sep作为分隔符进行分割，分割后字符最后去掉sep func SplitAfter(s, sep string) []string //将字符串s以sep作为分隔符进行分割，分割后字符最后附上sep func SplitAfterN(s, sep string, n int) []string //将字符串s以sep作为分隔符进行分割，分割后字符最后附上sep，n决定返回的切片数 func SplitN(s, sep string, n int) []string //将字符串s以sep作为分隔符进行分割，分割后字符最后去掉sep，n决定返回的切片数 func Title(s string) string //将字符串s每个单词首字母大写返回 func ToLower(s string) string //将字符串s转换成小写返回 func ToLowerSpecial(_case unicode.SpecialCase, s string) string //将字符串s中所有字符按_case指定的映射转换成小写返回 func ToTitle(s string) string //将字符串s转换成大写返回 func ToTitleSpecial(_case unicode.SpecialCase, s string) string //将字符串s中所有字符按_case指定的映射转换成大写返回 func ToUpper(s string) string //将字符串s转换成大写返回 func ToUpperSpecial(_case unicode.SpecialCase, s string) string //将字符串s中所有字符按_case指定的映射转换成大写返回 func Trim(s string, cutset string) string //将字符串s中首尾包含cutset中的任一字符去掉返回 func TrimFunc(s string, f func(rune) bool) string //将字符串s首尾满足函数f(r)==true的字符去掉返回 func TrimLeft(s string, cutset string) string //将字符串s左边包含cutset中的任一字符去掉返回 func TrimLeftFunc(s string, f func(rune) bool) string //将字符串s左边满足函数f(r)==true的字符去掉返回 func TrimPrefix(s, prefix string) string //将字符串s中前缀字符串prefix去掉返回 func TrimRight(s string, cutset string) string //将字符串s右边包含cutset中的任一字符去掉返回 func TrimRightFunc(s string, f func(rune) bool) string //将字符串s右边满足函数f(r)==true的字符去掉返回 func TrimSpace(s string) string //将字符串s首尾空白去掉返回 func TrimSuffix(s, suffix string) string //将字符串s中后缀字符串prefix去掉返回 ","date":"2023-04-06","objectID":"/golang_quick/:8:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2 文件操作 使用 io/ioutil 进行读写操作 使用 OS 进行读写操作 ","date":"2023-04-06","objectID":"/golang_quick/:9:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2.1 io/ioutil 进行读写操作 读文件： package main import ( \"fmt\" \"io/ioutil\" ) func main() { b, err := ioutil.ReadFile(\"e:/tt.txt\") if err != nil { fmt.Println(err) } fmt.Println(b) str := string(b) fmt.Println(str) } 写文件： package main import ( \"io/ioutil\" ) func check(e error) { if e != nil { panic(e) } } func main() { d1 := []byte(\"hello\\ngo\\n\") err := ioutil.WriteFile(\"e:tt2.txt\", d1, 0644) check(err) } ","date":"2023-04-06","objectID":"/golang_quick/:9:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"2.2 使用 OS 读写文件 带缓冲的大文件读取： var path = \"...\" var savePath = \"...\" file, err := os.Open(path) defer file.Close() if err != nil { log.Println(\"文件打开失败!\") } buf := bufio.NewReader(file) for { line, err := buf.ReadBytes('\\n') if err == io.EOF { log.Println(\"读文件结束！\") break } if err != nil { log.Println(\"读文件失败:\", err) } } 写文件： file, err := os.OpenFile(\"test.txt\", os.O_WRONLY | os.O_CREATE | os.O_APPEND, 0600) if err != nil { fmt.Println(\"打开文件失败; err=\",err) return } defer file.Close() // 使用缓冲的方式写字符串到文件 writer := bufio.NewWriter(file) for i:=0; i\u003c3; i++ { if _, err := writer.WriteString(\"Hello 北京\"+\"\\n\"); err != nil { fmt.Println(\"文件写入失败, err=\", err) break } } // 使用缓冲的方式写byte切片到文件 sli := []byte(\"Hello 北京\\n\") for i:=0; i\u003c 3; i++ { if _, err := writer.Write(sli); err != nil { fmt.Println(\"文件写入失败, err=\", err) break } } writer.Flush() ","date":"2023-04-06","objectID":"/golang_quick/:9:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3 Json 参考: golang 开源 json 库使用笔记 encoding/json, 官方自带的, 文档最多, 易用性差, 性能差 go-simplejson, gabs, jason 等衍生包, 简单且易用, 易于阅读, 便于维护, 但性能最差 easyjson, ffjson 此类包, 适合固定结构的 json, 易用性一般, 维护成本高, 性能特别好 jsonparser 适合动态和固定结构的 json, 简单且易用, 维护成本低, 性能极好 ","date":"2023-04-06","objectID":"/golang_quick/:10:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3.1 encoding/json func Marshal(v interface{}) ([]byte, error) // 将Go中数据类型转换为 json 字符串的字节切片 func Unmarshal(data []byte, v interface{}) error // 反序列化json字符串 func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error //缩进显示json字符串 func Compact(dst *bytes.Buffer, src []byte) error //压缩无效空白符 序列化： package main import ( \"encoding/json\" \"fmt\" ) type Student struct { Id int `json:\"id\"` Name string `json:\"name\"` Hobby []Hobby } type Hobby struct { Name string describe string } func main() { var s0 = Student{ Id: 10001, Name: \"张三\", Hobby: []Hobby{ { Name: \"游泳\", describe: \"游泳。。。。\", }, { Name: \"钓鱼\", describe: \"台钓\", }, }, } ret, err := json.Marshal(\u0026s0) if err != nil { fmt.Println(\"序列化失败\") return } fmt.Println(string(ret)) } // 输出：{\"id\":10001,\"name\":\"张三\",\"Hobby\":[{\"Name\":\"游泳\"},{\"Name\":\"钓鱼\"}]} 反序列化： package main import ( \"encoding/json\" \"fmt\" ) type User struct { Name string `json:\"name\"` Class []string `json:\"class\"` } func main() { str := `{\"10001\": {\"name\": \"张三\", \"class\": [\"物理\",\"化学\",\"生物\"]}}` var user01 interface{} if err := json.Unmarshal([]byte(str), \u0026user01); err != nil { fmt.Println(\"反序列化失败,err=\", err) return } fmt.Printf(\"type:%T, value:%v\\n\", user01, user01) // 使用类型断言才能取值 if user, ok := user01.(map[string]interface {}); ok { fmt.Printf(\"type:%T, value:%v\\n\", user[\"10001\"], user[\"10001\"]) } } ","date":"2023-04-06","objectID":"/golang_quick/:10:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"3.2 simplejson 常用方法 常用于不需要创建结构体时，采用链式调用完成处理。 # \"github.com/bitly/go-simplejson\" 1. Json 结构体 type Json struct { // contains filtered or unexported fields } 2. 构造函数 func NewJson(body []byte) (*Json, error) 3. 从 io.Reader 接口构造 Json对象 func NewFromReader(r io.Reader) (*Json, error) 4. 断言相关的方法 func (j *Json) String() (string, error) func (j *Json) Int() (int, error) func (j *Json) Int64() (int64, error) func (j *Json) Uint64() (uint64, error) func (j *Json) Bool() (bool, error) func (j *Json) Bytes() ([]byte, error) func (j *Json) StringArray() ([]string, error) func (j *Json) Interface() interface{} func (j *Json) Map() (map[string]interface{}, error) func (j *Json) Array() ([]interface{}, error) 5. 保证返回指定类型的结果, args 设定默认值 func (j *Json) MustInt(args ...int) int func (j *Json) MustString(args ...string) string func (j *Json) MustFloat64(args ...float64) float64 func (j *Json) MustBool(args ...bool) bool func (j *Json) MustStringArray(args ...[]string) []string func (j *Json) MustMap(args ...map[string]interface{}) map[string]interface{} func (j *Json) MustArray(args ...[]interface{}) []interface{} 6. 在map类型中，根据key取值 func (j *Json) Get(key string) *Json 7. 更新json func (j *Json) Del(key string) func (j *Json) Set(key string, val interface{}) 8. 序列化 func (j *Json) Encode() ([]byte, error) func (j *Json) EncodePretty() ([]byte, error) // 带缩进 案例： json 字符串： { \"deploy_type\":\"task\", \"uniqid\":\"task-01\", \"labels\":{ \"deploy_type\":\"db\" }, \"callback_url\":\"https://xxx.xxx.xxx\", \"tasks\":[ { \"cluster_type\":\"vm_cluster\", \"deploy_type\":\"vm_cluster\", \"action\":\"create\", \"labels\":{ \"deploy_type\":\"cluster\" }, \"uniqid\":\"cluster01\", \"name\":\"cluster01\", \"options\":{ \"cadvisor\":true } } ] } 3.2.1 取值 func main() { sJson, err := simplejson.NewJson([]byte(str)) if err != nil { fmt.Printf(\"New json failed, err:%s\\n\", err.Error()) return } // 取labels res1 := sJson.Get(\"labels\").Get(\"deploy_type\").MustString(\"null\") tmp1, _ := json.Marshal(sJson.Get(\"tasks\").MustArray()[0]) // 返回值为 interface，需要重新序列化 tmp2, _ := simplejson.NewJson(tmp1) res2 := tmp2.Get(\"labels\").Get(\"deploy_type\").MustString() fmt.Printf(\"res1:%s,res2:%s\\n\", res1, res2) } 3.2.2 修改值 func main() { sJson, err := simplejson.NewJson([]byte(str)) if err != nil { fmt.Printf(\"New json failed, err:%s\\n\", err.Error()) return } // 删除值 sJson.Del(\"tasks\") // 删除task字段 res1, _:= sJson.EncodePretty() fmt.Println(string(res1)) // 修改值 sJson.Set(\"labels\", false) // 修改labels字段 res2, _:= sJson.EncodePretty() fmt.Println(string(res2)) } ","date":"2023-04-06","objectID":"/golang_quick/:10:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4 csv ","date":"2023-04-06","objectID":"/golang_quick/:11:0","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4.1 流式读文件 func readCsv() { file, err := os.Open(\"./test.csv\") if err != nil { panic(err.Error()) } defer file.Close() reader := csv.NewReader(file) //若要修改分隔符，则可使用：reader.Comma='\\t' ; for { read, err := reader.Read() //每次读一行，返回一个切片 if err == io.EOF { break } if err != nil { panic(err.Error()) } fmt.Println(read) } } ","date":"2023-04-06","objectID":"/golang_quick/:11:1","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"},{"categories":["Golang"],"content":"4.2 写文件 func writeCsv() { file, err := os.OpenFile(\"./test.csv\", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666) //0666是linux的文件权限设定（0777：-rwxrwxrwx ；0666：-rw-rw-rw-） if err != nil { panic(err.Error()) } defer file.Close() writer := csv.NewWriter(file) data := [][]string{{\"2\", \"3\", \"sdasd\"}} for _, v := range data { err := writer.Write(v) if err != nil { panic(err.Error()) } } writer.Flush() fmt.Println(\"write succ！\") } ","date":"2023-04-06","objectID":"/golang_quick/:11:2","tags":["Golang"],"title":"Golang极速上手","uri":"/golang_quick/"}]